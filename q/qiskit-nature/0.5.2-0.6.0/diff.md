# Comparing `tmp/qiskit-nature-0.5.2.tar.gz` & `tmp/qiskit-nature-0.6.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/qiskit-nature-0.5.2.tar", last modified: Wed Dec  7 17:10:30 2022, max compression
+gzip compressed data, was "dist/qiskit-nature-0.6.0.tar", last modified: Fri Apr 14 13:12:08 2023, max compression
```

## Comparing `qiskit-nature-0.5.2.tar` & `qiskit-nature-0.6.0.tar`

### file list

```diff
@@ -1,1081 +1,1104 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/
--rw-r--r--   0 runner    (1001) docker     (123)    11416 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (123)      319 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)     9314 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     8907 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/README.md
--rw-r--r--   0 runner    (1001) docker     (123)       82 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/pyproject.toml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/
--rw-r--r--   0 runner    (1001) docker     (123)        6 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/VERSION.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1661 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/
--rw-r--r--   0 runner    (1001) docker     (123)     3500 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/
--rw-r--r--   0 runner    (1001) docker     (123)     1654 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/
--rw-r--r--   0 runner    (1001) docker     (123)     1212 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1272 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     4095 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/numpy_eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     7050 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/excited_states_eigensolver.py
--rw-r--r--   0 runner    (1001) docker     (123)     2467 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/excited_states_solver.py
--rw-r--r--   0 runner    (1001) docker     (123)    23363 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/qeom.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/
--rw-r--r--   0 runner    (1001) docker     (123)     1403 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    18106 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/adapt_vqe.py
--rw-r--r--   0 runner    (1001) docker     (123)    11004 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/ground_state_eigensolver.py
--rw-r--r--   0 runner    (1001) docker     (123)     4970 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/ground_state_solver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/
--rw-r--r--   0 runner    (1001) docker     (123)     1918 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1922 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/minimum_eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     4569 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/numpy_minimum_eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)    13180 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_ucc_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)    12629 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uvcc_factory.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/
--rw-r--r--   0 runner    (1001) docker     (123)     1520 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5978 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/hf_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     2368 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)    13876 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/mp2_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     4971 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/vscf_initial_point.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/
--rw-r--r--   0 runner    (1001) docker     (123)     2747 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    12786 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/bopes_sampler.py
--rw-r--r--   0 runner    (1001) docker     (123)    20098 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/extrapolator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/
--rw-r--r--   0 runner    (1001) docker     (123)      909 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4264 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/energy_surface_spline.py
--rw-r--r--   0 runner    (1001) docker     (123)     9698 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/harmonic_potential.py
--rw-r--r--   0 runner    (1001) docker     (123)     8746 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/morse_potential.py
--rw-r--r--   0 runner    (1001) docker     (123)     5706 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/potential_base.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/
--rw-r--r--   0 runner    (1001) docker     (123)     1009 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/
--rw-r--r--   0 runner    (1001) docker     (123)     1723 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/
--rw-r--r--   0 runner    (1001) docker     (123)      799 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9310 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/chc.py
--rw-r--r--   0 runner    (1001) docker     (123)     6596 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/puccd.py
--rw-r--r--   0 runner    (1001) docker     (123)     7231 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/succd.py
--rw-r--r--   0 runner    (1001) docker     (123)    21291 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/ucc.py
--rw-r--r--   0 runner    (1001) docker     (123)     2609 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/uccsd.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/utils/
--rw-r--r--   0 runner    (1001) docker     (123)     1161 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    12219 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/utils/fermionic_excitation_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)     3456 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/utils/vibration_excitation_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)    13745 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/uvcc.py
--rw-r--r--   0 runner    (1001) docker     (123)     1861 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/uvccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    11286 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/bogoliubov_transform.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/
--rw-r--r--   0 runner    (1001) docker     (123)      809 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6952 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/fermionic_gaussian_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     5808 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/hartree_fock.py
--rw-r--r--   0 runner    (1001) docker     (123)     4953 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/slater_determinant.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/utils/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4053 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/utils/givens_rotations.py
--rw-r--r--   0 runner    (1001) docker     (123)     3738 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/vscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     2359 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/constants.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/converters/
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/converters/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)     1086 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    21012 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/qubit_converter.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/utils/
--rw-r--r--   0 runner    (1001) docker     (123)      887 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2240 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/utils/list_or_dict.py
--rw-r--r--   0 runner    (1001) docker     (123)    15435 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/deprecation.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/
--rw-r--r--   0 runner    (1001) docker     (123)     1050 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/bosonic_bases/
--rw-r--r--   0 runner    (1001) docker     (123)      948 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/bosonic_bases/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1678 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/bosonic_bases/bosonic_basis.py
--rw-r--r--   0 runner    (1001) docker     (123)    16915 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/bosonic_bases/harmonic_basis.py
--rw-r--r--   0 runner    (1001) docker     (123)    18545 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/molecule.py
--rw-r--r--   0 runner    (1001) docker     (123)    33098 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/qmolecule.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)     7002 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      967 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/base_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)     1441 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/electronic_structure_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)     6184 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/
--rw-r--r--   0 runner    (1001) docker     (123)      635 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5274 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/dumper.py
--rw-r--r--   0 runner    (1001) docker     (123)     4888 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/fcidumpdriver.py
--rw-r--r--   0 runner    (1001) docker     (123)    11019 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/parser.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/
--rw-r--r--   0 runner    (1001) docker     (123)     7690 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/
--rwxr-xr-x   0 runner    (1001) docker     (123)    12784 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/LICENSE.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)    27815 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/QCMatEl.py
--rwxr-xr-x   0 runner    (1001) docker     (123)    18069 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/QCOpMat.py
--rw-r--r--   0 runner    (1001) docker     (123)      930 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (123)    33018 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.F
--rw-r--r--   0 runner    (1001) docker     (123)   132096 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cp310-win_amd64.pyd
--rw-r--r--   0 runner    (1001) docker     (123)   125952 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cp37-win_amd64.pyd
--rw-r--r--   0 runner    (1001) docker     (123)   126464 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cp38-win_amd64.pyd
--rw-r--r--   0 runner    (1001) docker     (123)   129024 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cp39-win_amd64.pyd
--rwxr-xr-x   0 runner    (1001) docker     (123)   556024 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   420344 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   481832 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   452040 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   481976 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   489696 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   525864 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   242888 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so
--rw-r--r--   0 runner    (1001) docker     (123)     5203 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_forces_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)     3058 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_log_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)    12786 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_log_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     2139 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    17940 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussiandriver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/hdf5d/
--rw-r--r--   0 runner    (1001) docker     (123)      568 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/hdf5d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5119 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/hdf5d/hdf5driver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/psi4d/
--rw-r--r--   0 runner    (1001) docker     (123)     1558 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/psi4d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5259 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/psi4d/_template.txt
--rw-r--r--   0 runner    (1001) docker     (123)     8325 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/psi4d/psi4driver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyquanted/
--rw-r--r--   0 runner    (1001) docker     (123)     1988 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyquanted/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    17754 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyquanted/pyquantedriver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyscfd/
--rw-r--r--   0 runner    (1001) docker     (123)     1165 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyscfd/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    27394 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py
--rw-r--r--   0 runner    (1001) docker     (123)     1071 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/vibrational_structure_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)     5188 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/vibrational_structure_molecule_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)     1209 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/units_type.py
--rw-r--r--   0 runner    (1001) docker     (123)     1787 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/drivers/watson_hamiltonian.py
--rw-r--r--   0 runner    (1001) docker     (123)      786 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/exceptions.py
--rw-r--r--   0 runner    (1001) docker     (123)     9905 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/hdf5.py
--rw-r--r--   0 runner    (1001) docker     (123)     2741 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/list_or_dict.py
--rw-r--r--   0 runner    (1001) docker     (123)     6179 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/logging.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)     2146 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    22722 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/bksf.py
--rw-r--r--   0 runner    (1001) docker     (123)     5701 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/bravyi_kitaev_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1787 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/direct_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1199 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/fermionic_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1925 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/jordan_wigner_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     5505 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/linear_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     8148 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/logarithmic_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2291 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/parity_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     6024 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/qubit_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1156 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/spin_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1213 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/vibrational_mapper.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/operators/
--rw-r--r--   0 runner    (1001) docker     (123)     1091 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/operators/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)     1251 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    27314 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/fermionic_op.py
--rw-r--r--   0 runner    (1001) docker     (123)    14781 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/quadratic_hamiltonian.py
--rw-r--r--   0 runner    (1001) docker     (123)     2228 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/second_quantized_op.py
--rw-r--r--   0 runner    (1001) docker     (123)    21402 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/spin_op.py
--rw-r--r--   0 runner    (1001) docker     (123)    23187 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/vibrational_op.py
--rw-r--r--   0 runner    (1001) docker     (123)     2482 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/optionals.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/
--rw-r--r--   0 runner    (1001) docker     (123)      813 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/
--rw-r--r--   0 runner    (1001) docker     (123)      749 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/
--rw-r--r--   0 runner    (1001) docker     (123)     5305 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_contacts/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_contacts/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2970 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_contacts/contact_map.py
--rw-r--r--   0 runner    (1001) docker     (123)     8964 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_contacts/contact_map_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_distances/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_distances/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6295 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_distances/distance_map.py
--rw-r--r--   0 runner    (1001) docker     (123)    11734 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_distances/distance_map_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/data_loaders/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/data_loaders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1805 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/data_loaders/energy_matrix_loader.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/exceptions/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/exceptions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      705 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_residue_exception.py
--rw-r--r--   0 runner    (1001) docker     (123)      713 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_side_chain_exception.py
--rw-r--r--   0 runner    (1001) docker     (123)      716 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_size_exception.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1152 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/interaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     2455 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/mixed_interaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     2045 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/miyazawa_jernigan_interaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     1318 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/random_interaction.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/resources/
--rw-r--r--   0 runner    (1001) docker     (123)      794 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/resources/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3969 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/resources/mj_matrix.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1861 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/penalty_parameters.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/beads/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/beads/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5215 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/beads/base_bead.py
--rw-r--r--   0 runner    (1001) docker     (123)     2926 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/beads/main_bead.py
--rw-r--r--   0 runner    (1001) docker     (123)     3066 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/beads/side_bead.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/chains/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/chains/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2445 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/chains/base_chain.py
--rw-r--r--   0 runner    (1001) docker     (123)     6779 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/chains/main_chain.py
--rw-r--r--   0 runner    (1001) docker     (123)     3242 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/chains/side_chain.py
--rw-r--r--   0 runner    (1001) docker     (123)     1865 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/pauli_ops_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)     3651 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/peptide.py
--rw-r--r--   0 runner    (1001) docker     (123)     5302 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/protein_folding_problem.py
--rw-r--r--   0 runner    (1001) docker     (123)    20630 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/qubit_op_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/qubit_utils/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/qubit_utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3417 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/qubit_utils/qubit_fixing.py
--rw-r--r--   0 runner    (1001) docker     (123)     4414 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/qubit_utils/qubit_number_reducer.py
--rw-r--r--   0 runner    (1001) docker     (123)     2186 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/residue_validator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1606 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/sampling/sampling_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)     1320 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7806 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/base_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/
--rw-r--r--   0 runner    (1001) docker     (123)      873 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/builders/
--rw-r--r--   0 runner    (1001) docker     (123)      536 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/builders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5937 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/builders/hopping_ops_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)    11189 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/electronic_structure_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/
--rw-r--r--   0 runner    (1001) docker     (123)     1796 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6114 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattice_model_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/
--rw-r--r--   0 runner    (1001) docker     (123)     1198 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      683 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/boundary_condition.py
--rw-r--r--   0 runner    (1001) docker     (123)    13159 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/hyper_cubic_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     8182 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     1838 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/line_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     2505 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/square_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)    10928 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/triangular_lattice.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/
--rw-r--r--   0 runner    (1001) docker     (123)      962 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4913 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/fermi_hubbard_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     3611 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/ising_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     3433 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/lattice_model.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/
--rw-r--r--   0 runner    (1001) docker     (123)      829 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/builders/
--rw-r--r--   0 runner    (1001) docker     (123)      538 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/builders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4406 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/builders/hopping_ops_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)     2127 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/builders/vibrational_label_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)     8892 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/vibrational_structure_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/properties/
--rw-r--r--   0 runner    (1001) docker     (123)     1005 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5732 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/grouped_property.py
--rw-r--r--   0 runner    (1001) docker     (123)     4507 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/property.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)     1454 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3281 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/driver_metadata.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/
--rw-r--r--   0 runner    (1001) docker     (123)     2660 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    14067 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/angular_momentum.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/bases/
--rw-r--r--   0 runner    (1001) docker     (123)     1404 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/bases/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/bases/electronic_basis.py
--rw-r--r--   0 runner    (1001) docker     (123)     4681 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/bases/electronic_basis_transform.py
--rw-r--r--   0 runner    (1001) docker     (123)    14831 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/dipole_moment.py
--rw-r--r--   0 runner    (1001) docker     (123)    13572 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/electronic_energy.py
--rw-r--r--   0 runner    (1001) docker     (123)     6608 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/electronic_structure_driver_result.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/
--rw-r--r--   0 runner    (1001) docker     (123)     1310 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    17698 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/electronic_integrals.py
--rw-r--r--   0 runner    (1001) docker     (123)     9675 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/integral_property.py
--rw-r--r--   0 runner    (1001) docker     (123)     6735 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/one_body_electronic_integrals.py
--rw-r--r--   0 runner    (1001) docker     (123)    11182 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/two_body_electronic_integrals.py
--rw-r--r--   0 runner    (1001) docker     (123)     5532 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/magnetization.py
--rw-r--r--   0 runner    (1001) docker     (123)    12425 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/particle_number.py
--rw-r--r--   0 runner    (1001) docker     (123)     1003 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/types.py
--rw-r--r--   0 runner    (1001) docker     (123)     3391 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/second_quantized_property.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/
--rw-r--r--   0 runner    (1001) docker     (123)     1902 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/bases/
--rw-r--r--   0 runner    (1001) docker     (123)     1369 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/bases/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3155 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/bases/harmonic_basis.py
--rw-r--r--   0 runner    (1001) docker     (123)     4152 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/bases/vibrational_basis.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/integrals/
--rw-r--r--   0 runner    (1001) docker     (123)      959 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/integrals/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    13051 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/integrals/vibrational_integrals.py
--rw-r--r--   0 runner    (1001) docker     (123)     5526 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/occupied_modals.py
--rw-r--r--   0 runner    (1001) docker     (123)     2397 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/types.py
--rw-r--r--   0 runner    (1001) docker     (123)     8807 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/vibrational_energy.py
--rw-r--r--   0 runner    (1001) docker     (123)     5553 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/vibrational_structure_driver_result.py
--rw-r--r--   0 runner    (1001) docker     (123)       27 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/py.typed
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/results/
--rw-r--r--   0 runner    (1001) docker     (123)     2015 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2374 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/bopes_sampler_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     5204 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/eigenstate_result.py
--rw-r--r--   0 runner    (1001) docker     (123)    17646 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/electronic_structure_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     2669 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/lattice_model_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     7996 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/protein_folding_result.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/results/utils/
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5495 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/utils/protein_plotter.py
--rw-r--r--   0 runner    (1001) docker     (123)     5463 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/utils/protein_shape_decoder.py
--rw-r--r--   0 runner    (1001) docker     (123)     6574 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/utils/protein_shape_file_gen.py
--rw-r--r--   0 runner    (1001) docker     (123)     4013 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/results/vibrational_structure_result.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/runtime/
--rw-r--r--   0 runner    (1001) docker     (123)      959 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/runtime/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    15339 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/runtime/vqe_client.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/
--rw-r--r--   0 runner    (1001) docker     (123)      823 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/
--rw-r--r--   0 runner    (1001) docker     (123)     2942 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/
--rw-r--r--   0 runner    (1001) docker     (123)     1134 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1276 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     4082 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/numpy_eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     5907 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/excited_states_eigensolver.py
--rw-r--r--   0 runner    (1001) docker     (123)     2433 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/excited_states_solver.py
--rw-r--r--   0 runner    (1001) docker     (123)    26249 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom.py
--rw-r--r--   0 runner    (1001) docker     (123)     5525 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom_electronic_ops_builder.py
--rw-r--r--   0 runner    (1001) docker     (123)     4120 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom_vibrational_ops_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/
--rw-r--r--   0 runner    (1001) docker     (123)     1210 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5457 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_eigensolver.py
--rw-r--r--   0 runner    (1001) docker     (123)     3195 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_solver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/
--rw-r--r--   0 runner    (1001) docker     (123)     1257 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1918 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/minimum_eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     2648 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/numpy_minimum_eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     6669 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_ucc_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     6189 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uvcc_factory.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/
--rw-r--r--   0 runner    (1001) docker     (123)     1177 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5071 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/hf_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     2163 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)    12013 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/mp2_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     3991 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/vscf_initial_point.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/
--rw-r--r--   0 runner    (1001) docker     (123)      691 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/
--rw-r--r--   0 runner    (1001) docker     (123)     1746 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/
--rw-r--r--   0 runner    (1001) docker     (123)      799 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9332 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/chc.py
--rw-r--r--   0 runner    (1001) docker     (123)     6623 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/puccd.py
--rw-r--r--   0 runner    (1001) docker     (123)    11361 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/succd.py
--rw-r--r--   0 runner    (1001) docker     (123)    22759 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/ucc.py
--rw-r--r--   0 runner    (1001) docker     (123)     2537 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/uccsd.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/utils/
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    12372 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/utils/fermionic_excitation_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)     3479 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/utils/vibration_excitation_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)    15369 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/uvcc.py
--rw-r--r--   0 runner    (1001) docker     (123)     1781 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/uvccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)    11268 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/bogoliubov_transform.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/
--rw-r--r--   0 runner    (1001) docker     (123)      809 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6934 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/fermionic_gaussian_state.py
--rw-r--r--   0 runner    (1001) docker     (123)    10665 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/hartree_fock.py
--rw-r--r--   0 runner    (1001) docker     (123)     4934 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/slater_determinant.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/utils/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4053 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/utils/givens_rotations.py
--rw-r--r--   0 runner    (1001) docker     (123)     7810 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/vscf.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/
--rw-r--r--   0 runner    (1001) docker     (123)     2770 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      893 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/base_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)    12563 2022-12-07 17:10:18.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/electronic_structure_driver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/
--rw-r--r--   0 runner    (1001) docker     (123)     7668 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/
--rwxr-xr-x   0 runner    (1001) docker     (123)    12784 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/LICENSE.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)    27815 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/QCMatEl.py
--rwxr-xr-x   0 runner    (1001) docker     (123)    18069 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/QCOpMat.py
--rw-r--r--   0 runner    (1001) docker     (123)      930 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (123)    33018 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.F
--rw-r--r--   0 runner    (1001) docker     (123)   132096 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp310-win_amd64.pyd
--rw-r--r--   0 runner    (1001) docker     (123)   125952 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp37-win_amd64.pyd
--rw-r--r--   0 runner    (1001) docker     (123)   126464 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp38-win_amd64.pyd
--rw-r--r--   0 runner    (1001) docker     (123)   129024 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp39-win_amd64.pyd
--rwxr-xr-x   0 runner    (1001) docker     (123)   556024 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   420344 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   481832 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   452040 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   481976 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   489696 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   525864 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so
--rwxr-xr-x   0 runner    (1001) docker     (123)   242888 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so
--rw-r--r--   0 runner    (1001) docker     (123)     5497 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussian_forces_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)     3068 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)    10831 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     2139 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussian_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    18805 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussiandriver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/psi4d/
--rw-r--r--   0 runner    (1001) docker     (123)     1086 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/psi4d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3264 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/psi4d/_template.txt
--rw-r--r--   0 runner    (1001) docker     (123)     8521 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/psi4d/psi4driver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/pyscfd/
--rw-r--r--   0 runner    (1001) docker     (123)     1165 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/pyscfd/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    25211 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/pyscfd/pyscfdriver.py
--rw-r--r--   0 runner    (1001) docker     (123)     1220 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/vibrational_structure_driver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/
--rw-r--r--   0 runner    (1001) docker     (123)     1268 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump/
--rw-r--r--   0 runner    (1001) docker     (123)      844 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3108 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump/dumper.py
--rw-r--r--   0 runner    (1001) docker     (123)     6490 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump/fcidump.py
--rw-r--r--   0 runner    (1001) docker     (123)    11256 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump/parser.py
--rw-r--r--   0 runner    (1001) docker     (123)     1950 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump_translator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1909 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/molecule_info.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/
--rw-r--r--   0 runner    (1001) docker     (123)     2268 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4699 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     8257 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_basis_set.py
--rw-r--r--   0 runner    (1001) docker     (123)     1007 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_error.py
--rw-r--r--   0 runner    (1001) docker     (123)     2175 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     6146 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_properties.py
--rw-r--r--   0 runner    (1001) docker     (123)     1100 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_provenance.py
--rw-r--r--   0 runner    (1001) docker     (123)    14946 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_schema.py
--rw-r--r--   0 runner    (1001) docker     (123)     2709 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_schema_input.py
--rw-r--r--   0 runner    (1001) docker     (123)     4642 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_topology.py
--rw-r--r--   0 runner    (1001) docker     (123)    11104 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_wavefunction.py
--rw-r--r--   0 runner    (1001) docker     (123)     8876 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema_translator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/watson/
--rw-r--r--   0 runner    (1001) docker     (123)      858 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/watson/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2929 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/watson/watson_hamiltonian.py
--rw-r--r--   0 runner    (1001) docker     (123)     2117 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/formats/watson_translator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/
--rw-r--r--   0 runner    (1001) docker     (123)     1435 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10123 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/electronic_energy.py
--rw-r--r--   0 runner    (1001) docker     (123)     4356 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/fermi_hubbard_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     1736 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/hamiltonian.py
--rw-r--r--   0 runner    (1001) docker     (123)     3928 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/heisenberg_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     2875 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/ising_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     1389 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattice_model.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/
--rw-r--r--   0 runner    (1001) docker     (123)     1255 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      684 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/boundary_condition.py
--rw-r--r--   0 runner    (1001) docker     (123)    13172 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/hyper_cubic_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)    10662 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     1850 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/line_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     2517 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/square_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)    10939 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/triangular_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)    15311 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/quadratic_hamiltonian.py
--rw-r--r--   0 runner    (1001) docker     (123)     4228 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/vibrational_energy.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/
--rw-r--r--   0 runner    (1001) docker     (123)     2182 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    22607 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/bksf.py
--rw-r--r--   0 runner    (1001) docker     (123)     5725 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/bravyi_kitaev_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1956 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/direct_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1177 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/fermionic_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1967 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/jordan_wigner_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     4717 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/linear_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     7623 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/logarithmic_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2322 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/parity_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)    23199 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/qubit_converter.py
--rw-r--r--   0 runner    (1001) docker     (123)     5971 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/qubit_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1134 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/spin_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     1191 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/vibrational_mapper.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/
--rw-r--r--   0 runner    (1001) docker     (123)     1479 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5282 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/_bits_container.py
--rw-r--r--   0 runner    (1001) docker     (123)     3017 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/commutators.py
--rw-r--r--   0 runner    (1001) docker     (123)    26054 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/electronic_integrals.py
--rw-r--r--   0 runner    (1001) docker     (123)    25575 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/fermionic_op.py
--rw-r--r--   0 runner    (1001) docker     (123)    27981 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/polynomial_tensor.py
--rw-r--r--   0 runner    (1001) docker     (123)    20150 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/sparse_label_op.py
--rw-r--r--   0 runner    (1001) docker     (123)    22339 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/spin_op.py
--rw-r--r--   0 runner    (1001) docker     (123)    11162 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/tensor_ordering.py
--rw-r--r--   0 runner    (1001) docker     (123)     2919 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/vibrational_integrals.py
--rw-r--r--   0 runner    (1001) docker     (123)    24142 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/operators/vibrational_op.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/
--rw-r--r--   0 runner    (1001) docker     (123)     2442 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4435 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/base_problem.py
--rw-r--r--   0 runner    (1001) docker     (123)     7244 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/eigenstate_result.py
--rw-r--r--   0 runner    (1001) docker     (123)      763 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/electronic_basis.py
--rw-r--r--   0 runner    (1001) docker     (123)     3072 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/electronic_properties_container.py
--rw-r--r--   0 runner    (1001) docker     (123)    12999 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/electronic_structure_problem.py
--rw-r--r--   0 runner    (1001) docker     (123)    18254 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/electronic_structure_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     3359 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/harmonic_basis.py
--rw-r--r--   0 runner    (1001) docker     (123)     2897 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/lattice_model_problem.py
--rw-r--r--   0 runner    (1001) docker     (123)     2669 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/lattice_model_result.py
--rw-r--r--   0 runner    (1001) docker     (123)      867 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/lattice_properties_container.py
--rw-r--r--   0 runner    (1001) docker     (123)     4369 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/properties_container.py
--rw-r--r--   0 runner    (1001) docker     (123)     5295 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/vibrational_basis.py
--rw-r--r--   0 runner    (1001) docker     (123)     1229 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/vibrational_properties_container.py
--rw-r--r--   0 runner    (1001) docker     (123)     4036 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/vibrational_structure_problem.py
--rw-r--r--   0 runner    (1001) docker     (123)     4013 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/problems/vibrational_structure_result.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/
--rw-r--r--   0 runner    (1001) docker     (123)     1673 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8797 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/angular_momentum.py
--rw-r--r--   0 runner    (1001) docker     (123)     7686 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/dipole_moment.py
--rw-r--r--   0 runner    (1001) docker     (123)     7112 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/electronic_density.py
--rw-r--r--   0 runner    (1001) docker     (123)     2623 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/magnetization.py
--rw-r--r--   0 runner    (1001) docker     (123)     3159 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/occupied_modals.py
--rw-r--r--   0 runner    (1001) docker     (123)     2539 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/particle_number.py
--rw-r--r--   0 runner    (1001) docker     (123)     1834 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/properties/protocols.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/
--rw-r--r--   0 runner    (1001) docker     (123)     1150 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    21019 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/active_space_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)     1956 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/base_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)     9254 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/basis_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)     4874 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/freeze_core_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)     3685 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/settings.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/
--rw-r--r--   0 runner    (1001) docker     (123)     1037 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)     1374 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1401 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/base_transformer.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/electronic/
--rw-r--r--   0 runner    (1001) docker     (123)     1480 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/electronic/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    20248 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/electronic/active_space_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)     5214 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/electronic/freeze_core_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)      657 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/units.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature/utils/
--rw-r--r--   0 runner    (1001) docker     (123)      891 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6460 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/utils/linalg.py
--rw-r--r--   0 runner    (1001) docker     (123)     2488 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/qiskit_nature/version.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     9314 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    55805 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (123)      215 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       14 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/qiskit_nature.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)      127 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (123)       38 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     3001 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/
--rw-r--r--   0 runner    (1001) docker     (123)      674 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/eigensolver_factories/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/eigensolver_factories/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3246 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     6882 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py
--rw-r--r--   0 runner    (1001) docker     (123)     6148 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/test_excited_states_solvers.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6677 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     6662 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)    11818 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/test_adapt_vqe.py
--rw-r--r--   0 runner    (1001) docker     (123)     6069 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/test_advanced_ucc_variants.py
--rw-r--r--   0 runner    (1001) docker     (123)    27402 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/test_groundstate_eigensolver.py
--rw-r--r--   0 runner    (1001) docker     (123)     3531 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/test_swaprz.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/initial_points/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/initial_points/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/initial_points/resources/
--rw-r--r--   0 runner    (1001) docker     (123)     6550 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/initial_points/resources/test_mp2_initial_point.json
--rw-r--r--   0 runner    (1001) docker     (123)     5029 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/initial_points/test_hf_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     2061 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/initial_points/test_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)    11100 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/initial_points/test_mp2_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     2910 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/initial_points/test_vscf_initial_point.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/pes_samplers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/pes_samplers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/algorithms/pes_samplers/potentials/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/pes_samplers/potentials/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10592 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/pes_samplers/potentials/test_potential.py
--rw-r--r--   0 runner    (1001) docker     (123)    15095 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/pes_samplers/test_bopes_sampler.py
--rw-r--r--   0 runner    (1001) docker     (123)    14840 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/algorithms/pes_samplers/test_extrapolators.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/circuit/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/circuit/library/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4073 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_chc.py
--rw-r--r--   0 runner    (1001) docker     (123)     4938 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_puccd.py
--rw-r--r--   0 runner    (1001) docker     (123)     6019 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_succd.py
--rw-r--r--   0 runner    (1001) docker     (123)     8802 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_ucc.py
--rw-r--r--   0 runner    (1001) docker     (123)    10382 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_uccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)     7600 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_uvcc.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/utils/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8618 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)     2156 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1821 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/ansatzes/utils/vibrational_op_label_creator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/circuit/library/initial_states/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/initial_states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3865 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/initial_states/test_fermionic_gaussian_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     5750 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/initial_states/test_hartree_fock.py
--rw-r--r--   0 runner    (1001) docker     (123)     3501 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/initial_states/test_slater_determinant.py
--rw-r--r--   0 runner    (1001) docker     (123)     1587 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/initial_states/test_vscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     6119 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/circuit/library/test_bogoliubov_transform.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/converters/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/converters/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/converters/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/converters/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    13057 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/converters/second_quantization/test_qubit_converter.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/drivers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8338 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump.py
--rw-r--r--   0 runner    (1001) docker     (123)     5289 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_dumper.py
--rw-r--r--   0 runner    (1001) docker     (123)      381 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_h2.fcidump
--rw-r--r--   0 runner    (1001) docker     (123)     5029 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_lih.fcidump
--rw-r--r--   0 runner    (1001) docker     (123)     1986 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_lih.npz
--rw-r--r--   0 runner    (1001) docker     (123)    24909 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_oh.fcidump
--rw-r--r--   0 runner    (1001) docker     (123)     8008 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_oh.npz
--rw-r--r--   0 runner    (1001) docker     (123)     5043 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_methods_fcidump.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1915 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian.py
--rw-r--r--   0 runner    (1001) docker     (123)     1545 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_extra.py
--rw-r--r--   0 runner    (1001) docker     (123)     7470 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_forces.py
--rw-r--r--   0 runner    (1001) docker     (123)   940592 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_from_mat.mat
--rw-r--r--   0 runner    (1001) docker     (123)     1399 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_from_mat.py
--rw-r--r--   0 runner    (1001) docker     (123)     9527 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log.py
--rw-r--r--   0 runner    (1001) docker     (123)    28437 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_A03.txt
--rw-r--r--   0 runner    (1001) docker     (123)    27861 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_C01.txt
--rw-r--r--   0 runner    (1001) docker     (123)    15552 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_vibrational_energy.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)     2733 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_methods_gaussian.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/hdf5d/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/hdf5d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    48547 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/hdf5d/test_driver_hdf5.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)     3994 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/hdf5d/test_driver_hdf5.py
--rw-r--r--   0 runner    (1001) docker     (123)    15664 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/hdf5d/test_driver_hdf5_legacy.hdf5
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/psi4d/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/psi4d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2693 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/psi4d/test_driver_methods_psi4.py
--rw-r--r--   0 runner    (1001) docker     (123)     1966 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/psi4d/test_driver_psi4.py
--rw-r--r--   0 runner    (1001) docker     (123)     2905 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/psi4d/test_driver_psi4_extra.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/pyquanted/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/pyquanted/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2970 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/pyquanted/test_driver_methods_pyquante.py
--rw-r--r--   0 runner    (1001) docker     (123)     1872 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/pyquanted/test_driver_pyquante.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/pyscfd/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/pyscfd/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7410 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/pyscfd/test_driver_methods_pyscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     3944 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/pyscfd/test_driver_pyscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     8451 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/test_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)     2295 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/test_driver_methods_gsc.py
--rw-r--r--   0 runner    (1001) docker     (123)     8169 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/test_driver_molecule.py
--rw-r--r--   0 runner    (1001) docker     (123)     8999 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/drivers/second_quantization/test_molecule_driver.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/mappers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/resources/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/resources/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    12158 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/resources/bksf_lih.py
--rw-r--r--   0 runner    (1001) docker     (123)    13817 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/resources/reference_direct_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     8090 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/test_bksf_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     4042 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/test_bravyi_kitaev_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2806 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/test_direct_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     4045 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/test_jordan_wigner_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     3135 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/test_linear_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2617 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/test_logarithmic_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     3966 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/mappers/second_quantization/test_parity_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     3977 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/nature_random.py
--rw-r--r--   0 runner    (1001) docker     (123)     4796 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/nature_test_case.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/operators/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/operators/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/operators/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/operators/second_quantization/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    24378 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/operators/second_quantization/test_fermionic_op.py
--rw-r--r--   0 runner    (1001) docker     (123)     9516 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/operators/second_quantization/test_quadratic_hamiltonian.py
--rw-r--r--   0 runner    (1001) docker     (123)    13627 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/operators/second_quantization/test_spin_op.py
--rw-r--r--   0 runner    (1001) docker     (123)     5076 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/operators/second_quantization/test_vibrational_op.py
--rw-r--r--   0 runner    (1001) docker     (123)      929 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/operators/second_quantization/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_contacts/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_contacts/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5224 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_contacts/test_contact_map_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_distances/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_distances/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5870 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_distances/test_distance_map.py
--rw-r--r--   0 runner    (1001) docker     (123)     5052 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_distances/test_distance_map_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/data_loaders/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/data_loaders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1602 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/data_loaders/test_energy_matrix_loader.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/interactions/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/interactions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1651 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/interactions/test_mixed_interaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     1685 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/interactions/test_miyazawa_jernigan_interaction.py
--rw-r--r--   0 runner    (1001) docker     (123)     1143 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/interactions/test_random_interaction.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/beads/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/beads/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2979 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/beads/test_bead_main.py
--rw-r--r--   0 runner    (1001) docker     (123)     3108 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/beads/test_bead_side.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/chains/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/chains/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2241 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/chains/test_chain_main.py
--rw-r--r--   0 runner    (1001) docker     (123)     1671 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/chains/test_chain_side.py
--rw-r--r--   0 runner    (1001) docker     (123)     2791 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/test_peptide.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/qubit_utils/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/qubit_utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2921 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/qubit_utils/test_qubit_fixing.py
--rw-r--r--   0 runner    (1001) docker     (123)     4727 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/qubit_utils/test_qubit_number_reducer.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1268 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/file_parser.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_main/
--rw-r--r--   0 runner    (1001) docker     (123)       85 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_main/test_main_bead_constructor_expected_indic_0
--rw-r--r--   0 runner    (1001) docker     (123)       85 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_main/test_main_bead_constructor_expected_indic_1
--rw-r--r--   0 runner    (1001) docker     (123)       85 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_main/test_main_bead_constructor_expected_indic_2
--rw-r--r--   0 runner    (1001) docker     (123)       85 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_main/test_main_bead_constructor_expected_indic_3
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_side/
--rw-r--r--   0 runner    (1001) docker     (123)       85 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_side/test_side_bead_constructor_expected_indic_0
--rw-r--r--   0 runner    (1001) docker     (123)       85 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_side/test_side_bead_constructor_expected_indic_1
--rw-r--r--   0 runner    (1001) docker     (123)       85 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_side/test_side_bead_constructor_expected_indic_2
--rw-r--r--   0 runner    (1001) docker     (123)       85 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_bead_side/test_side_bead_constructor_expected_indic_3
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/
--rw-r--r--   0 runner    (1001) docker     (123)      215 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_2_expected_1
--rw-r--r--   0 runner    (1001) docker     (123)      215 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_2_expected_2
--rw-r--r--   0 runner    (1001) docker     (123)      303 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_1
--rw-r--r--   0 runner    (1001) docker     (123)      303 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_2
--rw-r--r--   0 runner    (1001) docker     (123)      303 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_3
--rw-r--r--   0 runner    (1001) docker     (123)      303 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_4
--rw-r--r--   0 runner    (1001) docker     (123)      303 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_5
--rw-r--r--   0 runner    (1001) docker     (123)      303 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_6
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map/
--rw-r--r--   0 runner    (1001) docker     (123)       60 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map/test_first_neighbor
--rw-r--r--   0 runner    (1001) docker     (123)      567 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map/test_first_neighbor_side
--rw-r--r--   0 runner    (1001) docker     (123)       50 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map/test_second_neighbor
--rw-r--r--   0 runner    (1001) docker     (123)      248 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map/test_second_neighbor_2
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map_builder/
--rw-r--r--   0 runner    (1001) docker     (123)      101 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_add_distances_side_chain
--rw-r--r--   0 runner    (1001) docker     (123)      101 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_distances_main_chain_1
--rw-r--r--   0 runner    (1001) docker     (123)      101 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_distances_main_chain_2
--rw-r--r--   0 runner    (1001) docker     (123)       48 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_distances_main_chain_3
--rw-r--r--   0 runner    (1001) docker     (123)      127 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_distances_main_chain_4
--rw-r--r--   0 runner    (1001) docker     (123)       97 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_total_distances_1
--rw-r--r--   0 runner    (1001) docker     (123)       72 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_total_distances_2
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/
--rw-r--r--   0 runner    (1001) docker     (123)   639850 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem
--rw-r--r--   0 runner    (1001) docker     (123)      225 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem_2
--rw-r--r--   0 runner    (1001) docker     (123)     1113 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem_2_second_bead_side_chain
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/
--rw-r--r--   0 runner    (1001) docker     (123)     1721 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_build_qubit_op_2_expected
--rw-r--r--   0 runner    (1001) docker     (123)   294639 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_build_qubit_op_expected
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected
--rw-r--r--   0 runner    (1001) docker     (123)      117 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected_t23
--rw-r--r--   0 runner    (1001) docker     (123)      117 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected_t2s3
--rw-r--r--   0 runner    (1001) docker     (123)      117 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected_t34
--rw-r--r--   0 runner    (1001) docker     (123)      117 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected_t3s4s
--rw-r--r--   0 runner    (1001) docker     (123)       97 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_back_expected
--rw-r--r--   0 runner    (1001) docker     (123)       97 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_back_side_chains_expected
--rw-r--r--   0 runner    (1001) docker     (123)    43153 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbbb_expected
--rw-r--r--   0 runner    (1001) docker     (123)     3909 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_2_expected
--rw-r--r--   0 runner    (1001) docker     (123)     9265 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_expected_h_bbsc
--rw-r--r--   0 runner    (1001) docker     (123)    11041 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_expected_h_scbb
--rw-r--r--   0 runner    (1001) docker     (123)      505 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_chiral_2_expected
--rw-r--r--   0 runner    (1001) docker     (123)     1317 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_chiral_expected
--rw-r--r--   0 runner    (1001) docker     (123)     4145 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/test_protein_folding_problem.py
--rw-r--r--   0 runner    (1001) docker     (123)    14178 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/sampling/protein_folding/test_qubit_op_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/builders/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/builders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4774 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/builders/test_hopping_ops_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/
--rw-r--r--   0 runner    (1001) docker     (123)     1294 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_active_space
--rw-r--r--   0 runner    (1001) docker     (123)      446 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_one_int
--rw-r--r--   0 runner    (1001) docker     (123)    19270 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_two_ints
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      968 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/resource_reader.py
--rw-r--r--   0 runner    (1001) docker     (123)     8152 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/electronic/test_electronic_structure_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4237 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_hyper_cubic_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     6268 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     3284 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_line_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     3666 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_square_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     7145 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_triangular_lattice.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/models/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     6867 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/models/test_fermi_hubbard_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     5158 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/models/test_ising_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     4282 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/lattice/test_lattice_model_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/builders/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/builders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4754 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/builders/test_hopping_ops_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/resources/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/resources/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3138 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/resources/expected_ops.py
--rw-r--r--   0 runner    (1001) docker     (123)     4325 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/test_vibrational_structure_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9506 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/property_test.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/
--rw-r--r--   0 runner    (1001) docker     (123)     2067 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/integral_property_op.json
--rw-r--r--   0 runner    (1001) docker     (123)     1710 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_second_q_op_alpha_and_beta_expected.json
--rw-r--r--   0 runner    (1001) docker     (123)     1621 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_second_q_op_only_alpha_expected.json
--rw-r--r--   0 runner    (1001) docker     (123)     2048 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_spin_alpha_and_beta_expected.numpy.bin
--rw-r--r--   0 runner    (1001) docker     (123)     2048 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_spin_only_alpha_expected.numpy.bin
--rw-r--r--   0 runner    (1001) docker     (123)     4682 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/test_integral_property.py
--rw-r--r--   0 runner    (1001) docker     (123)     9251 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/test_one_body_electronic_integrals.py
--rw-r--r--   0 runner    (1001) docker     (123)    11076 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/test_two_body_electronic_integrals.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/resources/
--rw-r--r--   0 runner    (1001) docker     (123)     2528 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/resources/angular_momentum_op.json
--rw-r--r--   0 runner    (1001) docker     (123)      377 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/resources/dipole_moment_ops.json
--rw-r--r--   0 runner    (1001) docker     (123)     1645 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/resources/electronic_energy_op.json
--rw-r--r--   0 runner    (1001) docker     (123)    72011 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/resources/electronic_structure_driver_result.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)     2379 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_angular_momentum.py
--rw-r--r--   0 runner    (1001) docker     (123)     4242 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_dipole_moment.py
--rw-r--r--   0 runner    (1001) docker     (123)     6162 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_electronic_energy.py
--rw-r--r--   0 runner    (1001) docker     (123)     1790 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_electronic_structure_driver_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     2220 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_magnetization.py
--rw-r--r--   0 runner    (1001) docker     (123)     2579 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_particle_number.py
--rw-r--r--   0 runner    (1001) docker     (123)     1745 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/test_second_quantized_property.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/
--rw-r--r--   0 runner    (1001) docker     (123)      241 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_basis_1.json
--rw-r--r--   0 runner    (1001) docker     (123)     1227 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_basis_2.json
--rw-r--r--   0 runner    (1001) docker     (123)      342 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_basis_3.json
--rw-r--r--   0 runner    (1001) docker     (123)      339 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_second_q_op_1.json
--rw-r--r--   0 runner    (1001) docker     (123)     1374 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_second_q_op_2.json
--rw-r--r--   0 runner    (1001) docker     (123)      264 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_second_q_op_3.json
--rw-r--r--   0 runner    (1001) docker     (123)     4959 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/test_harmonic_basis.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/resources/
--rw-r--r--   0 runner    (1001) docker     (123)     1977 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/resources/vibrational_energy_op.json
--rw-r--r--   0 runner    (1001) docker     (123)    18952 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/resources/vibrational_structure_driver_result.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)     2498 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/test_occupied_modals.py
--rw-r--r--   0 runner    (1001) docker     (123)     3811 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/test_vibrational_energy.py
--rw-r--r--   0 runner    (1001) docker     (123)     1968 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/test_vibrational_structure_driver_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     3182 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/properties/test_grouped_property.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/resources/
--rw-r--r--   0 runner    (1001) docker     (123)    14648 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/resources/test_hdf5_error_import_failure.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    14648 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/resources/test_hdf5_error_missing_class.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    14920 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/resources/test_hdf5_error_multiple_groups.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    14752 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/resources/test_hdf5_error_non_native.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    20792 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/resources/test_hdf5_error_non_protocol.hdf5
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/results/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      949 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/test_eigenstate_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     2887 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/test_electronic_structure_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     4679 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/test_protein_folding_result.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/results/utils/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/utils/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/results/utils/resources/
--rw-r--r--   0 runner    (1001) docker     (123)      341 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/utils/resources/also_side_chains_test.xyz
--rw-r--r--   0 runner    (1001) docker     (123)      338 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/utils/resources/only_main_chain_test.xyz
--rw-r--r--   0 runner    (1001) docker     (123)     2609 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/utils/test_protein_decoder.py
--rw-r--r--   0 runner    (1001) docker     (123)     5555 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/results/utils/test_protein_shape_file_gen.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/runtime/
--rw-r--r--   0 runner    (1001) docker     (123)      513 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/runtime/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3508 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/runtime/fake_vqeruntime.py
--rw-r--r--   0 runner    (1001) docker     (123)     2860 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/runtime/test_vqeprogram.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/algorithms/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/eigensolver_factories/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/eigensolver_factories/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3167 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     6467 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py
--rw-r--r--   0 runner    (1001) docker     (123)     8334 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/test_excited_states_solvers.py
--rw-r--r--   0 runner    (1001) docker     (123)     5062 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/test_qeom_electronic_ops.py
--rw-r--r--   0 runner    (1001) docker     (123)     5537 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/test_qeom_vibrational_ops.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5331 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     5321 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py
--rw-r--r--   0 runner    (1001) docker     (123)     5820 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/test_advanced_ucc_variants.py
--rw-r--r--   0 runner    (1001) docker     (123)    13247 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/test_groundstate_eigensolver.py
--rw-r--r--   0 runner    (1001) docker     (123)     2972 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/test_swaprz.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3781 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/test_hf_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     1996 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/test_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     8665 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/test_mp2_initial_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     2272 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/test_vscf_initial_point.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/circuit/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3840 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_chc.py
--rw-r--r--   0 runner    (1001) docker     (123)     5203 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_puccd.py
--rw-r--r--   0 runner    (1001) docker     (123)    12554 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_succd.py
--rw-r--r--   0 runner    (1001) docker     (123)     9913 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_ucc.py
--rw-r--r--   0 runner    (1001) docker     (123)    10682 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_uccsd.py
--rw-r--r--   0 runner    (1001) docker     (123)     7370 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_uvcc.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/utils/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8740 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)     2145 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1869 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/utils/vibrational_op_label_creator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3799 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/test_fermionic_gaussian_state.py
--rw-r--r--   0 runner    (1001) docker     (123)     6560 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/test_hartree_fock.py
--rw-r--r--   0 runner    (1001) docker     (123)     3435 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/test_slater_determinant.py
--rw-r--r--   0 runner    (1001) docker     (123)     2153 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/test_vscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     6054 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/circuit/library/test_bogoliubov_transform.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/drivers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1366 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian.py
--rw-r--r--   0 runner    (1001) docker     (123)     1514 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_extra.py
--rw-r--r--   0 runner    (1001) docker     (123)    10840 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_forces.py
--rw-r--r--   0 runner    (1001) docker     (123)   940592 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_from_mat.mat
--rw-r--r--   0 runner    (1001) docker     (123)     1410 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_from_mat.py
--rw-r--r--   0 runner    (1001) docker     (123)     9084 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log.py
--rw-r--r--   0 runner    (1001) docker     (123)    28437 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log_A03.txt
--rw-r--r--   0 runner    (1001) docker     (123)    27861 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log_C01.txt
--rw-r--r--   0 runner    (1001) docker     (123)    90979 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log_polyyne_2.txt
--rw-r--r--   0 runner    (1001) docker     (123)    15480 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log_vibrational_energy.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)     2689 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_methods_gaussian.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/drivers/psi4d/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/psi4d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2697 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/psi4d/test_driver_methods_psi4.py
--rw-r--r--   0 runner    (1001) docker     (123)     1752 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/psi4d/test_driver_psi4.py
--rw-r--r--   0 runner    (1001) docker     (123)     3013 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/psi4d/test_driver_psi4_extra.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/drivers/pyscfd/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/pyscfd/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7368 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/pyscfd/test_driver_methods_pyscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     2904 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/pyscfd/test_driver_pyscf.py
--rw-r--r--   0 runner    (1001) docker     (123)     7146 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/test_driver.py
--rw-r--r--   0 runner    (1001) docker     (123)     2337 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/drivers/test_driver_methods_gsc.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/formats/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7997 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump.py
--rw-r--r--   0 runner    (1001) docker     (123)     7471 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_dumper.py
--rw-r--r--   0 runner    (1001) docker     (123)      381 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_h2.fcidump
--rw-r--r--   0 runner    (1001) docker     (123)     5029 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_lih.fcidump
--rw-r--r--   0 runner    (1001) docker     (123)     1986 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_lih.npz
--rw-r--r--   0 runner    (1001) docker     (123)    24914 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_oh.fcidump
--rw-r--r--   0 runner    (1001) docker     (123)     8008 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_oh.npz
--rw-r--r--   0 runner    (1001) docker     (123)     3167 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_methods_fcidump.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      375 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/he2_energy_VV10_input.json
--rw-r--r--   0 runner    (1001) docker     (123)     1023 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/he2_energy_VV10_input.py
--rw-r--r--   0 runner    (1001) docker     (123)     1127 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/he2_energy_VV10_output.json
--rw-r--r--   0 runner    (1001) docker     (123)     1841 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/he2_energy_VV10_output.py
--rw-r--r--   0 runner    (1001) docker     (123)    24880 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/legacy_electronic_structure_driver_result.json
--rw-r--r--   0 runner    (1001) docker     (123)     4056 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/water_output.json
--rw-r--r--   0 runner    (1001) docker     (123)     4999 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/water_output.py
--rw-r--r--   0 runner    (1001) docker     (123)     4080 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/water_output_v3.json
--rw-r--r--   0 runner    (1001) docker     (123)      686 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/qcschema/water_output_v3.py
--rw-r--r--   0 runner    (1001) docker     (123)     4593 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/formats/test_qcschema.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4231 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_hyper_cubic_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     6262 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     3278 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_line_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     3660 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_square_lattice.py
--rw-r--r--   0 runner    (1001) docker     (123)     7139 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_triangular_lattice.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/resources/
--rw-r--r--   0 runner    (1001) docker     (123)     1557 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/resources/electronic_energy_op.json
--rw-r--r--   0 runner    (1001) docker     (123)     3783 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/test_electronic_energy.py
--rw-r--r--   0 runner    (1001) docker     (123)     6825 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/test_fermi_hubbard_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     5390 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/test_heisenberg_model.py
--rw-r--r--   0 runner    (1001) docker     (123)     5116 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/test_ising_model.py
--rw-r--r--   0 runner    (1001) docker     (123)    11408 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/test_quadratic_hamiltonian.py
--rw-r--r--   0 runner    (1001) docker     (123)     3565 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/hamiltonians/test_vibrational_energy.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/mappers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/mappers/resources/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/resources/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    11935 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/resources/bksf_lih.py
--rw-r--r--   0 runner    (1001) docker     (123)    13817 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/resources/reference_direct_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     8121 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/test_bksf_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     3968 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/test_bravyi_kitaev_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2582 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/test_direct_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     4349 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/test_jordan_wigner_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2904 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/test_linear_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2624 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/test_logarithmic_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)     3892 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/test_parity_mapper.py
--rw-r--r--   0 runner    (1001) docker     (123)    12412 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/mappers/test_qubit_converter.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/operators/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2416 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/test_commutators.py
--rw-r--r--   0 runner    (1001) docker     (123)    19776 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/test_electronic_integrals.py
--rw-r--r--   0 runner    (1001) docker     (123)    25517 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/test_fermionic_op.py
--rw-r--r--   0 runner    (1001) docker     (123)    33626 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/test_polynomial_tensor.py
--rw-r--r--   0 runner    (1001) docker     (123)    17622 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/test_sparse_label_op.py
--rw-r--r--   0 runner    (1001) docker     (123)     8122 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/test_spin_op.py
--rw-r--r--   0 runner    (1001) docker     (123)     5775 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/test_tensor_ordering.py
--rw-r--r--   0 runner    (1001) docker     (123)    13790 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/operators/test_vibrational_op.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/problems/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/problems/resources/
--rw-r--r--   0 runner    (1001) docker     (123)    23464 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/resources/H2_631g_ferm_op.json
--rw-r--r--   0 runner    (1001) docker     (123)     1550 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/resources/H2_631g_ferm_op_active_space.json
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/resources/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3608 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/resources/expected_ops.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_eigenstate_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     5143 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_electronic_properties_container.py
--rw-r--r--   0 runner    (1001) docker     (123)     3874 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_electronic_structure_problem.py
--rw-r--r--   0 runner    (1001) docker     (123)     2962 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_electronic_structure_result.py
--rw-r--r--   0 runner    (1001) docker     (123)     3476 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_lattice_model_problem.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_lattice_properties_container.py
--rw-r--r--   0 runner    (1001) docker     (123)     6066 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_properties_container.py
--rw-r--r--   0 runner    (1001) docker     (123)     1907 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_vibrational_properties_container.py
--rw-r--r--   0 runner    (1001) docker     (123)     3802 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/problems/test_vibrational_structure_problem.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/properties/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2425 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/property_test.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/properties/resources/
--rw-r--r--   0 runner    (1001) docker     (123)     2336 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/resources/angular_momentum_op.json
--rw-r--r--   0 runner    (1001) docker     (123)     2707 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/resources/vibrational_energy_op.json
--rw-r--r--   0 runner    (1001) docker     (123)     1489 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/test_angular_momentum.py
--rw-r--r--   0 runner    (1001) docker     (123)     2111 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/test_dipole_moment.py
--rw-r--r--   0 runner    (1001) docker     (123)     7894 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/test_electronic_density.py
--rw-r--r--   0 runner    (1001) docker     (123)     1315 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/test_magnetization.py
--rw-r--r--   0 runner    (1001) docker     (123)     1646 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/test_occupied_modals.py
--rw-r--r--   0 runner    (1001) docker     (123)     1317 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/properties/test_particle_number.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/transformers/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/transformers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/second_q/transformers/resources/
--rw-r--r--   0 runner    (1001) docker     (123)    24880 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/transformers/resources/BeH_sto3g_reduced.json
--rw-r--r--   0 runner    (1001) docker     (123)    34241 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/transformers/resources/LiH_sto3g_reduced.json
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/transformers/resources/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    14270 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/transformers/test_active_space_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)     7294 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/transformers/test_basis_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)     5211 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/second_q/transformers/test_freeze_core_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)    20238 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/test_deprecation.py
--rw-r--r--   0 runner    (1001) docker     (123)     2260 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/test_end2end_with_vqe.py
--rw-r--r--   0 runner    (1001) docker     (123)     3942 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/test_hdf5.py
--rw-r--r--   0 runner    (1001) docker     (123)     5195 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/test_logging.py
--rw-r--r--   0 runner    (1001) docker     (123)     2540 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/test_readme_sample.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/transformers/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/
--rw-r--r--   0 runner    (1001) docker     (123)    87427 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/BeH_sto3g.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    72011 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/BeH_sto3g_reduced.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    68723 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/H2_631g.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    64603 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/H2_sto3g.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    64603 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/H2_sto3g_v2.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    87427 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/LiH_sto3g.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)    77027 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/LiH_sto3g_reduced.hdf5
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    18703 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/test_active_space_transformer.py
--rw-r--r--   0 runner    (1001) docker     (123)     5415 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/test_freeze_core_transformer.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-07 17:10:30.000000 qiskit-nature-0.5.2/test/utils/
--rw-r--r--   0 runner    (1001) docker     (123)      477 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1091 2022-12-07 17:10:19.000000 qiskit-nature-0.5.2/test/utils/test_linalg.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/
+-rw-r--r--   0 runner    (1001) docker     (123)    11416 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      319 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     6586 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     6101 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      142 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/pyproject.toml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/
+-rw-r--r--   0 runner    (1001) docker     (123)        6 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/VERSION.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1672 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/
+-rw-r--r--   0 runner    (1001) docker     (123)     3500 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1654 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/
+-rw-r--r--   0 runner    (1001) docker     (123)     1212 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1272 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4095 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/numpy_eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7050 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/excited_states_eigensolver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2467 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/excited_states_solver.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23363 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/qeom.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1403 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18106 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/adapt_vqe.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11004 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/ground_state_eigensolver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4970 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/ground_state_solver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/
+-rw-r--r--   0 runner    (1001) docker     (123)     1918 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1922 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/minimum_eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4569 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/numpy_minimum_eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13180 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_ucc_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12629 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uvcc_factory.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/
+-rw-r--r--   0 runner    (1001) docker     (123)     1520 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5978 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/hf_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2382 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13876 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/mp2_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4971 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/vscf_initial_point.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/
+-rw-r--r--   0 runner    (1001) docker     (123)     2747 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12786 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/bopes_sampler.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20098 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/extrapolator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/
+-rw-r--r--   0 runner    (1001) docker     (123)      909 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4264 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/energy_surface_spline.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9698 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/harmonic_potential.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8746 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/morse_potential.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5706 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/potential_base.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/
+-rw-r--r--   0 runner    (1001) docker     (123)     1009 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/
+-rw-r--r--   0 runner    (1001) docker     (123)     1723 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/
+-rw-r--r--   0 runner    (1001) docker     (123)      799 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9310 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/chc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6596 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/puccd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7231 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/succd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21323 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/ucc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2609 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/uccsd.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     1161 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12219 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/utils/fermionic_excitation_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3456 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/utils/vibration_excitation_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13777 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/uvcc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1861 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/uvccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11286 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/bogoliubov_transform.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/
+-rw-r--r--   0 runner    (1001) docker     (123)      809 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6952 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/fermionic_gaussian_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5808 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/hartree_fock.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4953 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/slater_determinant.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4053 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/utils/givens_rotations.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3738 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/vscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2359 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/constants.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/converters/
+-rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/converters/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)     1086 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21012 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/qubit_converter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      887 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2240 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/utils/list_or_dict.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17156 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/deprecation.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1050 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/bosonic_bases/
+-rw-r--r--   0 runner    (1001) docker     (123)      948 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/bosonic_bases/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1678 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/bosonic_bases/bosonic_basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16915 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/bosonic_bases/harmonic_basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18545 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/molecule.py
+-rw-r--r--   0 runner    (1001) docker     (123)    33098 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/qmolecule.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)     7002 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      967 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/base_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1441 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/electronic_structure_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6184 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/
+-rw-r--r--   0 runner    (1001) docker     (123)      635 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5274 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/dumper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4888 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/fcidumpdriver.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11019 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/parser.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/
+-rw-r--r--   0 runner    (1001) docker     (123)     7690 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/
+-rwxr-xr-x   0 runner    (1001) docker     (123)    12784 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/LICENSE.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)    27815 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/QCMatEl.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    18069 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/QCOpMat.py
+-rw-r--r--   0 runner    (1001) docker     (123)      930 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    33018 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.F
+-rw-r--r--   0 runner    (1001) docker     (123)   132096 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cp310-win_amd64.pyd
+-rw-r--r--   0 runner    (1001) docker     (123)   125952 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cp37-win_amd64.pyd
+-rw-r--r--   0 runner    (1001) docker     (123)   126464 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cp38-win_amd64.pyd
+-rw-r--r--   0 runner    (1001) docker     (123)   129024 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cp39-win_amd64.pyd
+-rwxr-xr-x   0 runner    (1001) docker     (123)   556024 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   420344 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   481832 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   452040 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   481976 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   489696 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   525864 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   242888 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--   0 runner    (1001) docker     (123)     5203 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_forces_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3058 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_log_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12786 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_log_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2139 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17940 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussiandriver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/hdf5d/
+-rw-r--r--   0 runner    (1001) docker     (123)      568 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/hdf5d/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5119 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/hdf5d/hdf5driver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/psi4d/
+-rw-r--r--   0 runner    (1001) docker     (123)     1558 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/psi4d/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5259 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/psi4d/_template.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     8325 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/psi4d/psi4driver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyquanted/
+-rw-r--r--   0 runner    (1001) docker     (123)     1988 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyquanted/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17754 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyquanted/pyquantedriver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyscfd/
+-rw-r--r--   0 runner    (1001) docker     (123)     1165 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyscfd/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27394 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/vibrational_structure_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5188 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/vibrational_structure_molecule_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1209 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/units_type.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1787 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/drivers/watson_hamiltonian.py
+-rw-r--r--   0 runner    (1001) docker     (123)      786 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9905 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/hdf5.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2741 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/list_or_dict.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6179 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/logging.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)     2146 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22722 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/bksf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5701 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/bravyi_kitaev_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1787 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/direct_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1199 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/fermionic_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1925 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/jordan_wigner_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5505 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/linear_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8148 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/logarithmic_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2291 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/parity_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6024 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/qubit_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1156 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/spin_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1213 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/vibrational_mapper.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/operators/
+-rw-r--r--   0 runner    (1001) docker     (123)     1091 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/operators/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)     1251 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27314 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/fermionic_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14781 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/quadratic_hamiltonian.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2228 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/second_quantized_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21402 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/spin_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23187 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/vibrational_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2596 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/optionals.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/
+-rw-r--r--   0 runner    (1001) docker     (123)      813 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/
+-rw-r--r--   0 runner    (1001) docker     (123)     5305 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_contacts/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_contacts/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2970 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_contacts/contact_map.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8964 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_contacts/contact_map_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_distances/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_distances/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6295 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_distances/distance_map.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11734 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_distances/distance_map_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/data_loaders/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/data_loaders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1805 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/data_loaders/energy_matrix_loader.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/exceptions/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/exceptions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      705 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_residue_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)      713 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_side_chain_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)      716 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_size_exception.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1152 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/interaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2455 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/mixed_interaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2045 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/miyazawa_jernigan_interaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1318 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/random_interaction.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)      794 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3969 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/resources/mj_matrix.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1861 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/penalty_parameters.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/beads/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/beads/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5215 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/beads/base_bead.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2926 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/beads/main_bead.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3066 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/beads/side_bead.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/chains/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/chains/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2445 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/chains/base_chain.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6779 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/chains/main_chain.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3242 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/chains/side_chain.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1865 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/pauli_ops_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3651 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/peptide.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5302 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/protein_folding_problem.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20630 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/qubit_op_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/qubit_utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/qubit_utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3417 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/qubit_utils/qubit_fixing.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4414 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/qubit_utils/qubit_number_reducer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2186 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/residue_validator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1606 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/sampling/sampling_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)     1320 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7806 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/base_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/
+-rw-r--r--   0 runner    (1001) docker     (123)      873 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/builders/
+-rw-r--r--   0 runner    (1001) docker     (123)      536 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/builders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5937 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/builders/hopping_ops_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11189 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/electronic_structure_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/
+-rw-r--r--   0 runner    (1001) docker     (123)     1796 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6114 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattice_model_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/
+-rw-r--r--   0 runner    (1001) docker     (123)     1198 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      683 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/boundary_condition.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13159 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/hyper_cubic_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8182 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1838 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/line_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2505 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/square_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10928 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/triangular_lattice.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/
+-rw-r--r--   0 runner    (1001) docker     (123)      962 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4913 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/fermi_hubbard_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3611 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/ising_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3433 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/lattice_model.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/
+-rw-r--r--   0 runner    (1001) docker     (123)      829 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/builders/
+-rw-r--r--   0 runner    (1001) docker     (123)      538 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/builders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4406 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/builders/hopping_ops_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2127 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/builders/vibrational_label_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8892 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/vibrational_structure_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/properties/
+-rw-r--r--   0 runner    (1001) docker     (123)     1005 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5732 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/grouped_property.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4507 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/property.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)     1454 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3281 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/driver_metadata.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/
+-rw-r--r--   0 runner    (1001) docker     (123)     2660 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14067 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/angular_momentum.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/bases/
+-rw-r--r--   0 runner    (1001) docker     (123)     1404 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/bases/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/bases/electronic_basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4681 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/bases/electronic_basis_transform.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14831 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/dipole_moment.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13572 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/electronic_energy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6608 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/electronic_structure_driver_result.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/
+-rw-r--r--   0 runner    (1001) docker     (123)     1310 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17698 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/electronic_integrals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9675 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/integral_property.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6735 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/one_body_electronic_integrals.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11182 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/two_body_electronic_integrals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5532 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/magnetization.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12425 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/particle_number.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1003 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/types.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/second_quantized_property.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/
+-rw-r--r--   0 runner    (1001) docker     (123)     1902 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/bases/
+-rw-r--r--   0 runner    (1001) docker     (123)     1369 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/bases/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3155 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/bases/harmonic_basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4152 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/bases/vibrational_basis.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/integrals/
+-rw-r--r--   0 runner    (1001) docker     (123)      959 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/integrals/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13051 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/integrals/vibrational_integrals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5526 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/occupied_modals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2397 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/types.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8807 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/vibrational_energy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5553 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/vibrational_structure_driver_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)       27 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/py.typed
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/results/
+-rw-r--r--   0 runner    (1001) docker     (123)     2015 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2374 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/bopes_sampler_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5204 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/eigenstate_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17646 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/electronic_structure_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2669 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/lattice_model_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7996 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/protein_folding_result.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/results/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5495 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/utils/protein_plotter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5463 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/utils/protein_shape_decoder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6574 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/utils/protein_shape_file_gen.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4013 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/results/vibrational_structure_result.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/runtime/
+-rw-r--r--   0 runner    (1001) docker     (123)     1297 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/runtime/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16042 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/runtime/vqe_client.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/
+-rw-r--r--   0 runner    (1001) docker     (123)      823 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/
+-rw-r--r--   0 runner    (1001) docker     (123)     3651 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1164 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/
+-rw-r--r--   0 runner    (1001) docker     (123)     1049 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1287 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4784 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/numpy_eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7795 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/excited_states_eigensolver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2677 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/excited_states_solver.py
+-rw-r--r--   0 runner    (1001) docker     (123)    55023 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6877 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom_electronic_ops_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5081 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom_vibrational_ops_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1210 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7531 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_eigensolver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4499 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_solver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/
+-rw-r--r--   0 runner    (1001) docker     (123)     1268 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2641 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/minimum_eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4101 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/numpy_minimum_eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7996 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_ucc_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7510 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uvcc_factory.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/
+-rw-r--r--   0 runner    (1001) docker     (123)     1375 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5071 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/hf_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2177 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12971 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/mp2_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3991 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/vscf_initial_point.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/
+-rw-r--r--   0 runner    (1001) docker     (123)      691 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/
+-rw-r--r--   0 runner    (1001) docker     (123)     1746 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/
+-rw-r--r--   0 runner    (1001) docker     (123)      799 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9332 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/chc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7489 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/puccd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12589 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/succd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24934 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/ucc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3403 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/uccsd.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12845 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/utils/fermionic_excitation_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3479 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/utils/vibration_excitation_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17573 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/uvcc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2646 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/uvccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12000 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/bogoliubov_transform.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/
+-rw-r--r--   0 runner    (1001) docker     (123)      809 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7596 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/fermionic_gaussian_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14022 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/hartree_fock.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5590 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/slater_determinant.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4053 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/utils/givens_rotations.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10767 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/vscf.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/
+-rw-r--r--   0 runner    (1001) docker     (123)     2770 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      893 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/base_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12856 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/electronic_structure_driver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/
+-rw-r--r--   0 runner    (1001) docker     (123)     7668 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/
+-rwxr-xr-x   0 runner    (1001) docker     (123)    12784 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/LICENSE.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)    27815 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/QCMatEl.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    18069 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/QCOpMat.py
+-rw-r--r--   0 runner    (1001) docker     (123)      930 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    33018 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.F
+-rw-r--r--   0 runner    (1001) docker     (123)   132096 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp310-win_amd64.pyd
+-rw-r--r--   0 runner    (1001) docker     (123)   129536 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp311-win_amd64.pyd
+-rw-r--r--   0 runner    (1001) docker     (123)   125952 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp37-win_amd64.pyd
+-rw-r--r--   0 runner    (1001) docker     (123)   126464 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp38-win_amd64.pyd
+-rw-r--r--   0 runner    (1001) docker     (123)   129024 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp39-win_amd64.pyd
+-rwxr-xr-x   0 runner    (1001) docker     (123)   556024 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   420344 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   167328 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-311-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   413656 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-311-x86_64-linux-gnu.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   481832 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   452040 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   481976 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   489696 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   525864 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so
+-rwxr-xr-x   0 runner    (1001) docker     (123)   242888 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--   0 runner    (1001) docker     (123)     5497 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussian_forces_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3068 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11541 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2139 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussian_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19213 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussiandriver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/psi4d/
+-rw-r--r--   0 runner    (1001) docker     (123)     1086 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/psi4d/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3315 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/psi4d/_template.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     8521 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/psi4d/psi4driver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/pyscfd/
+-rw-r--r--   0 runner    (1001) docker     (123)     1165 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/pyscfd/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25920 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/pyscfd/pyscfdriver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1220 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/vibrational_structure_driver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/
+-rw-r--r--   0 runner    (1001) docker     (123)     1268 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump/
+-rw-r--r--   0 runner    (1001) docker     (123)      844 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3179 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump/dumper.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12167 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump/fcidump.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8546 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump/parser.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1950 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump_translator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1909 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/molecule_info.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/
+-rw-r--r--   0 runner    (1001) docker     (123)     2268 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4727 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8257 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_basis_set.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1007 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_error.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2175 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6146 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_properties.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1100 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_provenance.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14946 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_schema.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2709 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_schema_input.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4642 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_topology.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11104 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_wavefunction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9630 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema_translator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/watson/
+-rw-r--r--   0 runner    (1001) docker     (123)      858 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/watson/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2945 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/watson/watson_hamiltonian.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2117 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/formats/watson_translator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/
+-rw-r--r--   0 runner    (1001) docker     (123)     1435 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11219 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/electronic_energy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4356 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/fermi_hubbard_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1736 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/hamiltonian.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3928 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/heisenberg_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2875 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/ising_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1389 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattice_model.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/
+-rw-r--r--   0 runner    (1001) docker     (123)     1255 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      684 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/boundary_condition.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13174 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/hyper_cubic_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10662 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1850 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/line_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2517 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/square_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10939 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/triangular_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15311 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/quadratic_hamiltonian.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4228 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/vibrational_energy.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/
+-rw-r--r--   0 runner    (1001) docker     (123)     3224 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22931 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/bksf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5942 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/bravyi_kitaev_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1784 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/direct_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1140 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/fermionic_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4454 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/interleaved_qubit_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1869 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/jordan_wigner_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4841 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/linear_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7850 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/logarithmic_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5866 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/parity_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26859 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/qubit_converter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12824 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/qubit_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1110 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/spin_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10213 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/tapered_qubit_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1152 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/vibrational_mapper.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/
+-rw-r--r--   0 runner    (1001) docker     (123)     1558 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5296 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/_bits_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3041 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/commutators.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27586 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/electronic_integrals.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25398 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/fermionic_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27244 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/polynomial_tensor.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20279 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/sparse_label_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22012 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/spin_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30615 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/symmetric_two_body.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25683 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/tensor.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11470 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/tensor_ordering.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4306 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/vibrational_integrals.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23973 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/operators/vibrational_op.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/
+-rw-r--r--   0 runner    (1001) docker     (123)     2442 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7548 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/base_problem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7413 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/eigenstate_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)      763 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/electronic_basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3072 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/electronic_properties_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15897 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/electronic_structure_problem.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19106 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/electronic_structure_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3359 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/harmonic_basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2897 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/lattice_model_problem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2757 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/lattice_model_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)      867 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/lattice_properties_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4369 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/properties_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5295 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/vibrational_basis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1229 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/vibrational_properties_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4036 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/vibrational_structure_problem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4105 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/problems/vibrational_structure_result.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/
+-rw-r--r--   0 runner    (1001) docker     (123)     1673 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8797 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/angular_momentum.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7686 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/dipole_moment.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10918 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/electronic_density.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2623 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/magnetization.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3159 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/occupied_modals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2539 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/particle_number.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1834 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/properties/protocols.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1150 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29154 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/active_space_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1956 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/base_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9754 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/basis_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14197 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/freeze_core_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10859 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/settings.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/testing/
+-rw-r--r--   0 runner    (1001) docker     (123)      926 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/testing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3347 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/testing/random.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1037 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)     1374 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1401 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/base_transformer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/electronic/
+-rw-r--r--   0 runner    (1001) docker     (123)     1480 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/electronic/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20248 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/electronic/active_space_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5214 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/electronic/freeze_core_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)      657 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/units.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      929 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6466 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/utils/linalg.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1272 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/utils/opt_einsum.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2488 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/qiskit_nature/version.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     6586 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    57099 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)      272 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       14 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/qiskit_nature.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      125 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     3114 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/
+-rw-r--r--   0 runner    (1001) docker     (123)      674 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/eigensolver_factories/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/eigensolver_factories/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3246 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6882 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6148 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/test_excited_states_solvers.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6677 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6662 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11818 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/test_adapt_vqe.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6069 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/test_advanced_ucc_variants.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27402 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/test_groundstate_eigensolver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3531 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/test_swaprz.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/initial_points/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/initial_points/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/initial_points/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)     6550 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/initial_points/resources/test_mp2_initial_point.json
+-rw-r--r--   0 runner    (1001) docker     (123)     5029 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/initial_points/test_hf_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2061 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/initial_points/test_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11100 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/initial_points/test_mp2_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2910 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/initial_points/test_vscf_initial_point.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/pes_samplers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/pes_samplers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/algorithms/pes_samplers/potentials/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/pes_samplers/potentials/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10592 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/pes_samplers/potentials/test_potential.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15095 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/pes_samplers/test_bopes_sampler.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14840 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/algorithms/pes_samplers/test_extrapolators.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/circuit/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/circuit/library/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4073 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_chc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4938 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_puccd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6019 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_succd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8802 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_ucc.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10382 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_uccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7600 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_uvcc.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8618 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2156 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1821 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/ansatzes/utils/vibrational_op_label_creator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/circuit/library/initial_states/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/initial_states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3884 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/initial_states/test_fermionic_gaussian_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5750 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/initial_states/test_hartree_fock.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3520 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/initial_states/test_slater_determinant.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1587 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/initial_states/test_vscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6138 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/circuit/library/test_bogoliubov_transform.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/converters/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/converters/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/converters/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/converters/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13057 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/converters/second_quantization/test_qubit_converter.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/drivers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8389 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5341 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_dumper.py
+-rw-r--r--   0 runner    (1001) docker     (123)      381 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_h2.fcidump
+-rw-r--r--   0 runner    (1001) docker     (123)     5029 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_lih.fcidump
+-rw-r--r--   0 runner    (1001) docker     (123)     1986 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_lih.npz
+-rw-r--r--   0 runner    (1001) docker     (123)    24909 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_oh.fcidump
+-rw-r--r--   0 runner    (1001) docker     (123)     8008 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_oh.npz
+-rw-r--r--   0 runner    (1001) docker     (123)     5043 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_methods_fcidump.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1915 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1545 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_extra.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7470 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_forces.py
+-rw-r--r--   0 runner    (1001) docker     (123)   940592 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_from_mat.mat
+-rw-r--r--   0 runner    (1001) docker     (123)     1399 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_from_mat.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9527 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28437 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_A03.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    27861 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_C01.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    15552 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_vibrational_energy.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)     2733 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_methods_gaussian.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/hdf5d/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/hdf5d/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    48547 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/hdf5d/test_driver_hdf5.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)     3994 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/hdf5d/test_driver_hdf5.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15664 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/hdf5d/test_driver_hdf5_legacy.hdf5
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/psi4d/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/psi4d/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2693 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/psi4d/test_driver_methods_psi4.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1966 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/psi4d/test_driver_psi4.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2905 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/psi4d/test_driver_psi4_extra.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/pyquanted/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/pyquanted/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2970 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/pyquanted/test_driver_methods_pyquante.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1872 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/pyquanted/test_driver_pyquante.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/pyscfd/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/pyscfd/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7410 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/pyscfd/test_driver_methods_pyscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3944 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/pyscfd/test_driver_pyscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8595 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/test_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2295 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/test_driver_methods_gsc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8169 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/test_driver_molecule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8999 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/drivers/second_quantization/test_molecule_driver.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/mappers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12158 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/resources/bksf_lih.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13817 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/resources/reference_direct_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8090 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/test_bksf_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4042 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/test_bravyi_kitaev_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2806 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/test_direct_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4045 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/test_jordan_wigner_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3135 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/test_linear_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2617 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/test_logarithmic_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3966 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/mappers/second_quantization/test_parity_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6536 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/nature_test_case.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/operators/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/operators/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/operators/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/operators/second_quantization/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24378 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/operators/second_quantization/test_fermionic_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9519 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/operators/second_quantization/test_quadratic_hamiltonian.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13627 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/operators/second_quantization/test_spin_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5076 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/operators/second_quantization/test_vibrational_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)      929 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/operators/second_quantization/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_contacts/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_contacts/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5224 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_contacts/test_contact_map_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_distances/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_distances/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5870 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_distances/test_distance_map.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5052 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_distances/test_distance_map_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/data_loaders/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/data_loaders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1602 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/data_loaders/test_energy_matrix_loader.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/interactions/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/interactions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1651 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/interactions/test_mixed_interaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1685 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/interactions/test_miyazawa_jernigan_interaction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1143 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/interactions/test_random_interaction.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/beads/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/beads/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2979 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/beads/test_bead_main.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3108 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/beads/test_bead_side.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/chains/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/chains/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2241 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/chains/test_chain_main.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1671 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/chains/test_chain_side.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2791 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/test_peptide.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/qubit_utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/qubit_utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2921 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/qubit_utils/test_qubit_fixing.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4727 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/qubit_utils/test_qubit_number_reducer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1268 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/file_parser.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_main/
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_main/test_main_bead_constructor_expected_indic_0
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_main/test_main_bead_constructor_expected_indic_1
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_main/test_main_bead_constructor_expected_indic_2
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_main/test_main_bead_constructor_expected_indic_3
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_side/
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_side/test_side_bead_constructor_expected_indic_0
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_side/test_side_bead_constructor_expected_indic_1
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_side/test_side_bead_constructor_expected_indic_2
+-rw-r--r--   0 runner    (1001) docker     (123)       85 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_bead_side/test_side_bead_constructor_expected_indic_3
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/
+-rw-r--r--   0 runner    (1001) docker     (123)      215 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_2_expected_1
+-rw-r--r--   0 runner    (1001) docker     (123)      215 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_2_expected_2
+-rw-r--r--   0 runner    (1001) docker     (123)      303 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_1
+-rw-r--r--   0 runner    (1001) docker     (123)      303 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_2
+-rw-r--r--   0 runner    (1001) docker     (123)      303 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_3
+-rw-r--r--   0 runner    (1001) docker     (123)      303 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_4
+-rw-r--r--   0 runner    (1001) docker     (123)      303 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_5
+-rw-r--r--   0 runner    (1001) docker     (123)      303 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_contact_map_builder/test_create_pauli_for_contacts_3_expected_6
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map/
+-rw-r--r--   0 runner    (1001) docker     (123)       60 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map/test_first_neighbor
+-rw-r--r--   0 runner    (1001) docker     (123)      567 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map/test_first_neighbor_side
+-rw-r--r--   0 runner    (1001) docker     (123)       50 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map/test_second_neighbor
+-rw-r--r--   0 runner    (1001) docker     (123)      248 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map/test_second_neighbor_2
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map_builder/
+-rw-r--r--   0 runner    (1001) docker     (123)      101 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_add_distances_side_chain
+-rw-r--r--   0 runner    (1001) docker     (123)      101 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_distances_main_chain_1
+-rw-r--r--   0 runner    (1001) docker     (123)      101 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_distances_main_chain_2
+-rw-r--r--   0 runner    (1001) docker     (123)       48 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_distances_main_chain_3
+-rw-r--r--   0 runner    (1001) docker     (123)      127 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_distances_main_chain_4
+-rw-r--r--   0 runner    (1001) docker     (123)       97 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_total_distances_1
+-rw-r--r--   0 runner    (1001) docker     (123)       72 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map_builder/test_calc_total_distances_2
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/
+-rw-r--r--   0 runner    (1001) docker     (123)   639850 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem
+-rw-r--r--   0 runner    (1001) docker     (123)      225 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem_2
+-rw-r--r--   0 runner    (1001) docker     (123)     1113 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem_2_second_bead_side_chain
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/
+-rw-r--r--   0 runner    (1001) docker     (123)     1721 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_build_qubit_op_2_expected
+-rw-r--r--   0 runner    (1001) docker     (123)   294639 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_build_qubit_op_expected
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected
+-rw-r--r--   0 runner    (1001) docker     (123)      117 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected_t23
+-rw-r--r--   0 runner    (1001) docker     (123)      117 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected_t2s3
+-rw-r--r--   0 runner    (1001) docker     (123)      117 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected_t34
+-rw-r--r--   0 runner    (1001) docker     (123)      117 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_check_turns_expected_t3s4s
+-rw-r--r--   0 runner    (1001) docker     (123)       97 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_back_expected
+-rw-r--r--   0 runner    (1001) docker     (123)       97 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_back_side_chains_expected
+-rw-r--r--   0 runner    (1001) docker     (123)    43153 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbbb_expected
+-rw-r--r--   0 runner    (1001) docker     (123)     3909 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_2_expected
+-rw-r--r--   0 runner    (1001) docker     (123)     9265 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_expected_h_bbsc
+-rw-r--r--   0 runner    (1001) docker     (123)    11041 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_expected_h_scbb
+-rw-r--r--   0 runner    (1001) docker     (123)      505 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_chiral_2_expected
+-rw-r--r--   0 runner    (1001) docker     (123)     1317 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_chiral_expected
+-rw-r--r--   0 runner    (1001) docker     (123)     4145 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/test_protein_folding_problem.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14178 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/sampling/protein_folding/test_qubit_op_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/builders/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/builders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4774 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/builders/test_hopping_ops_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)     1294 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_active_space
+-rw-r--r--   0 runner    (1001) docker     (123)      446 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_one_int
+-rw-r--r--   0 runner    (1001) docker     (123)    19270 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_two_ints
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      968 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/resource_reader.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8152 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/electronic/test_electronic_structure_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4237 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_hyper_cubic_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6268 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3284 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_line_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3666 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_square_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7145 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_triangular_lattice.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/models/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/models/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6867 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/models/test_fermi_hubbard_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5158 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/models/test_ising_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4282 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/lattice/test_lattice_model_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/builders/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/builders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4754 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/builders/test_hopping_ops_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3138 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/resources/expected_ops.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4325 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/test_vibrational_structure_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9506 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/property_test.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)     2067 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/integral_property_op.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1710 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_second_q_op_alpha_and_beta_expected.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1621 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_second_q_op_only_alpha_expected.json
+-rw-r--r--   0 runner    (1001) docker     (123)     2048 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_spin_alpha_and_beta_expected.numpy.bin
+-rw-r--r--   0 runner    (1001) docker     (123)     2048 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_spin_only_alpha_expected.numpy.bin
+-rw-r--r--   0 runner    (1001) docker     (123)     4682 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/test_integral_property.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9251 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/test_one_body_electronic_integrals.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11076 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/test_two_body_electronic_integrals.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)     2528 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/resources/angular_momentum_op.json
+-rw-r--r--   0 runner    (1001) docker     (123)      377 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/resources/dipole_moment_ops.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1645 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/resources/electronic_energy_op.json
+-rw-r--r--   0 runner    (1001) docker     (123)    72011 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/resources/electronic_structure_driver_result.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)     2379 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_angular_momentum.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4242 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_dipole_moment.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6162 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_electronic_energy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1790 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_electronic_structure_driver_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2220 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_magnetization.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2579 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_particle_number.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1745 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/test_second_quantized_property.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)      241 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_basis_1.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1227 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_basis_2.json
+-rw-r--r--   0 runner    (1001) docker     (123)      342 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_basis_3.json
+-rw-r--r--   0 runner    (1001) docker     (123)      339 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_second_q_op_1.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1374 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_second_q_op_2.json
+-rw-r--r--   0 runner    (1001) docker     (123)      264 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_second_q_op_3.json
+-rw-r--r--   0 runner    (1001) docker     (123)     4959 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/test_harmonic_basis.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)     1977 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/resources/vibrational_energy_op.json
+-rw-r--r--   0 runner    (1001) docker     (123)    18952 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/resources/vibrational_structure_driver_result.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)     2498 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/test_occupied_modals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3811 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/test_vibrational_energy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1968 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/test_vibrational_structure_driver_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3182 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/properties/test_grouped_property.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)    14648 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/resources/test_hdf5_error_import_failure.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    14648 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/resources/test_hdf5_error_missing_class.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    14920 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/resources/test_hdf5_error_multiple_groups.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    14752 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/resources/test_hdf5_error_non_native.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    20792 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/resources/test_hdf5_error_non_protocol.hdf5
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/results/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      949 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/test_eigenstate_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2887 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/test_electronic_structure_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4679 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/test_protein_folding_result.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/results/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/utils/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/results/utils/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)      341 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/utils/resources/also_side_chains_test.xyz
+-rw-r--r--   0 runner    (1001) docker     (123)      338 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/utils/resources/only_main_chain_test.xyz
+-rw-r--r--   0 runner    (1001) docker     (123)     2609 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/utils/test_protein_decoder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5555 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/results/utils/test_protein_shape_file_gen.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/runtime/
+-rw-r--r--   0 runner    (1001) docker     (123)      513 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/runtime/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3508 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/runtime/fake_vqeruntime.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4022 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/runtime/test_vqeprogram.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/algorithms/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/eigensolver_factories/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/eigensolver_factories/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3308 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4438 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/resources/expected_qeom_ops.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2256 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/resources/expected_transition_amplitudes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7068 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13018 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/test_excited_states_solvers.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10601 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/test_excited_states_solvers_auxiliaries.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6079 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/test_qeom_electronic_ops.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6769 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/test_qeom_vibrational_ops.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5458 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5448 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5652 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/test_advanced_ucc_variants.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15825 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/test_groundstate_eigensolver.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15768 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/test_groundstate_eigensolver_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2963 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/test_swaprz.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3781 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/test_hf_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1996 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/test_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9001 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/test_mp2_initial_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2272 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/test_vscf_initial_point.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/circuit/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4214 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_chc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5633 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_puccd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15295 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_succd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11909 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_ucc.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11991 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_uccsd.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8536 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_uvcc.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11028 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2145 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1869 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/utils/vibrational_op_label_creator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4839 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_fermionic_gaussian_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8655 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_hartree_fock.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4894 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_hartree_fock_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4369 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_slater_determinant.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3048 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_vscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7636 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/circuit/library/test_bogoliubov_transform.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/drivers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1366 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1514 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_extra.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10621 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_forces.py
+-rw-r--r--   0 runner    (1001) docker     (123)   940592 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_from_mat.mat
+-rw-r--r--   0 runner    (1001) docker     (123)     1410 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_from_mat.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9084 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28437 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log_A03.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    27861 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log_C01.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    90979 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log_polyyne_2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    15480 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log_vibrational_energy.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)     2689 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_methods_gaussian.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/drivers/psi4d/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/psi4d/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2697 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/psi4d/test_driver_methods_psi4.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1752 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/psi4d/test_driver_psi4.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3013 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/psi4d/test_driver_psi4_extra.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/drivers/pyscfd/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/pyscfd/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7916 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/pyscfd/test_driver_methods_pyscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4380 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/pyscfd/test_driver_pyscf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7319 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/test_driver.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2337 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/drivers/test_driver_methods_gsc.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/formats/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8561 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8379 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_dumper.py
+-rw-r--r--   0 runner    (1001) docker     (123)      381 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_h2.fcidump
+-rw-r--r--   0 runner    (1001) docker     (123)     5029 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_lih.fcidump
+-rw-r--r--   0 runner    (1001) docker     (123)     1986 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_lih.npz
+-rw-r--r--   0 runner    (1001) docker     (123)    24914 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_oh.fcidump
+-rw-r--r--   0 runner    (1001) docker     (123)     8008 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_oh.npz
+-rw-r--r--   0 runner    (1001) docker     (123)     5149 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_methods_fcidump.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      375 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/he2_energy_VV10_input.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1023 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/he2_energy_VV10_input.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1127 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/he2_energy_VV10_output.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1841 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/he2_energy_VV10_output.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24880 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/legacy_electronic_structure_driver_result.json
+-rw-r--r--   0 runner    (1001) docker     (123)     4056 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/water_output.json
+-rw-r--r--   0 runner    (1001) docker     (123)     4999 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/water_output.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4080 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/water_output_v3.json
+-rw-r--r--   0 runner    (1001) docker     (123)      686 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/qcschema/water_output_v3.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4593 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/formats/test_qcschema.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4231 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_hyper_cubic_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6262 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3278 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_line_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3660 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_square_lattice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7139 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_triangular_lattice.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)     1557 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/resources/electronic_energy_op.json
+-rw-r--r--   0 runner    (1001) docker     (123)     3783 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/test_electronic_energy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6825 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/test_fermi_hubbard_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5390 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/test_heisenberg_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5116 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/test_ising_model.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12151 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/test_quadratic_hamiltonian.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3565 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/hamiltonians/test_vibrational_energy.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/mappers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/mappers/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11935 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/resources/bksf_lih.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12890 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/resources/reference_direct_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11353 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_bksf_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6542 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_bravyi_kitaev_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3572 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_direct_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1782 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_interleaved_qubit_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9175 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_jordan_wigner_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3590 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_linear_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3317 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_logarithmic_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7357 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_parity_mapper.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27139 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_qubit_converter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30564 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/mappers/test_tapered_qubit_mapper.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/operators/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10134 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/tensor_test_cases.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3301 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_commutators.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19776 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_electronic_integrals.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26291 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_fermionic_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)    34652 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_polynomial_tensor.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18867 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_sparse_label_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8361 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_spin_op.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21744 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_symmetric_two_body.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4047 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_tensor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5775 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_tensor_ordering.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14914 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/operators/test_vibrational_op.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/problems/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/problems/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)    23464 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/resources/H2_631g_ferm_op.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1550 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/resources/H2_631g_ferm_op_active_space.json
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3608 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/resources/expected_ops.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_eigenstate_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5143 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_electronic_properties_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5569 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_electronic_structure_problem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3226 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_electronic_structure_result.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3476 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_lattice_model_problem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_lattice_properties_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6066 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_properties_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1907 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_vibrational_properties_container.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3802 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/problems/test_vibrational_structure_problem.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/properties/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2425 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/property_test.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/properties/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)     2336 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/resources/angular_momentum_op.json
+-rw-r--r--   0 runner    (1001) docker     (123)     2707 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/resources/vibrational_energy_op.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1489 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/test_angular_momentum.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2111 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/test_dipole_moment.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12358 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/test_electronic_density.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1315 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/test_magnetization.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1646 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/test_occupied_modals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1317 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/properties/test_particle_number.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/transformers/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/transformers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/second_q/transformers/resources/
+-rw-r--r--   0 runner    (1001) docker     (123)    24880 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/transformers/resources/BeH_sto3g_reduced.json
+-rw-r--r--   0 runner    (1001) docker     (123)    34241 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/transformers/resources/LiH_sto3g_reduced.json
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/transformers/resources/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15919 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/transformers/test_active_space_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8122 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/transformers/test_basis_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6795 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/transformers/test_freeze_core_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1235 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/second_q/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21557 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/test_deprecation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2097 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/test_end2end_with_vqe.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3942 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/test_hdf5.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5223 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/test_logging.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2540 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/test_readme_sample.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/transformers/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/
+-rw-r--r--   0 runner    (1001) docker     (123)    87427 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/BeH_sto3g.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    72011 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/BeH_sto3g_reduced.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    68723 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/H2_631g.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    64603 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/H2_sto3g.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    64603 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/H2_sto3g_v2.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    87427 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/LiH_sto3g.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)    77027 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/LiH_sto3g_reduced.hdf5
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18703 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/test_active_space_transformer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5415 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/test_freeze_core_transformer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-14 13:12:08.000000 qiskit-nature-0.6.0/test/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1091 2023-04-14 13:11:53.000000 qiskit-nature-0.6.0/test/utils/test_linalg.py
```

### Comparing `qiskit-nature-0.5.2/LICENSE.txt` & `qiskit-nature-0.6.0/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -41,14 +41,15 @@
 Submodules
 ==========
 
 .. autosummary::
    :toctree:
 
    second_q
+   testing
    utils
 
 """
 
 from qiskit.algorithms.minimum_eigen_solvers.minimum_eigen_solver import (
     ListOrDict as ListOrDictType,
 )
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/eigensolver_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/eigensolver_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/numpy_eigensolver_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/eigensolver_factories/numpy_eigensolver_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/excited_states_eigensolver.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/excited_states_eigensolver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/excited_states_solver.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/excited_states_solver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/excited_states_solvers/qeom.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/excited_states_solvers/qeom.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/adapt_vqe.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/adapt_vqe.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/ground_state_eigensolver.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/ground_state_eigensolver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/ground_state_solver.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/ground_state_solver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/minimum_eigensolver_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/minimum_eigensolver_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/numpy_minimum_eigensolver_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/numpy_minimum_eigensolver_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_ucc_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_ucc_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uvcc_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uvcc_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/hf_initial_point.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/hf_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/initial_point.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/initial_point.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -28,15 +28,15 @@
     r"""The initial point interface.
 
     The interface for utility classes that provide an initial point for the ``VQE`` parameters for a
     particular ``EvolvedOperatorAnsatz``.
     """
 
     @abstractmethod
-    def __init__(self):
+    def __init__(self) -> None:
         self._ansatz: EvolvedOperatorAnsatz | None = None
         self._grouped_property: GroupedSecondQuantizedProperty | None = None
 
     @property
     @abstractmethod
     def ansatz(self) -> EvolvedOperatorAnsatz | None:
         """The evolved operator ansatz.
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/mp2_initial_point.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/mp2_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/initial_points/vscf_initial_point.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/initial_points/vscf_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/bopes_sampler.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/bopes_sampler.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/extrapolator.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/extrapolator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/energy_surface_spline.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/energy_surface_spline.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/harmonic_potential.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/harmonic_potential.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/morse_potential.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/morse_potential.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/algorithms/pes_samplers/potentials/potential_base.py` & `qiskit-nature-0.6.0/qiskit_nature/algorithms/pes_samplers/potentials/potential_base.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/chc.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/chc.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/puccd.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/puccd.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/succd.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/succd.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/ucc.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/ucc.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -391,15 +391,15 @@
     def _get_excitation_list(self) -> list[tuple[tuple[int, ...], tuple[int, ...]]]:
         generators = self._get_excitation_generators()
 
         logger.debug("Generating excitation list...")
         excitations = []
         for gen in generators:
             excitations.extend(
-                gen(
+                gen(  # pylint: disable=not-callable
                     num_spin_orbitals=self.num_spin_orbitals,
                     num_particles=self.num_particles,
                 )
             )
 
         return excitations
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/uccsd.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/uccsd.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/utils/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/utils/fermionic_excitation_generator.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/utils/fermionic_excitation_generator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/utils/vibration_excitation_generator.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/utils/vibration_excitation_generator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/uvcc.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/uvcc.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -260,15 +260,15 @@
     def _get_excitation_list(self) -> list[tuple[tuple[int, ...], tuple[int, ...]]]:
         generators = self._get_excitation_generators()
 
         logger.debug("Generating excitation list...")
         excitations = []
         for gen in generators:
             excitations.extend(
-                gen(
+                gen(  # pylint: disable=not-callable
                     num_modals=self.num_modals,
                 )
             )
 
         return excitations
 
     def _get_excitation_generators(self) -> list[Callable]:
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/ansatzes/uvccsd.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/ansatzes/uvccsd.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/bogoliubov_transform.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/bogoliubov_transform.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/fermionic_gaussian_state.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/fermionic_gaussian_state.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/hartree_fock.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/hartree_fock.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/slater_determinant.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/slater_determinant.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/utils/givens_rotations.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/utils/givens_rotations.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/circuit/library/initial_states/vscf.py` & `qiskit-nature-0.6.0/qiskit_nature/circuit/library/initial_states/vscf.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/constants.py` & `qiskit-nature-0.6.0/qiskit_nature/constants.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/converters/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/converters/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/qubit_converter.py` & `qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/qubit_converter.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/utils/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/converters/second_quantization/utils/list_or_dict.py` & `qiskit-nature-0.6.0/qiskit_nature/converters/second_quantization/utils/list_or_dict.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/deprecation.py` & `qiskit-nature-0.6.0/qiskit_nature/deprecation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021,2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -88,14 +88,22 @@
     old_type: DeprecatedType
     old_name: str
     new_type: DeprecatedType
     new_name: str
     additional_msg: str
 
 
+class _DeprecatedArgumentType(NamedTuple):
+    version: str
+    func_qualname: str
+    old_type: str
+    new_type: str
+    additional_msg: str
+
+
 class _DeprecatedArgument(NamedTuple):
     version: str
     func_qualname: str
     old_arg: str
     new_arg: str
     additional_msg: str
 
@@ -181,45 +189,92 @@
         new_name=new_name,
         additional_msg=additional_msg,
         stack_level=stack_level + 1,
         category=category,
     )
 
 
+def warn_deprecated_type(
+    version: str,
+    argument_name: str,
+    old_type: str,
+    new_type: Optional[str] = None,
+    additional_msg: Optional[str] = None,
+    stack_level: int = 2,
+    category: Type[Warning] = DeprecationWarning,
+) -> None:
+    """Emits deprecation warning the first time only
+       Used when only a specific supported type of an argument is to be deprecated.
+
+    Args:
+        version: Version to be used
+        argument_name: The name of the argument whose type gets deprecated.
+        old_type: Old type to be used
+        new_type: New type to be used, if None, the type is deprecated without replacement.
+        additional_msg: any additional message
+        stack_level: stack level
+        category: warning category
+    """
+    # skip if it was already added
+    obj = _DeprecatedArgumentType(version, argument_name, old_type, new_type, additional_msg)
+    if obj in _DEPRECATED_OBJECTS:
+        return
+
+    _DEPRECATED_OBJECTS.add(cast(NamedTuple, obj))
+
+    msg = (
+        f"The {old_type} type in the '{argument_name}' argument is deprecated as of version "
+        f"{version} and will be removed no sooner than 3 months after the release"
+    )
+    if new_type:
+        msg += f". Instead use the {new_type} type"
+    if additional_msg:
+        msg += f" {additional_msg}"
+    msg += "."
+
+    warnings.warn(msg, category=category, stacklevel=stack_level + 1)
+
+
 def _rename_kwargs(version, qualname, func_name, kwargs, kwarg_map, additional_msg, stack_level):
     for old_arg, new_arg in kwarg_map.items():
         if old_arg in kwargs:
             if new_arg in kwargs:
                 raise TypeError(f"{func_name} received both {new_arg} and {old_arg} (deprecated).")
 
             # skip if it was already added
             obj = _DeprecatedArgument(version, qualname, old_arg, new_arg, additional_msg)
             if obj not in _DEPRECATED_OBJECTS:
                 _DEPRECATED_OBJECTS.add(obj)
 
                 msg = (
                     f"{func_name}: the {old_arg} {DeprecatedType.ARGUMENT.value} is deprecated "
                     f"as of version {version} and will be removed no sooner "
-                    "than 3 months after the release. Instead use the "
-                    f"{new_arg} {DeprecatedType.ARGUMENT.value}"
+                    "than 3 months after the release"
                 )
+                if new_arg:
+                    msg += f". Instead use the {new_arg} {DeprecatedType.ARGUMENT.value}"
                 if additional_msg:
                     msg += f" {additional_msg}"
                 msg += "."
                 warnings.warn(msg, DeprecationWarning, stacklevel=stack_level)
-            kwargs[new_arg] = kwargs.pop(old_arg)
+
+            if new_arg:
+                kwargs[new_arg] = kwargs.pop(old_arg)
 
 
 def deprecate_arguments(
     version: str,
     kwarg_map: Dict[str, str],
     additional_msg: Optional[str] = None,
     stack_level: int = 3,
 ) -> Callable:
     """Decorator to alias deprecated argument names and warn upon use.
+
+    When the new argument name is an empty string, this deprecates the argument without replacement.
+
     Args:
         version: Version to be used
         kwarg_map: Args dictionary with old, new arguments
         additional_msg: any additional message
         stack_level: stack level
 
     Returns:
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/bosonic_bases/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/bosonic_bases/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/bosonic_bases/bosonic_basis.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/bosonic_bases/bosonic_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/bosonic_bases/harmonic_basis.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/bosonic_bases/harmonic_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/molecule.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/molecule.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/qmolecule.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/qmolecule.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/base_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/base_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/electronic_structure_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/electronic_structure_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/dumper.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/dumper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/fcidumpdriver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/fcidumpdriver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/fcidumpd/parser.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/fcidumpd/parser.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/LICENSE.txt` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/QCMatEl.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/QCMatEl.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/QCOpMat.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/QCOpMat.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.F` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.F`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_forces_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_forces_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_log_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_log_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_log_result.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_log_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_utils.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussian_utils.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/gaussiand/gaussiandriver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/gaussiand/gaussiandriver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/hdf5d/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/hdf5d/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/hdf5d/hdf5driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/hdf5d/hdf5driver.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -96,16 +96,16 @@
 
         new_hdf5_file = hdf5_file
         if not replace:
             new_hdf5_file = hdf5_file.with_name(str(hdf5_file.stem) + "_new.hdf5")
 
         warnings.filterwarnings("ignore", category=DeprecationWarning)
         driver_result = ElectronicStructureDriverResult.from_legacy_driver_result(q_mol)
-        warnings.filterwarnings("default", category=DeprecationWarning)
         save_to_hdf5(driver_result, str(new_hdf5_file), replace=replace)
+        warnings.filterwarnings("default", category=DeprecationWarning)
 
     def run(self) -> GroupedSecondQuantizedProperty:
         """
         Returns:
             GroupedSecondQuantizedProperty re-constructed from the HDF5 file.
 
         Raises:
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/psi4d/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/psi4d/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/psi4d/_template.txt` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/psi4d/_template.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/psi4d/psi4driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/psi4d/psi4driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyquanted/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyquanted/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyquanted/pyquantedriver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyquanted/pyquantedriver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyscfd/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyscfd/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/vibrational_structure_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/vibrational_structure_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/second_quantization/vibrational_structure_molecule_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/second_quantization/vibrational_structure_molecule_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/units_type.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/units_type.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/drivers/watson_hamiltonian.py` & `qiskit-nature-0.6.0/qiskit_nature/drivers/watson_hamiltonian.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/exceptions.py` & `qiskit-nature-0.6.0/qiskit_nature/exceptions.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/hdf5.py` & `qiskit-nature-0.6.0/qiskit_nature/hdf5.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/list_or_dict.py` & `qiskit-nature-0.6.0/qiskit_nature/list_or_dict.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/logging.py` & `qiskit-nature-0.6.0/qiskit_nature/logging.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/bksf.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/bksf.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/bravyi_kitaev_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/bravyi_kitaev_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/direct_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/direct_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/fermionic_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/fermionic_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/jordan_wigner_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/jordan_wigner_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/linear_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/linear_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/logarithmic_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/logarithmic_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/parity_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/parity_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/qubit_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/qubit_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/spin_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/spin_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/mappers/second_quantization/vibrational_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/mappers/second_quantization/vibrational_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/operators/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/operators/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/fermionic_op.py` & `qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/fermionic_op.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/quadratic_hamiltonian.py` & `qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/quadratic_hamiltonian.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/second_quantized_op.py` & `qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/second_quantized_op.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/spin_op.py` & `qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/spin_op.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/operators/second_quantization/vibrational_op.py` & `qiskit-nature-0.6.0/qiskit_nature/operators/second_quantization/vibrational_op.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/optionals.py` & `qiskit-nature-0.6.0/qiskit_nature/optionals.py`

 * *Files 8% similar despite different names*

```diff
@@ -83,7 +83,11 @@
 )
 
 HAS_SPARSE = LazyImportTester(
     "sparse",
     name="sparse",
     install="pip install 'qiskit-nature[sparse]'",
 )
+
+HAS_OPT_EINSUM = LazyImportTester(
+    "opt_einsum", name="Optimized einsum", install="pip install opt_einsum"
+)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_contacts/contact_map.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_contacts/contact_map.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_contacts/contact_map_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_contacts/contact_map_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_distances/distance_map.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_distances/distance_map.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/bead_distances/distance_map_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/bead_distances/distance_map_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/data_loaders/energy_matrix_loader.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/data_loaders/energy_matrix_loader.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_residue_exception.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_residue_exception.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_side_chain_exception.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_side_chain_exception.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_size_exception.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/exceptions/invalid_size_exception.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/interaction.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/interaction.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/mixed_interaction.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/mixed_interaction.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/miyazawa_jernigan_interaction.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/miyazawa_jernigan_interaction.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/random_interaction.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/random_interaction.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/resources/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/resources/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/interactions/resources/mj_matrix.txt` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/interactions/resources/mj_matrix.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/penalty_parameters.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/penalty_parameters.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/beads/base_bead.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/beads/base_bead.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/beads/main_bead.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/beads/main_bead.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/beads/side_bead.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/beads/side_bead.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/chains/base_chain.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/chains/base_chain.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/chains/main_chain.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/chains/main_chain.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/chains/side_chain.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/chains/side_chain.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/pauli_ops_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/pauli_ops_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/peptide/peptide.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/peptide/peptide.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/protein_folding_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/protein_folding_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/qubit_op_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/qubit_op_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/qubit_utils/qubit_fixing.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/qubit_utils/qubit_fixing.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/qubit_utils/qubit_number_reducer.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/qubit_utils/qubit_number_reducer.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/protein_folding/residue_validator.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/protein_folding/residue_validator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/sampling/sampling_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/sampling/sampling_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/base_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/base_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/builders/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/builders/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/builders/hopping_ops_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/builders/hopping_ops_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/electronic/electronic_structure_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/electronic/electronic_structure_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattice_model_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattice_model_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/boundary_condition.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/boundary_condition.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/hyper_cubic_lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/hyper_cubic_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/line_lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/line_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/square_lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/square_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/lattices/triangular_lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/lattices/triangular_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/fermi_hubbard_model.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/fermi_hubbard_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/ising_model.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/ising_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/lattice/models/lattice_model.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/lattice/models/lattice_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/builders/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/builders/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/builders/hopping_ops_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/builders/hopping_ops_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/builders/vibrational_label_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/builders/vibrational_label_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/problems/second_quantization/vibrational/vibrational_structure_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/problems/second_quantization/vibrational/vibrational_structure_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/grouped_property.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/grouped_property.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/property.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/property.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/driver_metadata.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/driver_metadata.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/angular_momentum.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/angular_momentum.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/bases/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/bases/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/bases/electronic_basis.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/bases/electronic_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/bases/electronic_basis_transform.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/bases/electronic_basis_transform.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/dipole_moment.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/dipole_moment.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/electronic_energy.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/electronic_energy.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/electronic_structure_driver_result.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/electronic_structure_driver_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/electronic_integrals.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/electronic_integrals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/integral_property.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/integral_property.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/one_body_electronic_integrals.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/one_body_electronic_integrals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/integrals/two_body_electronic_integrals.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/integrals/two_body_electronic_integrals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/magnetization.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/magnetization.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/particle_number.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/particle_number.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/electronic/types.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/electronic/types.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/second_quantized_property.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/second_quantized_property.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/bases/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/bases/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/bases/harmonic_basis.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/bases/harmonic_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/bases/vibrational_basis.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/bases/vibrational_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/integrals/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/integrals/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/integrals/vibrational_integrals.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/integrals/vibrational_integrals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/occupied_modals.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/occupied_modals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/types.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/types.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/vibrational_energy.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/vibrational_energy.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/properties/second_quantization/vibrational/vibrational_structure_driver_result.py` & `qiskit-nature-0.6.0/qiskit_nature/properties/second_quantization/vibrational/vibrational_structure_driver_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/results/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/bopes_sampler_result.py` & `qiskit-nature-0.6.0/qiskit_nature/results/bopes_sampler_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/eigenstate_result.py` & `qiskit-nature-0.6.0/qiskit_nature/results/eigenstate_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/electronic_structure_result.py` & `qiskit-nature-0.6.0/qiskit_nature/results/electronic_structure_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/lattice_model_result.py` & `qiskit-nature-0.6.0/qiskit_nature/results/lattice_model_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/protein_folding_result.py` & `qiskit-nature-0.6.0/qiskit_nature/results/protein_folding_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/utils/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/results/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/utils/protein_plotter.py` & `qiskit-nature-0.6.0/qiskit_nature/results/utils/protein_plotter.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/utils/protein_shape_decoder.py` & `qiskit-nature-0.6.0/qiskit_nature/results/utils/protein_shape_decoder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/utils/protein_shape_file_gen.py` & `qiskit-nature-0.6.0/qiskit_nature/results/utils/protein_shape_file_gen.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/results/vibrational_structure_result.py` & `qiskit-nature-0.6.0/qiskit_nature/results/vibrational_structure_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/runtime/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/runtime/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,25 +1,30 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """
-Qiskit Nature Runtime (:mod:`qiskit_nature.runtime`)
-====================================================
+DEPRECATED Qiskit Nature Runtime (:mod:`qiskit_nature.runtime`)
+===============================================================
 
 .. currentmodule:: qiskit_nature.runtime
 
+.. warning::
+    This entire module is deprecated as of version 0.6.0 and will be removed no sooner than 3 months
+    after the release. Instead you should update your code to use the Qiskit Runtime Primitives. For
+    more details on how to migrate check out this guide, here: https://qisk.it/algo_migration#vqe !
+
 Programs that embed Qiskit Runtime in the algorithmic interfaces and facilitate usage of
 algorithms and scripts in the cloud.
 
 .. autosummary::
    :toctree: ../stubs/
    :nosignatures:
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/runtime/vqe_client.py` & `qiskit-nature-0.6.0/qiskit_nature/runtime/vqe_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -16,31 +16,33 @@
 from typing import Callable, Optional, Any, Dict, Union
 import warnings
 import numpy as np
 
 from qiskit import QuantumCircuit
 from qiskit.exceptions import QiskitError
 from qiskit.providers import Provider
-from qiskit.providers.backend import Backend
+from qiskit.providers.backend import Backend, BackendV2
 from qiskit.algorithms import (
     MinimumEigensolver,
     MinimumEigensolverResult,
     VQEResult,
     VariationalAlgorithm,
 )
 from qiskit.algorithms.optimizers import Optimizer, SPSA
 from qiskit.opflow import OperatorBase, PauliSumOp
 from qiskit.quantum_info import SparsePauliOp
+
 from qiskit_nature import ListOrDictType
+from qiskit_nature.deprecation import warn_deprecated, DeprecatedType
 
 from ..converters.second_quantization.utils import ListOrDict
 
 
 class VQEClient(VariationalAlgorithm, MinimumEigensolver):
-    """The Qiskit Nature VQE Runtime Client.
+    """DEPRECATED The Qiskit Nature VQE Runtime Client.
 
     This class is a client to call the VQE program in Qiskit Runtime."""
 
     def __init__(
         self,
         ansatz: QuantumCircuit,
         optimizer: Optional[Union[Optimizer, Dict[str, Any]]] = None,
@@ -70,14 +72,24 @@
                 Four parameter values are passed to the callback as follows during each evaluation
                 by the optimizer for its current set of parameters as it works towards the minimum.
                 These are: the evaluation count, the optimizer parameters for the
                 ansatz, the evaluated mean and the evaluated standard deviation.
             store_intermediate: Whether or not to store intermediate values of the optimization
                 steps. Per default False.
         """
+        warn_deprecated(
+            "0.6.0",
+            DeprecatedType.CLASS,
+            "VQEClient",
+            additional_msg=(
+                ". Instead you should use the new primitives based VQE with the Qiskit IBM Runtime "
+                "Estimator primitive. For more details on how to migrate check out this guide, "
+                "here: https://qisk.it/algo_migration#vqe"
+            ),
+        )
         with warnings.catch_warnings():
             warnings.simplefilter("ignore")
             super().__init__()
         if optimizer is None:
             optimizer = SPSA(maxiter=300)
 
         # define program name
@@ -285,15 +297,19 @@
             "initial_point": self.initial_point,
             "shots": self.shots,
             "measurement_error_mitigation": self.measurement_error_mitigation,
             "store_intermediate": self.store_intermediate,
         }
 
         # define runtime options
-        options = {"backend_name": self.backend.name()}
+        options = {
+            "backend_name": self.backend.name
+            if isinstance(self.backend, BackendV2)
+            else self.backend.name()
+        }
 
         # send job to runtime and return result
         job = self.provider.runtime.run(
             program_id=self.program_id,
             inputs=inputs,
             options=options,
             callback=self._wrap_vqe_callback(),
@@ -330,21 +346,22 @@
         vqe_result.optimizer_time = result.get("optimizer_time", None)
         vqe_result.optimizer_history = result.get("optimizer_history", None)
 
         return vqe_result
 
 
 class VQERuntimeResult(VQEResult):
-    """The VQEClient result object.
+    """DEPRECATED The VQEClient result object.
 
     This result objects contains the same as the VQEResult and additionally the history
     of the optimizer, containing information such as the function and parameter values per step.
     """
 
     def __init__(self) -> None:
+        warn_deprecated("0.6.0", DeprecatedType.CLASS, "VQERuntimeResult")
         super().__init__()
         self._job_id = None  # type: str
         self._optimizer_history = None  # type: Dict[str, Any]
 
     @property
     def job_id(self) -> str:
         """The job ID associated with the VQE runtime job."""
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -15,18 +15,19 @@
 ==================================================================================================
 
 .. currentmodule:: qiskit_nature.second_q.algorithms.excited_states_solvers
 
 """
 
 from .excited_states_solver import ExcitedStatesSolver
-from .qeom import QEOM
+from .qeom import QEOM, QEOMResult
 from .eigensolver_factories import EigensolverFactory, NumPyEigensolverFactory
 from .excited_states_eigensolver import ExcitedStatesEigensolver
 
 __all__ = [
     "ExcitedStatesSolver",
     "ExcitedStatesEigensolver",
     "EigensolverFactory",
     "NumPyEigensolverFactory",
     "QEOM",
+    "QEOMResult",
 ]
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """
 Eigensolver Factories
 (:mod:`qiskit_nature.second_q.algorithms.excited_states_solvers.eigensolver_factories`)
 =======================================================================================
 
-Factories that create an eigensolver based on a qubit transformation.
+DEPRECATED Factories that create an eigensolver based on a qubit transformation.
 
 .. currentmodule:: qiskit_nature.second_q.algorithms.excited_states_solvers.eigensolver_factories
 
 """
 
 from .eigensolver_factory import EigensolverFactory
 from .numpy_eigensolver_factory import NumPyEigensolverFactory
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/eigensolver_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/eigensolver_factory.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -16,15 +16,15 @@
 
 from qiskit.algorithms.eigensolvers import Eigensolver
 
 from qiskit_nature.second_q.problems.base_problem import BaseProblem
 
 
 class EigensolverFactory(ABC):
-    """A factory to construct an eigensolver based on a qubit operator transformation."""
+    """DEPRECATED A factory to construct an eigensolver based on a qubit operator transformation."""
 
     @abstractmethod
     def get_solver(self, problem: BaseProblem) -> Eigensolver:
         """Returns an eigensolver, based on the qubit operator transformation.
 
         Args:
             problem: A class encoding a problem to be solved.
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/numpy_eigensolver_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/eigensolver_factories/numpy_eigensolver_factory.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -14,20 +14,27 @@
 
 from typing import Optional, Union, List, Callable
 
 import numpy as np
 from qiskit.algorithms.eigensolvers import Eigensolver, NumPyEigensolver
 from qiskit.utils.validation import validate_min
 
+from qiskit_nature.deprecation import DeprecatedType, warn_deprecated
 from qiskit_nature.second_q.problems.base_problem import BaseProblem
 from .eigensolver_factory import EigensolverFactory
 
 
 class NumPyEigensolverFactory(EigensolverFactory):
-    """A factory to construct a NumPyEigensolver."""
+    """DEPRECATED A factory to construct a NumPyEigensolver.
+
+    .. warning::
+
+        This class is deprecated! Please see :ref:`this guide <how-to-numpy>` for how to replace
+        your usage of it!
+    """
 
     def __init__(
         self,
         filter_criterion: Callable[
             [Union[List, np.ndarray], float, Optional[List[float]]], bool
         ] = None,
         k: int = 100,
@@ -42,14 +49,24 @@
                 whether to consider this value or not. If there is no
                 feasible element, the result can even be empty.
             use_default_filter_criterion: Whether to use default filter criteria or not.
             k: How many eigenvalues are to be computed, has a min. value of 1.
             use_default_filter_criterion: Whether to use the transformation's default filter
                 criterion if ``filter_criterion`` is ``None``.
         """
+        warn_deprecated(
+            "0.6.0",
+            DeprecatedType.CLASS,
+            "NumPyMinimumEigensolverFactory",
+            additional_msg=(
+                ". This class is deprecated without replacement. Instead, refer to this how-to "
+                "guide which explains the steps you need to take to replace the use of this class: "
+                "https://qiskit.org/documentation/nature/howtos/numpy_minimum_eigensolver.html"
+            ),
+        )
         self._filter_criterion = filter_criterion
         self._k = k  # pylint:disable=invalid-name
         self._use_default_filter_criterion = use_default_filter_criterion
 
     @property
     def filter_criterion(
         self,
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/excited_states_eigensolver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/excited_states_eigensolver.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,130 +1,181 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """The calculation of excited states via an Eigensolver algorithm."""
 
 from __future__ import annotations
 
-from typing import Union, Optional, Tuple
+import logging
 
 from qiskit.algorithms.eigensolvers import Eigensolver
 from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
 
-from qiskit_nature import QiskitNatureError
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from qiskit_nature.second_q.operators import SparseLabelOp
 from qiskit_nature.second_q.problems import BaseProblem
 from qiskit_nature.second_q.problems import EigenstateResult
+from qiskit_nature.deprecation import deprecate_arguments, warn_deprecated_type
 
 from .excited_states_solver import ExcitedStatesSolver
 from .eigensolver_factories import EigensolverFactory
 
+LOGGER = logging.getLogger(__name__)
+
 
 class ExcitedStatesEigensolver(ExcitedStatesSolver):
     """The calculation of excited states via an Eigensolver algorithm."""
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
-        qubit_converter: QubitConverter,
-        solver: Union[Eigensolver, EigensolverFactory],
+        qubit_mapper: QubitConverter | QubitMapper,
+        solver: Eigensolver | EigensolverFactory,
+        *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
     ) -> None:
+        # pylint: disable=unused-argument
         """
 
         Args:
-            qubit_converter: The ``QubitConverter`` to use for mapping and symmetry reduction. The
-                             Z2 symmetries stored in this instance are the basis for the
-                             commutativity information returned by this method.
+            qubit_mapper: The ``QubitMapper`` or ``QubitConverter`` (use of the latter is
+                deprecated) to use for mapping.
             solver: Minimum Eigensolver or MESFactory object.
+            qubit_converter: DEPRECATED The ``QubitConverter`` or ``QubitMapper`` to use for mapping
+                and symmetry reduction.
         """
-        self._qubit_converter = qubit_converter
+        if isinstance(solver, EigensolverFactory):
+            warn_deprecated_type(
+                "0.6.0",
+                "solver",
+                "EigensolverFactory",
+            )
+        self._qubit_mapper = qubit_mapper
         self._solver = solver
 
     @property
-    def solver(self) -> Union[Eigensolver, EigensolverFactory]:
+    def solver(self) -> Eigensolver | EigensolverFactory:
         """Returns the minimum eigensolver or factory."""
         return self._solver
 
     @solver.setter
-    def solver(self, solver: Union[Eigensolver, EigensolverFactory]) -> None:
+    def solver(self, solver: Eigensolver | EigensolverFactory) -> None:
         """Sets the minimum eigensolver or factory."""
+        if isinstance(solver, EigensolverFactory):
+            warn_deprecated_type(
+                "0.6.0",
+                "solver",
+                "EigensolverFactory",
+            )
         self._solver = solver
 
     def get_qubit_operators(
         self,
         problem: BaseProblem,
-        aux_operators: Optional[dict[str, Union[SparseLabelOp, PauliSumOp]]] = None,
-    ) -> Tuple[PauliSumOp, Optional[dict[str, PauliSumOp]]]:
-        """Gets the operator and auxiliary operators, and transforms the provided auxiliary operators."""
+        aux_operators: dict[str, SparseLabelOp | PauliSumOp | SparsePauliOp] | None = None,
+    ) -> tuple[PauliSumOp | SparsePauliOp, dict[str, PauliSumOp | SparsePauliOp] | None]:
         # Note that ``aux_ops`` contains not only the transformed ``aux_operators`` passed by the
         # user but also additional ones from the transformation
         main_second_q_op, aux_second_q_ops = problem.second_q_ops()
 
         num_particles = getattr(problem, "num_particles", None)
 
-        main_operator = self._qubit_converter.convert(
-            main_second_q_op,
-            num_particles=num_particles,
-            sector_locator=problem.symmetry_sector_locator,
-        )
-        aux_ops = self._qubit_converter.convert_match(aux_second_q_ops)
+        if isinstance(self._qubit_mapper, QubitConverter):
+            main_operator = self._qubit_mapper.convert(
+                main_second_q_op,
+                num_particles=num_particles,
+                sector_locator=problem.symmetry_sector_locator,
+            )
+            aux_ops = self._qubit_mapper.convert_match(aux_second_q_ops)
+
+        else:
+            main_operator = self._qubit_mapper.map(main_second_q_op)
+            aux_ops = self._qubit_mapper.map(aux_second_q_ops)
 
         if aux_operators is not None:
             for name_aux, aux_op in aux_operators.items():
-                if isinstance(aux_op, SparseLabelOp):
-                    converted_aux_op = self._qubit_converter.convert_match(
-                        aux_op, suppress_none=True
+                if isinstance(aux_op, PauliSumOp):
+                    warn_deprecated_type(
+                        "0.6.0",
+                        argument_name="aux_operators",
+                        old_type="PauliSumOp",
+                        new_type="SparsePauliOp",
                     )
+                if isinstance(aux_op, SparseLabelOp):
+                    if isinstance(self._qubit_mapper, QubitConverter):
+                        converted_aux_op = self._qubit_mapper.convert_match(
+                            aux_op, suppress_none=True
+                        )
+                    else:
+                        converted_aux_op = self._qubit_mapper.map(aux_op)
                 else:
                     converted_aux_op = aux_op
+
                 if name_aux in aux_ops.keys():
-                    raise QiskitNatureError(
-                        f"The key '{name_aux}' is already taken by an internally constructed "
-                        "auxiliary operator! Please use a different name for your custom "
-                        "operator."
+                    LOGGER.warning(
+                        "The key '%s' was already taken by an internally constructed auxiliary "
+                        "operator! The internal operator was overridden by the one provided manually. "
+                        "If this was not the intended behavior, please consider renaming "
+                        "this operator.",
+                        name_aux,
+                    )
+                if converted_aux_op is not None:
+                    # The custom op overrides the default op if the key is already taken.
+                    aux_ops[name_aux] = converted_aux_op
+                else:
+                    LOGGER.warning(
+                        "The manually provided operator '%s' got reduced to `None` in the mapping "
+                        "process. This can occur for example when it does not commute with the "
+                        "hamiltonian after applying the determined symmetry reductions. Thus, this "
+                        "operator will not be used!",
+                        name_aux,
                     )
-                aux_ops[name_aux] = converted_aux_op
 
         if isinstance(self._solver, EigensolverFactory):
+            warn_deprecated_type(
+                "0.6.0",
+                "solver",
+                "EigensolverFactory",
+            )
             # this must be called after transformation.transform
             self._solver = self._solver.get_solver(problem)
 
         # if the eigensolver does not support auxiliary operators, reset them
         if not self._solver.supports_aux_operators():
             aux_ops = None
         return main_operator, aux_ops
 
     def solve(
         self,
         problem: BaseProblem,
-        aux_operators: Optional[dict[str, Union[SparseLabelOp, PauliSumOp]]] = None,
+        aux_operators: dict[str, SparseLabelOp | PauliSumOp | SparsePauliOp] | None = None,
     ) -> EigenstateResult:
         """Compute Ground and Excited States properties.
 
         Args:
             problem: A class encoding a problem to be solved.
             aux_operators: Additional auxiliary operators to evaluate.
 
-        Raises:
-            ValueError: If the grouped property object returned by the driver does not contain a
-                main property as requested by the problem being solved (`problem.main_property_name`).
-            QiskitNatureError: If the user-provided ``aux_operators`` contain a name which clashes
-                with an internally constructed auxiliary operator. Note: the names used for the
-                internal auxiliary operators correspond to the `Property.name` attributes which
-                generated the respective operators.
-
         Returns:
             An interpreted :class:`~.EigenstateResult`. For more information see also
             :meth:`~.BaseProblem.interpret`.
         """
         # get the operator and auxiliary operators, and transform the provided auxiliary operators
         # note that ``aux_operators`` contains not only the transformed ``aux_operators`` passed
         # by the user but also additional ones from the transformation
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/excited_states_solver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/excited_states_solver.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,41 +1,41 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """The excited states calculation interface."""
 
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
-from typing import Optional, Union, Tuple
 
 from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
 
 from qiskit_nature.second_q.operators import SparseLabelOp
 from qiskit_nature.second_q.problems import BaseProblem
 from qiskit_nature.second_q.problems import EigenstateResult
 
 
 class ExcitedStatesSolver(ABC):
     """The excited states calculation interface."""
 
     @abstractmethod
     def solve(
         self,
         problem: BaseProblem,
-        aux_operators: Optional[dict[str, Union[SparseLabelOp, PauliSumOp]]] = None,
+        aux_operators: dict[str, SparseLabelOp | PauliSumOp | SparsePauliOp] | None = None,
     ) -> EigenstateResult:
         r"""Compute the excited states energies of the molecule that was supplied via the driver.
 
         Args:
             problem: A class encoding a problem to be solved.
             aux_operators: Additional auxiliary operators to evaluate.
 
@@ -50,21 +50,23 @@
     def solver(self):
         """Returns the solver."""
 
     @abstractmethod
     def get_qubit_operators(
         self,
         problem: BaseProblem,
-        aux_operators: Optional[dict[str, Union[SparseLabelOp, PauliSumOp]]] = None,
-    ) -> Tuple[PauliSumOp, Optional[dict[str, PauliSumOp]]]:
-        """Construct qubit operators by getting the second quantized operators from the problem
-        (potentially running a driver in doing so [can be computationally expensive])
-        and using a QubitConverter to map and reduce the operators to qubit operators.
+        aux_operators: dict[str, SparseLabelOp | SparsePauliOp | PauliSumOp] | None = None,
+    ) -> tuple[PauliSumOp | SparseLabelOp, dict[str, PauliSumOp | SparseLabelOp] | None]:
+        """Gets the operator and auxiliary operators, and transforms the provided auxiliary operators
+        using a ``QubitConverter`` or ``QubitMapper``.
+        If the user-provided ``aux_operators`` contain a name which clashes with an internally
+        constructed auxiliary operator, then the corresponding internal operator will be overridden by
+        the user-provided operator.
 
         Args:
-            problem: A class encoding a problem to be solved.
-            aux_operators: Additional auxiliary operators to evaluate.
+            problem:  A class encoding a problem defining the qubit operators.
+            aux_operators: Additional auxiliary operators to transform.
 
         Returns:
-            Qubit operator.
-            Additional auxiliary operators.
+            A tuple with the main operator (hamiltonian) and a dictionary of auxiliary default and
+            custom operators.
         """
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom_electronic_ops_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom_electronic_ops_builder.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,139 +1,162 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Utility methods to build fermionic hopping operators."""
 
 from __future__ import annotations
 
-from typing import Callable, Dict, List, Tuple
+from typing import Callable
 
 from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
 from qiskit.tools import parallel_map
 from qiskit.utils import algorithm_globals
 
 from qiskit_nature import QiskitNatureError
 from qiskit_nature.second_q.circuit.library import UCC
 from qiskit_nature.second_q.operators import FermionicOp
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper, TaperedQubitMapper
+from qiskit_nature.deprecation import deprecate_arguments
 
 
+@deprecate_arguments(
+    "0.6.0",
+    {"qubit_converter": "qubit_mapper"},
+    additional_msg=(
+        ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+        "and support for it will be removed together with the qubit_converter argument."
+    ),
+)
 def build_electronic_ops(
     num_spatial_orbitals: int,
-    num_particles: Tuple[int, int],
+    num_particles: tuple[int, int],
     excitations: str
     | int
     | list[int]
     | Callable[
         [int, tuple[int, int]],
         list[tuple[tuple[int, ...], tuple[int, ...]]],
     ],
-    qubit_converter: QubitConverter,
-) -> Tuple[
-    Dict[str, PauliSumOp],
-    Dict[str, List[bool]],
-    Dict[str, Tuple[Tuple[int, ...], Tuple[int, ...]]],
+    qubit_mapper: QubitConverter | QubitMapper,
+    *,
+    qubit_converter: QubitConverter | QubitMapper | None = None,
+) -> tuple[
+    dict[str, PauliSumOp | SparsePauliOp],
+    dict[str, list[bool]],
+    dict[str, tuple[tuple[int, ...], tuple[int, ...]]],
 ]:
+    # pylint: disable=unused-argument
     """Builds the product of raising and lowering operators (basic excitation operators)
 
     Args:
         num_spatial_orbitals: The number of spatial orbitals.
         num_particles: The number of alpha- and beta-spin particles as a tuple.
         excitations: The types of excitations to consider. The simple cases for this input are:
             - a `str` containing any of the following characters: `s`, `d`, `t` or `q`.
             - a single, positive `int` denoting the excitation type (1 == `s`, etc.).
             - a list of positive integers.
             - and finally a callable which can be used to specify a custom list of excitations.
               For more details on how to write such a function refer to the default method,
               :meth:`generate_fermionic_excitations`.
-        qubit_converter: The ``QubitConverter`` to use for mapping and symmetry reduction. The Z2
-                         symmetries stored in this instance are the basis for the commutativity
-                         information returned by this method.
+        qubit_mapper: The ``QubitMapper`` or ``QubitConverter`` (use of the latter is deprecated) to
+            use for mapping.
+        qubit_converter: DEPRECATED The ``QubitConverter`` or ``QubitMapper`` to use for mapping and
+            symmetry reduction. The Z2 symmetries stored in this instance are the basis for the
+            commutativity information returned by this method. These symmetries are set to ``None``
+            when a ``QubitMapper`` is used.
 
     Returns:
         A tuple containing the hopping operators, the types of commutativities and the excitation
         indices.
     """
 
     num_alpha, num_beta = num_particles
 
-    ansatz = UCC(num_spatial_orbitals, (num_alpha, num_beta), excitations, qubit_converter)
+    ansatz = UCC(num_spatial_orbitals, (num_alpha, num_beta), excitations, qubit_mapper)
     excitations_list = ansatz._get_excitation_list()
     size = len(excitations_list)
 
     # build all hopping operators
-    hopping_operators: Dict[str, PauliSumOp] = {}
-    type_of_commutativities: Dict[str, List[bool]] = {}
-    excitation_indices: Dict[str, Tuple[Tuple[int, ...], Tuple[int, ...]]] = {}
+    hopping_operators: dict[str, PauliSumOp | SparsePauliOp] = {}
+    type_of_commutativities: dict[str, list[bool]] = {}
+    excitation_indices: dict[str, tuple[tuple[int, ...], tuple[int, ...]]] = {}
     to_be_executed_list = []
     for idx in range(size):
         to_be_executed_list += [excitations_list[idx], excitations_list[idx][::-1]]
         hopping_operators[f"E_{idx}"] = None
         hopping_operators[f"Edag_{idx}"] = None
         type_of_commutativities[f"E_{idx}"] = None
         type_of_commutativities[f"Edag_{idx}"] = None
         excitation_indices[f"E_{idx}"] = excitations_list[idx]
         excitation_indices[f"Edag_{idx}"] = excitations_list[idx][::-1]
 
     result = parallel_map(
         _build_single_hopping_operator,
         to_be_executed_list,
-        task_args=(num_spatial_orbitals, qubit_converter),
+        task_args=(num_spatial_orbitals, qubit_mapper),
         num_processes=algorithm_globals.num_processes,
     )
 
     for key, res in zip(hopping_operators.keys(), result):
         hopping_operators[key] = res[0]
         type_of_commutativities[key] = res[1]
 
     return hopping_operators, type_of_commutativities, excitation_indices
 
 
 def _build_single_hopping_operator(
-    excitation: Tuple[Tuple[int, ...], Tuple[int, ...]],
+    excitation: tuple[tuple[int, ...], tuple[int, ...]],
     num_spatial_orbitals: int,
-    qubit_converter: QubitConverter,
-) -> Tuple[PauliSumOp, List[bool]]:
+    qubit_mapper: QubitConverter | QubitMapper,
+) -> tuple[PauliSumOp | SparsePauliOp, list[bool]]:
     label = []
     for occ in excitation[0]:
         label.append(f"+_{occ}")
     for unocc in excitation[1]:
         label.append(f"-_{unocc}")
-    fer_op = FermionicOp(
-        {" ".join(label): 4.0 ** len(excitation[0])}, num_spin_orbitals=2 * num_spatial_orbitals
-    )
+    fer_op = FermionicOp({" ".join(label): 1.0}, num_spin_orbitals=2 * num_spatial_orbitals)
 
-    qubit_op = qubit_converter.convert_only(fer_op, qubit_converter.num_particles)
-    z2_symmetries = qubit_converter.z2symmetries
+    if isinstance(qubit_mapper, QubitConverter):
+        qubit_op = qubit_mapper.convert_only(fer_op, num_particles=qubit_mapper.num_particles)
+        symmetries_for_commutativity = qubit_mapper.z2symmetries.symmetries
+    elif isinstance(qubit_mapper, TaperedQubitMapper):
+        qubit_op = qubit_mapper.map_clifford(fer_op)
+        # Because the clifford conversion was already done, the commutativity information are based
+        # on the single qubit pauli objects.
+        symmetries_for_commutativity = qubit_mapper.z2symmetries.sq_paulis
+    else:
+        qubit_op = qubit_mapper.map(fer_op)
+        symmetries_for_commutativity = []
 
     commutativities = []
-    if not z2_symmetries.is_empty():
-        for symmetry in z2_symmetries.symmetries:
-            symmetry_op = PauliSumOp.from_list([(symmetry.to_label(), 1.0)])
-            paulis = qubit_op.primitive.paulis
+    if not len(symmetries_for_commutativity) == 0:
+        for symmetry in symmetries_for_commutativity:
+            symmetry_op = SparsePauliOp.from_list([(symmetry.to_label(), 1.0)])
+            if isinstance(qubit_op, PauliSumOp):
+                paulis = qubit_op.primitive.paulis
+            else:
+                paulis = qubit_op.paulis
             len_paulis = len(paulis)
-            commuting = len(paulis.commutes_with_all(symmetry_op.primitive.paulis)) == len_paulis
-            anticommuting = (
-                len(paulis.anticommutes_with_all(symmetry_op.primitive.paulis)) == len_paulis
-            )
+            commuting = len(paulis.commutes_with_all(symmetry_op.paulis)) == len_paulis
+            anticommuting = len(paulis.anticommutes_with_all(symmetry_op.paulis)) == len_paulis
 
             if commuting != anticommuting:  # only one of them is True
                 if commuting:
                     commutativities.append(True)
                 elif anticommuting:
                     commutativities.append(False)
             else:
                 raise QiskitNatureError(
                     f"Symmetry {symmetry.to_label()} neither commutes nor anti-commutes "
                     "with excitation operator."
                 )
-
     return qubit_op, commutativities
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom_vibrational_ops_builder.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/excited_states_solvers/qeom_vibrational_ops_builder.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,105 +1,127 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Utility methods to build vibrational hopping operators."""
 
 from __future__ import annotations
 
-from typing import Callable, Dict, List, Tuple
+from typing import Callable
 
 from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
 from qiskit.tools import parallel_map
 from qiskit.utils import algorithm_globals
 
 from qiskit_nature.second_q.circuit.library import UVCC
 from qiskit_nature.second_q.operators import VibrationalOp
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper, TaperedQubitMapper
+from qiskit_nature.deprecation import deprecate_arguments
 
 
+@deprecate_arguments(
+    "0.6.0",
+    {"qubit_converter": "qubit_mapper"},
+    additional_msg=(
+        ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+        "and support for it will be removed together with the qubit_converter argument."
+    ),
+)
 def build_vibrational_ops(
-    num_modals: List[int],
+    num_modals: list[int],
     excitations: str
     | int
     | list[int]
     | Callable[
         [int, tuple[int, int]],
         list[tuple[tuple[int, ...], tuple[int, ...]]],
     ],
-    qubit_converter: QubitConverter,
-) -> Tuple[
-    Dict[str, PauliSumOp],
-    Dict[str, List[bool]],
-    Dict[str, Tuple[Tuple[int, ...], Tuple[int, ...]]],
+    qubit_mapper: QubitConverter | QubitMapper,
+    *,
+    qubit_converter: QubitConverter | QubitMapper | None = None,
+) -> tuple[
+    dict[str, PauliSumOp | SparsePauliOp],
+    dict[str, list[bool]],
+    dict[str, tuple[tuple[int, ...], tuple[int, ...]]],
 ]:
+    # pylint: disable=unused-argument
     """
     Args:
         num_modals: The number of modals per mode.
         excitations: The types of excitations to consider. The simple cases for this input are:
             - a `str` containing any of the following characters: `s`, `d`, `t` or `q`.
             - a single, positive `int` denoting the excitation type (1 == `s`, etc.).
             - a list of positive integers.
             - and finally a callable which can be used to specify a custom list of excitations.
               For more details on how to write such a function refer to the default method,
               :meth:`generate_vibrational_excitations`.
-        qubit_converter: The ``QubitConverter`` to use for mapping and symmetry reduction. The Z2
-                         symmetries stored in this instance are the basis for the commutativity
-                         information returned by this method.
+        qubit_mapper: The ``QubitMapper`` or ``QubitConverter`` (use of the latter is deprecated) to
+            use for mapping.
+        qubit_converter: DEPRECATED The ``QubitConverter`` or ``QubitMapper`` to use for mapping and
+            symmetry reduction. Note that the ``QubitConverter`` will use its stored Z2 symmetries
+            as basis for the commutativity information returned by this method.
     Returns:
         Dict of hopping operators, dict of commutativity types and dict of excitation indices.
     """
 
-    ansatz = UVCC(num_modals, excitations, qubit_converter)
+    ansatz = UVCC(num_modals, excitations, qubit_mapper)
     excitations_list = ansatz._get_excitation_list()
     size = len(excitations_list)
 
-    hopping_operators: Dict[str, PauliSumOp] = {}
-    excitation_indices: Dict[str, Tuple[Tuple[int, ...], Tuple[int, ...]]] = {}
+    hopping_operators: dict[str, PauliSumOp | SparsePauliOp] = {}
+    excitation_indices: dict[str, tuple[tuple[int, ...], tuple[int, ...]]] = {}
     to_be_executed_list = []
     for idx in range(size):
         to_be_executed_list += [excitations_list[idx], excitations_list[idx][::-1]]
         hopping_operators[f"E_{idx}"] = None
         hopping_operators[f"Edag_{idx}"] = None
         excitation_indices[f"E_{idx}"] = excitations_list[idx]
         excitation_indices[f"Edag_{idx}"] = excitations_list[idx][::-1]
 
     result = parallel_map(
         _build_single_hopping_operator,
         to_be_executed_list,
-        task_args=(num_modals, qubit_converter),
+        task_args=(num_modals, qubit_mapper),
         num_processes=algorithm_globals.num_processes,
     )
 
     for key, res in zip(hopping_operators.keys(), result):
         hopping_operators[key] = res
 
     # This variable is required for compatibility with the ElectronicStructureProblem
     # at the moment we do not have any type of commutativity in the bosonic case.
-    type_of_commutativities: Dict[str, List[bool]] = {}
+    type_of_commutativities: dict[str, list[bool]] = {}
 
     return hopping_operators, type_of_commutativities, excitation_indices
 
 
 def _build_single_hopping_operator(
-    excitation: Tuple[Tuple[int, ...], Tuple[int, ...]],
-    num_modals: List[int],
-    qubit_converter: QubitConverter,
+    excitation: tuple[tuple[int, ...], tuple[int, ...]],
+    num_modals: list[int],
+    qubit_mapper: QubitConverter | QubitMapper,
 ) -> PauliSumOp:
     label = []
     for occ in excitation[0]:
         label.append(f"+_{VibrationalOp.build_dual_index(num_modals, occ)}")
     for unocc in excitation[1]:
         label.append(f"-_{VibrationalOp.build_dual_index(num_modals, unocc)}")
 
     vibrational_op = VibrationalOp({" ".join(label): 1}, num_modals)
-    qubit_op: PauliSumOp = qubit_converter.convert_match(vibrational_op)
+
+    qubit_op: PauliSumOp
+    if isinstance(qubit_mapper, QubitConverter):
+        qubit_op = qubit_mapper.convert_match(vibrational_op)
+    elif isinstance(qubit_mapper, TaperedQubitMapper):
+        qubit_op = qubit_mapper.map_clifford(vibrational_op)
+    else:
+        qubit_op = qubit_mapper.map(vibrational_op)
 
     return qubit_op
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_solver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/minimum_eigensolver_factory.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,92 +1,70 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
-"""The ground state calculation interface."""
+"""The minimum eigensolver factory for ground state calculation algorithms."""
 
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
-from typing import Union
 
-from qiskit.opflow import PauliSumOp
-from qiskit.quantum_info.operators.base_operator import BaseOperator
+from qiskit.algorithms.minimum_eigensolvers import MinimumEigensolver
 
-from qiskit_nature.second_q.operators import SparseLabelOp
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from qiskit_nature.second_q.problems import BaseProblem
-from qiskit_nature.second_q.problems import EigenstateResult
+from qiskit_nature.deprecation import deprecate_arguments
 
-QubitOperator = Union[BaseOperator, PauliSumOp]
 
-
-class GroundStateSolver(ABC):
-    """The ground state calculation interface."""
-
-    def __init__(self, qubit_converter: QubitConverter) -> None:
-        """
-        Args:
-            qubit_converter: A class that converts second quantized operator to qubit operator
-                             according to a mapper it is initialized with.
-        """
-        self._qubit_converter = qubit_converter
+class MinimumEigensolverFactory(ABC):
+    """DEPRECATED A factory to construct a minimum eigensolver based on a qubit operator
+    transformation.
+    """
 
     @abstractmethod
-    def solve(
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
+    def get_solver(
         self,
         problem: BaseProblem,
-        aux_operators: dict[str, SparseLabelOp | QubitOperator] | None = None,
-    ) -> EigenstateResult:
-        """Compute the ground state energy of the molecule that was supplied via the driver.
+        qubit_mapper: QubitConverter | QubitMapper,
+        *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
+    ) -> MinimumEigensolver:
+        """Returns a minimum eigensolver, based on the qubit operator transformation.
 
         Args:
             problem: A class encoding a problem to be solved.
-            aux_operators: Additional auxiliary operators to evaluate.
+            qubit_mapper: A class that converts second quantized operator to qubit operator.
+                Providing a ``QubitConverter`` instance here is deprecated.
+            qubit_converter: DEPRECATED A class that converts second quantized operator to qubit
+                operator according to a mapper it is initialized with.
 
         Returns:
-            An interpreted :class:`~.EigenstateResult`. For more information see also
-            :meth:`~.BaseProblem.interpret`.
+            A minimum eigensolver suitable to compute the ground state of the molecule.
         """
         raise NotImplementedError
 
     @abstractmethod
-    def get_qubit_operators(
-        self,
-        problem: BaseProblem,
-        aux_operators: dict[str, SparseLabelOp | QubitOperator] | None = None,
-    ) -> tuple[QubitOperator, dict[str, QubitOperator] | None]:
-        """Construct qubit operators by getting the second quantized operators from the problem
-        (potentially running a driver in doing so [can be computationally expensive])
-        and using a QubitConverter to map and reduce the operators to qubit operators.
-
-        Args:
-            problem: A class encoding a problem to be solved.
-            aux_operators: Additional auxiliary operators to evaluate.
-
-        Returns:
-            Qubit operator.
-            Additional auxiliary operators.
-        """
-
-    @abstractmethod
     def supports_aux_operators(self) -> bool:
-        """Returns whether the eigensolver supports auxiliary operators."""
+        """Returns whether the eigensolver generated by this factory supports auxiliary operators."""
         raise NotImplementedError
 
     @property
-    def qubit_converter(self):
-        """Returns the qubit converter."""
-        return self._qubit_converter
-
-    @property
     @abstractmethod
-    def solver(self):
-        """Returns the solver."""
+    def minimum_eigensolver(self) -> MinimumEigensolver:
+        """Returns the solver instance."""
+        raise NotImplementedError
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """
 Minimum Eigensolver Factories
 (:mod:`qiskit_nature.second_q.algorithms.ground_state_solvers.minimum_eigensolver_factories`)
 =============================================================================================
 
-Factories that create a minimum eigensolver based on a qubit transformation.
+DEPRECATED Factories that create a minimum eigensolver based on a qubit transformation.
 
 .. currentmodule:: qiskit_nature.second_q.algorithms.ground_state_solvers.minimum_eigensolver_factories
 
 """
 
 from .minimum_eigensolver_factory import MinimumEigensolverFactory
 from .numpy_minimum_eigensolver_factory import NumPyMinimumEigensolverFactory
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_ucc_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uvcc_factory.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -18,137 +18,158 @@
 import numpy as np
 
 from qiskit.algorithms.minimum_eigensolvers import MinimumEigensolver, VQE
 from qiskit.algorithms.optimizers import Minimizer, Optimizer
 from qiskit.circuit import QuantumCircuit
 from qiskit.primitives import BaseEstimator
 
-from qiskit_nature.second_q.circuit.library import HartreeFock, UCC
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.deprecation import DeprecatedType, warn_deprecated
+from qiskit_nature.second_q.circuit.library import UVCC, VSCF
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from qiskit_nature.second_q.problems import (
-    ElectronicStructureProblem,
+    VibrationalStructureProblem,
 )
+from qiskit_nature.deprecation import deprecate_arguments
 
-from ...initial_points import InitialPoint, HFInitialPoint
 from .minimum_eigensolver_factory import MinimumEigensolverFactory
+from ...initial_points import InitialPoint, VSCFInitialPoint
 
 logger = logging.getLogger(__name__)
 
 
-class VQEUCCFactory(MinimumEigensolverFactory):
-    """Factory to construct a :class:`~qiskit.algorithms.minimum_eigensolvers.VQE` minimum
-    eigensolver with :class:`~.UCC` ansatz wavefunction.
+class VQEUVCCFactory(MinimumEigensolverFactory):
+    """DEPRECATED Factory to construct a :class:`~qiskit.algorithms.minimum_eigensolvers.VQE`
+    minimum eigensolver with :class:`~.UVCC` ansatz wavefunction.
+
+    .. warning::
+
+        This class is deprecated! Please see :ref:`this guide <how-to-vqe-uvcc>` for how to replace
+        your usage of it!
     """
 
     def __init__(
         self,
         estimator: BaseEstimator,
-        ansatz: UCC,
+        ansatz: UVCC,
         optimizer: Optimizer | Minimizer,
         *,
         initial_point: np.ndarray | InitialPoint | None = None,
         initial_state: QuantumCircuit | None = None,
         **kwargs,
     ) -> None:
         """
         Args:
             estimator: The ``BaseEstimator`` class to use for the internal
                 :class:`~qiskit.algorithms.minimum_eigensolvers.VQE`.
-            ansatz: The ``UCC`` ansatz. Its attributes ``qubit_converter``, ``num_particles``,
-                ``num_spatial_orbitals``, and ``initial_point`` will be completed at runtime based on
-                the problem being solved.
+            ansatz: The ``UVCC`` ansatz. Its attributes ``qubit_mapper``, ``num_modals``, and
+                ``initial_point`` will be completed at runtime based on the problem being solved.
             optimizer: The ``Optimizer`` or ``Minimizer`` to use for the internal
                 :class:`~qiskit.algorithms.minimum_eigensolvers.VQE`.
             initial_point: An optional initial point (i.e., initial parameter values for the VQE
                 optimizer). If ``None`` then VQE will use an all-zero initial point of the
                 appropriate length computed using
-                :class:`~qiskit_nature.second_q.algorithms.initial_points.\
-                hf_initial_point.HFInitialPoint`.
-                This then defaults to the Hartree-Fock (HF) state when the HF circuit is prepended
+                :class:`~initial_points.vscf_initial_point.VSCFInitialPoint`.
+                This then defaults to the VSCF state when the VSCF circuit is prepended
                 to the ansatz circuit. If another ``InitialPoint`` instance, this is used to
                 compute an initial point for the VQE ansatz parameters. If a user-provided NumPy
                 array, this is used directly.
             initial_state: Allows specification of a custom ``QuantumCircuit`` to be used as the
                 initial state of the ansatz. If this is never set by the user, the factory will
-                default to the :class:`~.HartreeFock` state.
+                default to the :class:`~.VSCF` state.
             kwargs: Remaining keyword arguments are passed to the
                 :class:`~qiskit.algorithms.minimum_eigensolvers.VQE`.
         """
+        warn_deprecated(
+            "0.6.0",
+            DeprecatedType.CLASS,
+            "VQEUVCCFactory",
+            additional_msg=(
+                ". This class is deprecated without replacement. Instead, refer to this how-to "
+                "guide which explains the steps you need to take to replace the use of this class: "
+                "https://qiskit.org/documentation/nature/howtos/vqe_uvcc.html"
+            ),
+        )
         self._initial_state = initial_state
-        self._initial_point = initial_point if initial_point is not None else HFInitialPoint()
+        self._initial_point = initial_point if initial_point is not None else VSCFInitialPoint()
 
         self._vqe = VQE(estimator, ansatz, optimizer, **kwargs)
 
     @property
-    def ansatz(self) -> UCC:
+    def ansatz(self) -> UVCC:
         """Gets the user provided ansatz of future VQEs produced by the factory."""
         return self.minimum_eigensolver.ansatz
 
     @ansatz.setter
-    def ansatz(self, ansatz: UCC) -> None:
+    def ansatz(self, ansatz: UVCC) -> None:
         """Sets the ansatz of future VQEs produced by the factory."""
         self.minimum_eigensolver.ansatz = ansatz
 
     @property
-    def initial_point(self) -> np.ndarray | InitialPoint | None:
-        """Gets the initial point of future VQEs produced by the factory."""
-        return self._initial_point
-
-    @initial_point.setter
-    def initial_point(self, initial_point: np.ndarray | InitialPoint | None) -> None:
-        """Sets the initial point of future VQEs produced by the factory."""
-        self._initial_point = initial_point
-
-    @property
     def initial_state(self) -> QuantumCircuit | None:
-        """
-        Getter of the initial state.
-        If value is ``None`` it will default to using the :class:`~.HartreeFock`.
-        """
+        """Getter of the initial state."""
         return self._initial_state
 
     @initial_state.setter
     def initial_state(self, initial_state: QuantumCircuit | None) -> None:
         """
         Setter of the initial state.
-        If ``None`` is passed, this factory will default to using the :class:`~.HartreeFock`.
+        If ``None`` is passed, this factory will default to using the :class:`~.VSCF`.
         """
         self._initial_state = initial_state
 
-    def get_solver(  # type: ignore[override]
+    @property
+    def initial_point(self) -> np.ndarray | InitialPoint | None:
+        """
+        Gets the initial point of future VQEs produced by the factory.
+        """
+        return self._initial_point
+
+    @initial_point.setter
+    def initial_point(self, initial_point: np.ndarray | InitialPoint | None) -> None:
+        """Sets the initial point of future VQEs produced by the factory."""
+        self._initial_point = initial_point
+
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
+    def get_solver(
         self,
-        problem: ElectronicStructureProblem,
-        qubit_converter: QubitConverter,
+        problem: VibrationalStructureProblem,
+        qubit_mapper: QubitConverter | QubitMapper,
+        *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
     ) -> MinimumEigensolver:
-        """Returns a VQE with a UCC wavefunction ansatz, based on ``qubit_converter``.
+        # pylint: disable=unused-argument
+        """Returns a VQE with a :class:`~.UVCC` wavefunction ansatz, based on ``qubit_mapper``.
 
         Args:
             problem: A class encoding a problem to be solved.
-            qubit_converter: A class that converts second quantized operator to qubit operator
-                according to a mapper it is initialized with.
+            qubit_mapper: A class that converts second quantized operator to qubit operator.
+                Providing a ``QubitConverter`` instance here is deprecated.
+            qubit_converter: DEPRECATED A class that converts second quantized operator to qubit
+                operator according to a mapper it is initialized with.
 
         Returns:
             A VQE suitable to compute the ground state of the molecule.
         """
-        driver_result = problem
-        num_spatial_orbitals = problem.num_spatial_orbitals
-        num_particles = problem.num_alpha, problem.num_beta
-
         initial_state = self.initial_state
         if initial_state is None:
-            initial_state = HartreeFock(num_spatial_orbitals, num_particles, qubit_converter)
+            initial_state = VSCF(problem.num_modals)
 
-        self.ansatz.qubit_converter = qubit_converter
-        self.ansatz.num_particles = num_particles
-        self.ansatz.num_spatial_orbitals = num_spatial_orbitals
+        self.ansatz.qubit_mapper = qubit_mapper
+        self.ansatz.num_modals = problem.num_modals
         self.ansatz.initial_state = initial_state
 
         if isinstance(self.initial_point, InitialPoint):
             self.initial_point.ansatz = self.ansatz
-            self.initial_point.problem = driver_result
             initial_point = self.initial_point.to_numpy_array()
         else:
             initial_point = self.initial_point
 
         self.minimum_eigensolver.initial_point = initial_point
         return self.minimum_eigensolver
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uvcc_factory.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_ucc_factory.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,134 +12,172 @@
 
 """The minimum eigensolver factory for ground state calculation algorithms."""
 
 from __future__ import annotations
 
 import logging
 import numpy as np
-
 from qiskit.algorithms.minimum_eigensolvers import MinimumEigensolver, VQE
 from qiskit.algorithms.optimizers import Minimizer, Optimizer
 from qiskit.circuit import QuantumCircuit
 from qiskit.primitives import BaseEstimator
 
-from qiskit_nature.second_q.circuit.library import UVCC, VSCF
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.deprecation import DeprecatedType, warn_deprecated
+from qiskit_nature.second_q.circuit.library import HartreeFock, UCC
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from qiskit_nature.second_q.problems import (
-    VibrationalStructureProblem,
+    ElectronicStructureProblem,
 )
+from qiskit_nature.deprecation import deprecate_arguments
 
+from ...initial_points import InitialPoint, HFInitialPoint
 from .minimum_eigensolver_factory import MinimumEigensolverFactory
-from ...initial_points import InitialPoint, VSCFInitialPoint
 
 logger = logging.getLogger(__name__)
 
 
-class VQEUVCCFactory(MinimumEigensolverFactory):
-    """Factory to construct a :class:`~qiskit.algorithms.minimum_eigensolvers.VQE` minimum
-    eigensolver with :class:`~.UVCC` ansatz wavefunction.
+class VQEUCCFactory(MinimumEigensolverFactory):
+    """DEPRECATED Factory to construct a :class:`~qiskit.algorithms.minimum_eigensolvers.VQE`
+    minimum eigensolver with :class:`~.UCC` ansatz wavefunction.
+
+    .. warning::
+
+        This class is deprecated! Please see :ref:`this guide <how-to-vqe-ucc>` for how to replace
+        your usage of it!
     """
 
     def __init__(
         self,
         estimator: BaseEstimator,
-        ansatz: UVCC,
+        ansatz: UCC,
         optimizer: Optimizer | Minimizer,
         *,
         initial_point: np.ndarray | InitialPoint | None = None,
         initial_state: QuantumCircuit | None = None,
         **kwargs,
     ) -> None:
         """
         Args:
             estimator: The ``BaseEstimator`` class to use for the internal
                 :class:`~qiskit.algorithms.minimum_eigensolvers.VQE`.
-            ansatz: The ``UVCC`` ansatz. Its attributes ``qubit_converter``, ``num_modals``, and
-                ``initial_point`` will be completed at runtime based on the problem being solved.
+            ansatz: The ``UCC`` ansatz. Its attributes ``qubit_mapper``, ``num_particles``,
+                ``num_spatial_orbitals``, and ``initial_point`` will be completed at runtime based on
+                the problem being solved.
             optimizer: The ``Optimizer`` or ``Minimizer`` to use for the internal
                 :class:`~qiskit.algorithms.minimum_eigensolvers.VQE`.
             initial_point: An optional initial point (i.e., initial parameter values for the VQE
                 optimizer). If ``None`` then VQE will use an all-zero initial point of the
                 appropriate length computed using
-                :class:`~initial_points.vscf_initial_point.VSCFInitialPoint`.
-                This then defaults to the VSCF state when the VSCF circuit is prepended
+                :class:`~qiskit_nature.second_q.algorithms.initial_points.\
+                hf_initial_point.HFInitialPoint`.
+                This then defaults to the Hartree-Fock (HF) state when the HF circuit is prepended
                 to the ansatz circuit. If another ``InitialPoint`` instance, this is used to
                 compute an initial point for the VQE ansatz parameters. If a user-provided NumPy
                 array, this is used directly.
             initial_state: Allows specification of a custom ``QuantumCircuit`` to be used as the
                 initial state of the ansatz. If this is never set by the user, the factory will
-                default to the :class:`~.VSCF` state.
+                default to the :class:`~.HartreeFock` state.
             kwargs: Remaining keyword arguments are passed to the
                 :class:`~qiskit.algorithms.minimum_eigensolvers.VQE`.
         """
+        warn_deprecated(
+            "0.6.0",
+            DeprecatedType.CLASS,
+            "VQEUCCFactory",
+            additional_msg=(
+                ". This class is deprecated without replacement. Instead, refer to this how-to "
+                "guide which explains the steps you need to take to replace the use of this class: "
+                "https://qiskit.org/documentation/nature/howtos/vqe_ucc.html"
+            ),
+        )
         self._initial_state = initial_state
-        self._initial_point = initial_point if initial_point is not None else VSCFInitialPoint()
+        self._initial_point = initial_point if initial_point is not None else HFInitialPoint()
 
         self._vqe = VQE(estimator, ansatz, optimizer, **kwargs)
 
     @property
-    def ansatz(self) -> UVCC:
+    def ansatz(self) -> UCC:
         """Gets the user provided ansatz of future VQEs produced by the factory."""
         return self.minimum_eigensolver.ansatz
 
     @ansatz.setter
-    def ansatz(self, ansatz: UVCC) -> None:
+    def ansatz(self, ansatz: UCC) -> None:
         """Sets the ansatz of future VQEs produced by the factory."""
         self.minimum_eigensolver.ansatz = ansatz
 
     @property
+    def initial_point(self) -> np.ndarray | InitialPoint | None:
+        """Gets the initial point of future VQEs produced by the factory."""
+        return self._initial_point
+
+    @initial_point.setter
+    def initial_point(self, initial_point: np.ndarray | InitialPoint | None) -> None:
+        """Sets the initial point of future VQEs produced by the factory."""
+        self._initial_point = initial_point
+
+    @property
     def initial_state(self) -> QuantumCircuit | None:
-        """Getter of the initial state."""
+        """
+        Getter of the initial state.
+        If value is ``None`` it will default to using the :class:`~.HartreeFock`.
+        """
         return self._initial_state
 
     @initial_state.setter
     def initial_state(self, initial_state: QuantumCircuit | None) -> None:
         """
         Setter of the initial state.
-        If ``None`` is passed, this factory will default to using the :class:`~.VSCF`.
+        If ``None`` is passed, this factory will default to using the :class:`~.HartreeFock`.
         """
         self._initial_state = initial_state
 
-    @property
-    def initial_point(self) -> np.ndarray | InitialPoint | None:
-        """
-        Gets the initial point of future VQEs produced by the factory.
-        """
-        return self._initial_point
-
-    @initial_point.setter
-    def initial_point(self, initial_point: np.ndarray | InitialPoint | None) -> None:
-        """Sets the initial point of future VQEs produced by the factory."""
-        self._initial_point = initial_point
-
-    def get_solver(  # type: ignore[override]
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
+    def get_solver(
         self,
-        problem: VibrationalStructureProblem,
-        qubit_converter: QubitConverter,
+        problem: ElectronicStructureProblem,
+        qubit_mapper: QubitConverter | QubitMapper,
+        *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
     ) -> MinimumEigensolver:
-        """Returns a VQE with a :class:`~.UVCC` wavefunction ansatz, based on ``qubit_converter``.
+        # pylint: disable=unused-argument
+        """Returns a VQE with a UCC wavefunction ansatz, based on ``qubit_mapper``.
 
         Args:
             problem: A class encoding a problem to be solved.
-            qubit_converter: A class that converts second quantized operator to qubit operator
-                             according to a mapper it is initialized with.
+            qubit_mapper: A class that converts second quantized operator to qubit operator.
+                Providing a ``QubitConverter`` instance here is deprecated.
+            qubit_converter: DEPRECATED A class that converts second quantized operator to qubit
+                operator according to a mapper it is initialized with.
 
         Returns:
             A VQE suitable to compute the ground state of the molecule.
         """
+        driver_result = problem
+        num_spatial_orbitals = problem.num_spatial_orbitals
+        num_particles = problem.num_alpha, problem.num_beta
+
         initial_state = self.initial_state
         if initial_state is None:
-            initial_state = VSCF(problem.num_modals)
+            initial_state = HartreeFock(num_spatial_orbitals, num_particles, qubit_mapper)
 
-        self.ansatz.qubit_converter = qubit_converter
-        self.ansatz.num_modals = problem.num_modals
+        self.ansatz.qubit_mapper = qubit_mapper
+        self.ansatz.num_particles = num_particles
+        self.ansatz.num_spatial_orbitals = num_spatial_orbitals
         self.ansatz.initial_state = initial_state
 
         if isinstance(self.initial_point, InitialPoint):
             self.initial_point.ansatz = self.ansatz
+            self.initial_point.problem = driver_result
             initial_point = self.initial_point.to_numpy_array()
         else:
             initial_point = self.initial_point
 
         self.minimum_eigensolver.initial_point = initial_point
         return self.minimum_eigensolver
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/hf_initial_point.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/hf_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/initial_point.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/initial_point.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -26,15 +26,15 @@
     r"""The initial point interface.
 
     The interface for utility classes that provide an initial point for the ``VQE`` parameters for a
     particular ``EvolvedOperatorAnsatz``.
     """
 
     @abstractmethod
-    def __init__(self):
+    def __init__(self) -> None:
         self._ansatz: EvolvedOperatorAnsatz | None = None
         self._problem: BaseProblem | None = None
 
     @property
     @abstractmethod
     def ansatz(self) -> EvolvedOperatorAnsatz | None:
         """The evolved operator ansatz.
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/mp2_initial_point.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/mp2_initial_point.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2019, 2022.
+# (C) Copyright IBM 2019, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -15,60 +15,78 @@
 from __future__ import annotations
 
 import numpy as np
 
 from qiskit_nature.exceptions import QiskitNatureError
 from qiskit_nature.second_q.circuit.library import UCC
 from qiskit_nature.second_q.operators import ElectronicIntegrals
-from qiskit_nature.second_q.operators.tensor_ordering import IndexType, to_chemist_ordering
+from qiskit_nature.second_q.operators.tensor import ARRAY_TYPE, Tensor
+from qiskit_nature.second_q.operators.symmetric_two_body import SymmetricTwoBodyIntegrals, unfold
 from qiskit_nature.second_q.problems import BaseProblem, ElectronicStructureProblem
-
+from qiskit_nature.utils import get_einsum
 
 from .initial_point import InitialPoint
 
 
 def _compute_mp2(
-    num_occ: int, integral_matrix: np.ndarray, orbital_energies: np.ndarray
+    num_occ: int, integral_matrix: ARRAY_TYPE | Tensor, orbital_energies: np.ndarray
 ) -> tuple[np.ndarray, float]:
     """Compute the T2 amplitudes and MP2 energy correction.
 
     Args:
         num_occ: The number of occupied molecular orbitals.
-        integral_matrix: The two-body molecular orbitals matrix.
+        integral_matrix: The two-body molecular orbitals tensor.
         orbital_energies: The orbital energies.
 
     Returns:
         A tuple consisting of the:
         - T amplitudes t2[i, j, a, b] (i, j in occupied, a, b in virtual).
         - The MP2 energy correction.
 
     """
+    if isinstance(integral_matrix, SymmetricTwoBodyIntegrals):
+        integral_matrix = unfold(integral_matrix)
+    elif not isinstance(integral_matrix, Tensor):
+        # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+        integral_matrix = Tensor(integral_matrix)
+
     # We use NumPy broadcasting to compute the matrix of occupied - virtual energy deltas with
     # shape (num_occ, num_vir), such that
     # energy_deltas[i, a] = orbital_energy[i] - orbital_energy[a].
-    # NOTE In the unrestricted-spin calculation, the orbital energies will be a 2D array, and this
+    # NOTE: In the unrestricted-spin calculation, the orbital energies will be a 2D array, and this
     # logic will need to be revisited.
     energy_deltas = orbital_energies[:num_occ, np.newaxis] - orbital_energies[num_occ:]
 
     # We now want to compute a 4D tensor of (occupied, occupied) - (virtual, virtual)
     # energy deltas with shape (num_occ, num_vir, num_occ, num_vir), such that
     # double_deltas[i, a, j, b] = orbital_energies[i] + orbital_energies[j]
     #                             - orbital_energies[a] - orbital_energies[b].
     # Again we can use NumPy broadcasting to speed this up.
     double_deltas = energy_deltas[:, :, np.newaxis, np.newaxis] + energy_deltas
 
+    # Now we transpose this matrix into (num_occ, num_occ, num_vir, num_vir) which is the expected
+    # ordering of T2 amplitudes following the convention set out by PySCF
+    double_deltas = double_deltas.transpose(0, 2, 1, 3)
+
+    # We must swap the last two axes in order to match the ordering of double_deltas as
+    # explained above. We use the _reverse_label_template routine here to handle non-default label
+    # templates in the integral_matrix Tensor, too.
+    integral_matrix = integral_matrix.transpose(
+        integral_matrix._reverse_label_template((0, 1, 3, 2))
+    )
     # Create integral matrix that uses occupied and virtual indices rather than MO indices.
-    integral_matrix_ovov = integral_matrix[:num_occ, num_occ:, :num_occ, num_occ:]
+    integral_matrix_oovv = integral_matrix[:num_occ, :num_occ, num_occ:, num_occ:]
 
     # Compute T2 amplitudes and transpose to num_occ, num_occ, num_vir, num_vir.
-    t2_amplitudes = (integral_matrix_ovov / double_deltas).transpose(0, 2, 1, 3)
+    t2_amplitudes = integral_matrix_oovv / double_deltas
 
     # Compute MP2 energy correction.
-    energy_correction = np.einsum("ijab,iajb", t2_amplitudes, integral_matrix_ovov) * 2
-    energy_correction -= np.einsum("ijab,ibja", t2_amplitudes, integral_matrix_ovov)
+    einsum_func, _ = get_einsum()
+    energy_correction = einsum_func("ijab,ijab", t2_amplitudes, integral_matrix_oovv) * 2
+    energy_correction -= einsum_func("ijab,ijba", t2_amplitudes, integral_matrix_oovv)
 
     return t2_amplitudes, energy_correction
 
 
 class MP2InitialPoint(InitialPoint):
     """Compute the second-order Møller-Plesset perturbation theory (MP2) initial point.
 
@@ -174,17 +192,15 @@
         num_occ = problem.num_alpha
         if num_occ is None:
             raise QiskitNatureError(
                 "The `num_particles` attribute of the `ElectronicStructureProblem` is required by "
                 "the MP2InitialPoint."
             )
 
-        integral_matrix = to_chemist_ordering(
-            two_body_mo_integral.alpha.get("++--"), index_order=IndexType.PHYSICIST
-        )
+        integral_matrix = two_body_mo_integral.alpha.get("++--")
 
         reference_energy = problem.reference_energy if not None else 0.0
 
         self._invalidate()
 
         t2_amplitudes, energy_correction = _compute_mp2(num_occ, integral_matrix, orbital_energies)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/algorithms/initial_points/vscf_initial_point.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/initial_points/vscf_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/chc.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/chc.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/puccd.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/puccd.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -15,15 +15,16 @@
 
 from __future__ import annotations
 
 import logging
 
 from qiskit.circuit import QuantumCircuit
 from qiskit_nature import QiskitNatureError
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.deprecation import deprecate_arguments
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 
 from .ucc import UCC
 from .utils.fermionic_excitation_generator import (
     generate_fermionic_excitations,
     get_alpha_excitations,
 )
 
@@ -43,50 +44,65 @@
     This is a convenience subclass of the UCC ansatz. For more information refer to :class:`UCC`.
 
     References:
         [1] `arXiv:1911.10864 <https://arxiv.org/abs/1911.10864>`_
 
     """
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         num_spatial_orbitals: int | None = None,
         num_particles: tuple[int, int] | None = None,
-        qubit_converter: QubitConverter | None = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
         reps: int = 1,
         initial_state: QuantumCircuit | None = None,
         include_singles: tuple[bool, bool] = (False, False),
         generalized: bool = False,
-    ):
+        qubit_converter: QubitConverter | QubitMapper | None = None,
+    ) -> None:
+        # pylint: disable=unused-argument
         """
 
         Args:
             num_spatial_orbitals: The number of spatial orbitals.
             num_particles: The tuple of the number of alpha- and beta-spin particles.
-            qubit_converter: The :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance
-                which takes care of mapping to a qubit operator.
+            qubit_mapper: The :class:`~qiskit_nature.second_q.mappers.QubitMapper` or
+                :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance (use of the latter
+                is deprecated) which takes care of mapping to a qubit operator.
             reps: The number of times to repeat the evolved operators.
             initial_state: A ``QuantumCircuit`` object to prepend to the circuit.
             include_singles: enables the inclusion of single excitations per spin species.
             generalized: Boolean flag whether or not to use generalized excitations, which ignore
                 the occupation of the spin orbitals. As such, the set of generalized excitations is
                 only determined from the number of spin orbitals and independent from the number of
                 particles.
+            qubit_converter: DEPRECATED The :class:`~qiskit_nature.second_q.mappers.QubitConverter`
+                or :class:`~qiskit_nature.second_q.mappers.QubitMapper` instance which takes care of
+                mapping to a qubit operator.
 
         Raises:
             QiskitNatureError: if the number of alpha and beta electrons is not equal.
+
         """
         self._validate_num_particles(num_particles)
         self._include_singles = include_singles
         super().__init__(
             num_spatial_orbitals=num_spatial_orbitals,
             num_particles=num_particles,
             excitations=self.generate_excitations,
-            qubit_converter=qubit_converter,
+            qubit_mapper=qubit_mapper,
             alpha_spin=True,
             beta_spin=True,
             max_spin_excitation=None,
             generalized=generalized,
             reps=reps,
             initial_state=initial_state,
         )
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/succd.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/succd.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -18,16 +18,18 @@
 from typing import Sequence, cast
 from collections import defaultdict
 
 import itertools
 import logging
 
 from qiskit.circuit import QuantumCircuit
+from qiskit.opflow import PauliSumOp
 from qiskit_nature import QiskitNatureError
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.deprecation import deprecate_arguments
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 
 from qiskit_nature.second_q.operators import FermionicOp
 
 from .ucc import UCC
 from .utils.fermionic_excitation_generator import (
     generate_fermionic_excitations,
     get_alpha_excitations,
@@ -49,58 +51,72 @@
     This is a convenience subclass of the UCC ansatz. For more information refer to :class:`UCC`.
 
     References:
         [1] `arXiv:1911.10864 <https://arxiv.org/abs/1911.10864>`_
 
     """
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         num_spatial_orbitals: int | None = None,
         num_particles: tuple[int, int] | None = None,
-        qubit_converter: QubitConverter | None = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
         reps: int = 1,
         initial_state: QuantumCircuit | None = None,
         include_singles: tuple[bool, bool] = (False, False),
         generalized: bool = False,
         mirror: bool = False,
-    ):
+        qubit_converter: QubitConverter | QubitMapper | None = None,
+    ) -> None:
+        # pylint: disable=unused-argument
         """
         Args:
             num_spatial_orbitals: The number of spatial orbitals.
             num_particles: The tuple of the number of alpha- and beta-spin particles.
-            qubit_converter: The QubitConverter instance which takes care of mapping to a qubit
-                operator.
+            qubit_mapper: The :class:`~qiskit_nature.second_q.mappers.QubitMapper` or
+                :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance (use of the latter
+                is deprecated) which takes care of mapping to a qubit operator.
             reps: The number of times to repeat the evolved operators.
             initial_state: A ``QuantumCircuit`` object to prepend to the circuit.
             include_singles: enables the inclusion of single excitations per spin species.
             generalized: Boolean flag whether or not to use generalized excitations, which ignore
                 the occupation of the spin orbitals. As such, the set of generalized excitations is
                 only determined from the number of spin orbitals and independent from the number of
                 particles.
             mirror: Boolean flag whether or not to include the symmetrically mirrored double
                 excitations, while keeping the original number of circuit
                 parameters. This results in mirrored excitations having identical parameter values.
                 Enabling this parameter will result in the SUCCD ansatz referred to as
                 "q-UCCSD0-full" in reference [1].
+            qubit_converter: DEPRECATED The :class:`~qiskit_nature.second_q.mappers.QubitConverter`
+                or :class:`~qiskit_nature.second_q.mappers.QubitMapper` instance which takes care of
+                mapping to a qubit operator.
         Raises:
             QiskitNatureError: if the number of alpha and beta electrons is not equal.
         """
         self._validate_num_particles(num_particles)
         self._include_singles = include_singles
         self._mirror = mirror
         self._excitations_dict: dict[
             str, list[tuple[tuple[int, ...], tuple[int, ...]]]
         ] | None = None
         super().__init__(
             num_spatial_orbitals=num_spatial_orbitals,
             num_particles=num_particles,
             excitations=self.generate_excitations,
-            qubit_converter=qubit_converter,
+            qubit_mapper=qubit_mapper,
             alpha_spin=True,
             beta_spin=True,
             max_spin_excitation=None,
             generalized=generalized,
             reps=reps,
             initial_state=initial_state,
         )
@@ -129,14 +145,18 @@
         self._invalidate()
         self._mirror = mirror
 
     def _filter_operators(self, operators):
         valid_operators, valid_excitations = [], []
         for op, ex in zip(operators, self._excitations_dict.values()):
             if op is not None:
+                # TODO: remove wrapping into PauliSumOp after the EvolvedOperatorAnsatz supports
+                # SparsePauliOp instances, too: https://github.com/Qiskit/qiskit-terra/pull/9537
+                if not isinstance(op, PauliSumOp):
+                    op = PauliSumOp(op)
                 valid_operators.append(op)
                 valid_excitations.extend(ex)
 
         self._excitation_list = valid_excitations
         self.operators = valid_operators
 
     def generate_excitations(
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/ucc.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/ucc.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -17,18 +17,19 @@
 
 import logging
 from functools import partial
 from typing import Callable, Sequence
 
 from qiskit.circuit import QuantumCircuit
 from qiskit.circuit.library import EvolvedOperatorAnsatz
-from qiskit.opflow import PauliTrotterEvolution
+from qiskit.opflow import PauliSumOp
 
 from qiskit_nature import QiskitNatureError
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.deprecation import deprecate_arguments, deprecate_property, warn_deprecated_type
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper, TaperedQubitMapper
 from qiskit_nature.second_q.operators import FermionicOp, SparseLabelOp
 
 from .utils.fermionic_excitation_generator import generate_fermionic_excitations
 
 logger = logging.getLogger(__name__)
 
 
@@ -40,22 +41,20 @@
     operators which are generated by
     :meth:`~qiskit_nature.second_q.circuit.library.ansatzes.utils.generate_fermionic_excitations`.
 
     This method constructs the requested excitations based on a
     :class:`~qiskit_nature.second_q.circuit.library.HartreeFock` reference state by default. When
     setting up a ``VQE`` algorithm using this ansatz and initial state, it is likely you will also
     want to use a :class:`~qiskit_nature.second_q.algorithms.initial_points.HFInitialPoint` that has
-    been configured using the corresponding ansatz parameters. When using a
-    :class:`~qiskit_nature.second_q.algorithms.VQEUCCFactory` this is set by default. When directly
-    using ``VQE`` you can set it manually. For example:
+    been configured using the corresponding ansatz parameters. This can be done as follows:
 
     .. code-block:: python
 
-        qubit_converter = QubitConverter(JordanWignerMapper())
-        ucc = UCC(4, (2, 2), 'sd', qubit_converter)
+        qubit_mapper = JordanWignerMapper()
+        ucc = UCC(4, (2, 2), 'sd', qubit_mapper)
         hf_initial_point = HFInitialPoint()
         hf_initial_point.ansatz = ucc
         initial_point = hf_initial_point.to_numpy_array()
         vqe = VQE(Estimator(), ucc, SLSQP(), initial_point=initial_point)
 
     You can also use a custom excitation generator method by passing a callable to ``excitations``.
 
@@ -101,15 +100,15 @@
             return my_excitation_list
 
         my_custom_ucc = UCC(excitations=custom_excitation_list)
 
     Keep in mind, that in all of the examples above we have not set any of the following keyword
     arguments, which must be specified before the ansatz becomes usable:
 
-    - ``qubit_converter``
+    - ``qubit_mapper``
     - ``num_particles``
     - ``num_spatial_orbitals``
 
     If you are using this ansatz with a Qiskit Nature algorithm, these arguments will be set for
     you, depending on the rest of the stack.
 
 
@@ -121,36 +120,46 @@
     _EXCITATION_TYPE = {
         "s": 1,
         "d": 2,
         "t": 3,
         "q": 4,
     }
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         num_spatial_orbitals: int | None = None,
         num_particles: tuple[int, int] | None = None,
         excitations: str
         | int
         | list[int]
         | Callable[
             [int, tuple[int, int]],
             list[tuple[tuple[int, ...], tuple[int, ...]]],
         ]
         | None = None,
-        qubit_converter: QubitConverter | None = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
         alpha_spin: bool = True,
         beta_spin: bool = True,
         max_spin_excitation: int | None = None,
         generalized: bool = False,
         preserve_spin: bool = True,
         reps: int = 1,
         initial_state: QuantumCircuit | None = None,
-    ):
+        qubit_converter: QubitConverter | QubitMapper | None = None,
+    ) -> None:
+        # pylint: disable=unused-argument
         """
 
         Args:
             num_spatial_orbitals: The number of spatial orbitals.
             num_particles: The tuple of the number of alpha- and beta-spin particles.
             excitations: This can be any of the following types:
 
@@ -163,16 +172,17 @@
                 :`Callable`: A function which is used to generate the excitations.
                     The callable must take the *keyword* arguments ``num_spatial_orbitals`` and
                     ``num_particles`` (with identical types to those explained above) and must return
                     a ``list[tuple[tuple[int, ...], tuple[int, ...]]]``. For more information on how
                     to write such a callable refer to the default method
                     :meth:`~qiskit_nature.second_q.circuit.library.ansatzes.utils.\
                     generate_fermionic_excitations`.
-            qubit_converter: The :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance
-                which takes care of mapping to a qubit operator.
+            qubit_mapper: The :class:`~qiskit_nature.second_q.mappers.QubitMapper` or
+                :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance (use of the latter
+                is deprecated) which takes care of mapping to a qubit operator.
             alpha_spin: Boolean flag whether to include alpha-spin excitations.
             beta_spin: Boolean flag whether to include beta-spin excitations.
             max_spin_excitation: The largest number of excitations within a spin. E.g. you can set
                 this to 1 and ``num_excitations`` to 2 in order to obtain only mixed-spin double
                 excitations (alpha,beta) but no pure-spin double excitations (alpha,alpha or
                 beta,beta).
             generalized: Boolean flag whether or not to use generalized excitations, which ignore
@@ -186,26 +196,29 @@
                 generation method (i.e. not providing a ``Callable`` to ``excitations``), these will
                 always be constructed with respect to a
                 :class:`~qiskit_nature.second_q.circuit.library.HartreeFock` reference state.
                 When setting up a ``VQE`` algorithm using this ansatz and initial state, it is
                 likely you will also want to use a
                 :class:`~qiskit_nature.second_q.algorithms.initial_points.HFInitialPoint` that has
                 been configured using the corresponding ansatz parameters.
+            qubit_converter: DEPRECATED The :class:`~qiskit_nature.second_q.mappers.QubitConverter`
+                or :class:`~qiskit_nature.second_q.mappers.QubitMapper` instance which takes care of
+                mapping to a qubit operator.
         """
-        self._qubit_converter = qubit_converter
+        self._qubit_mapper = qubit_mapper
         self._num_particles = num_particles
         self._num_spatial_orbitals = num_spatial_orbitals
         self._excitations = excitations
         self._alpha_spin = alpha_spin
         self._beta_spin = beta_spin
         self._max_spin_excitation = max_spin_excitation
         self._generalized = generalized
         self._preserve_spin = preserve_spin
 
-        super().__init__(reps=reps, evolution=PauliTrotterEvolution(), initial_state=initial_state)
+        super().__init__(reps=reps, initial_state=initial_state)
 
         # To give read access to the actual excitation list that UCC is using.
         self._excitation_list: list[tuple[tuple[int, ...], tuple[int, ...]]] | None = None
 
         # We cache these, because the generation may be quite expensive (depending on the generator)
         # and the user may want quick access to inspect these. Also, it speeds up testing for the
         # same reason!
@@ -215,24 +228,42 @@
         # number of qubits, which it gets from the operators. Getting the
         # operators here will build them if configuration already allows.
         # This will allow the circuit to be fully built/valid when it's
         # possible at this stage.
         _ = self.operators
 
     @property
-    def qubit_converter(self) -> QubitConverter:
-        """The qubit operator converter."""
-        return self._qubit_converter
+    @deprecate_property("0.6.0", new_name="qubit_mapper")
+    def qubit_converter(self) -> QubitConverter | QubitMapper | None:
+        """DEPRECATED The qubit operator converter."""
+        return self._qubit_mapper
 
     @qubit_converter.setter
-    def qubit_converter(self, conv: QubitConverter) -> None:
+    def qubit_converter(self, conv: QubitConverter | QubitMapper | None) -> None:
         """Sets the qubit operator converter."""
+        self.qubit_mapper = conv
+
+    @property
+    def qubit_mapper(self) -> QubitConverter | QubitMapper | None:
+        """The qubit operator mapper."""
+        return self._qubit_mapper
+
+    @qubit_mapper.setter
+    def qubit_mapper(self, mapper: QubitConverter | QubitMapper | None) -> None:
+        """Sets the qubit operator mapper."""
+        if isinstance(mapper, QubitConverter):
+            warn_deprecated_type(
+                "0.6.0",
+                argument_name="mapper",
+                old_type="QubitConverter",
+                new_type="QubitMapper",
+            )
         self._operators = None
         self._invalidate()
-        self._qubit_converter = conv
+        self._qubit_mapper = mapper
 
     @property
     def num_spatial_orbitals(self) -> int:
         """The number of spatial orbitals."""
         return self._num_spatial_orbitals
 
     @num_spatial_orbitals.setter
@@ -298,31 +329,42 @@
             if self._check_ucc_configuration(raise_on_failure=False):
                 # The qubit operators are cached by `EvolvedOperatorAnsatz` class. We only generate
                 # them from the `SparseLabelOp`s produced by the generators, if they're not
                 # already present. This behavior also enables the adaptive usage of the `UCC` class
                 # by algorithms such as `AdaptVQE`.
                 excitation_ops = self.excitation_ops()
 
-                logger.debug("Converting SparseLabelOps into PauliSumOps...")
+                logger.debug("Converting second-quantized into qubit operators...")
                 # Convert operators according to saved state in converter from the conversion of the
                 # main operator since these need to be compatible. If Z2 Symmetry tapering was done
                 # it may be that one or more excitation operators do not commute with the symmetry.
                 # The converted operators are maintained at the same index by the converter
                 # inserting ``None`` as the result if an operator did not commute. To ensure that
                 # the ``excitation_list`` is transformed identically to the operators, we retain
                 # ``None`` for non-commuting operators in order to manually remove them in unison.
-                operators = self.qubit_converter.convert_match(excitation_ops, suppress_none=False)
+                if isinstance(self.qubit_mapper, QubitConverter):
+                    operators = self.qubit_mapper.convert_match(excitation_ops, suppress_none=False)
+                elif isinstance(self.qubit_mapper, TaperedQubitMapper):
+                    operators = self.qubit_mapper.map_clifford(excitation_ops)
+                    operators = self.qubit_mapper.taper_clifford(operators, suppress_none=False)
+                else:
+                    operators = self.qubit_mapper.map(excitation_ops)
+
                 self._filter_operators(operators=operators)
 
         return super(UCC, self.__class__).operators.__get__(self)
 
     def _filter_operators(self, operators):
         valid_operators, valid_excitations = [], []
         for op, ex in zip(operators, self._excitation_list):
             if op is not None:
+                # TODO: remove wrapping into PauliSumOp after the EvolvedOperatorAnsatz supports
+                # SparsePauliOp instances, too: https://github.com/Qiskit/qiskit-terra/pull/9537
+                if not isinstance(op, PauliSumOp):
+                    op = PauliSumOp(op)
                 valid_operators.append(op)
                 valid_excitations.append(ex)
 
         self._excitation_list = valid_excitations
         self.operators = valid_operators
 
     def _invalidate(self):
@@ -376,17 +418,17 @@
             return False
 
         if self.excitations is None:
             if raise_on_failure:
                 raise ValueError("The excitations cannot be `None`.")
             return False
 
-        if self.qubit_converter is None:
+        if self.qubit_mapper is None:
             if raise_on_failure:
-                raise ValueError("The qubit_converter cannot be `None`.")
+                raise ValueError("The qubit_mapper cannot be `None`.")
             return False
 
         return True
 
     def excitation_ops(self) -> list[SparseLabelOp]:
         """Parses the excitations and generates the list of operators.
 
@@ -413,15 +455,15 @@
     def _get_excitation_list(self) -> list[tuple[tuple[int, ...], tuple[int, ...]]]:
         generators = self._get_excitation_generators()
 
         logger.debug("Generating excitation list...")
         excitations = []
         for gen in generators:
             excitations.extend(
-                gen(
+                gen(  # pylint: disable=not-callable
                     num_spatial_orbitals=self.num_spatial_orbitals,
                     num_particles=self.num_particles,
                 )
             )
 
         return excitations
 
@@ -521,13 +563,13 @@
             label = []
             for occ in exc[0]:
                 label.append(f"+_{occ}")
             for unocc in exc[1]:
                 label.append(f"-_{unocc}")
             op = FermionicOp({" ".join(label): 1}, num_spin_orbitals=num_spin_orbitals)
             op -= op.adjoint()
-            # we need to account for an additional imaginary phase in the exponent (see also
-            # `PauliTrotterEvolution.convert`)
+            # we need to account for an additional imaginary phase in the exponent accumulated from
+            # the first-order trotterization routine implemented in Qiskit Terra
             op *= 1j  # type: ignore
             operators.append(op)
 
         return operators
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/uccsd.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/uccsd.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,54 +12,70 @@
 """
 The UCCSD Ansatz.
 """
 
 from __future__ import annotations
 
 from qiskit.circuit import QuantumCircuit
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.deprecation import deprecate_arguments
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from .ucc import UCC
 
 
 class UCCSD(UCC):
     """The UCCSD Ansatz.
 
     This is a convenience subclass of the UCC ansatz. For more information refer to :class:`UCC`.
     """
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         num_spatial_orbitals: int | None = None,
         num_particles: tuple[int, int] | None = None,
-        qubit_converter: QubitConverter | None = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
         reps: int = 1,
         initial_state: QuantumCircuit | None = None,
         generalized: bool = False,
         preserve_spin: bool = True,
-    ):
+        qubit_converter: QubitConverter | QubitMapper | None = None,
+    ) -> None:
+        # pylint: disable=unused-argument
         """
         Args:
             num_spatial_orbitals: The number of spatial orbitals.
             num_particles: The tuple of the number of alpha- and beta-spin particles.
-            qubit_converter: The :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance
-                which takes care of mapping to a qubit operator.
+            qubit_mapper: The :class:`~qiskit_nature.second_q.mappers.QubitMapper` or
+                :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance (use of the latter
+                is deprecated) which takes care of mapping to a qubit operator.
             reps: The number of times to repeat the evolved operators.
             initial_state: A ``QuantumCircuit`` object to prepend to the circuit.
             generalized: Boolean flag whether or not to use generalized excitations, which ignore
                 the occupation of the spin orbitals. As such, the set of generalized excitations is
                 only determined from the number of spin orbitals and independent from the number of
                 particles.
             preserve_spin: Boolean flag whether or not to preserve the particle spins.
+            qubit_converter: DEPRECATED The :class:`~qiskit_nature.second_q.mappers.QubitConverter`
+                or :class:`~qiskit_nature.second_q.mappers.QubitMapper` instance which takes care of
+                mapping to a qubit operator.
+
         """
         super().__init__(
             num_spatial_orbitals=num_spatial_orbitals,
             num_particles=num_particles,
             excitations="sd",
-            qubit_converter=qubit_converter,
+            qubit_mapper=qubit_mapper,
             alpha_spin=True,
             beta_spin=True,
             max_spin_excitation=None,
             generalized=generalized,
             preserve_spin=preserve_spin,
             reps=reps,
             initial_state=initial_state,
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/utils/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/utils/fermionic_excitation_generator.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/utils/fermionic_excitation_generator.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -192,39 +192,47 @@
                             (i + num_spatial_orbitals, a + num_spatial_orbitals),
                         ],
                         single_excitations,
                     )
                 )
             )
         else:
-            # We can reuse our existing implementation for the scenario involving spin flips by
-            # generating the single excitations of an _interleaved_ spin orbital system.
-            # For this, we can reuse the alpha single excitation generator in a system of double the
-            # actual size.
+            # preserve_spin=False doesn't distinguish between alpha and beta spin species. This is
+            # effectively the same scenario as a single spin species for a system of double the
+            # actual size up to a reordering of the orbitals. We can reuse single spin species
+            # excitation generator if we reorder the orbitals afterwards. The first num_particles[0]
+            # orbitals in the output are fine, but the next num_particles[1] orbitals have to be
+            # reordered to start at index num_spatial_orbitals
+
             single_excitations = get_alpha_excitations(
                 num_spin_orbitals, sum(num_particles), generalized=False
             )
 
-            def interleaved2blocked(index: int, total: int) -> int:
-                if index % 2 == 0:
-                    return index // 2
-
-                return (index - 1 + total) // 2
+            def reorder_index(index: int) -> int:
+                # Alpha spins already at correct index
+                if index < num_particles[0]:
+                    return index
+                # Cyclically permute remaining (num_spin_orbitals - num_particles[0]) orbitals to
+                # get Beta spins at correct index
+                else:
+                    offset = num_particles[0]
+                    period = num_spin_orbitals - offset
+                    shift = num_spatial_orbitals - offset
+                    return (index - offset + shift) % period + offset
 
-            # we now split the generated single excitations into separate spin species
-            for (occ_interleaved, unocc_interleaved) in single_excitations:
+            for (occ_idx, unocc_idx) in single_excitations:
                 # we map from interleaved to blocked spin orbital indices
-                occ_blocked = interleaved2blocked(occ_interleaved, num_spin_orbitals)
-                unocc_blocked = interleaved2blocked(unocc_interleaved, num_spin_orbitals)
+                reordered_occ_idx = reorder_index(occ_idx)
+                reordered_unocc_idx = reorder_index(unocc_idx)
+                reordered_excitation = (reordered_occ_idx, reordered_unocc_idx)
 
-                if occ_interleaved % 2 == 0:
-                    # the originally occupied orbital was of alpha-spin character
-                    alpha_excitations.append((occ_blocked, unocc_blocked))
+                if reordered_occ_idx < num_spatial_orbitals:
+                    alpha_excitations.append(reordered_excitation)
                 else:
-                    beta_excitations.append((occ_blocked, unocc_blocked))
+                    beta_excitations.append(reordered_excitation)
 
             # NOTE: we sort the lists to ensure that non-spin flipped variants take higher precedence
             alpha_excitations = sorted(alpha_excitations)
             beta_excitations = sorted(beta_excitations)
 
     if not alpha_excitations and not beta_excitations:
         # nothing to do, let's return early
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/utils/vibration_excitation_generator.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/utils/vibration_excitation_generator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/uvcc.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/uvcc.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -16,18 +16,19 @@
 
 import logging
 from functools import partial
 from typing import Callable, Sequence
 
 from qiskit.circuit import QuantumCircuit
 from qiskit.circuit.library import EvolvedOperatorAnsatz
-from qiskit.opflow import PauliTrotterEvolution
+from qiskit.opflow import PauliSumOp
 
 from qiskit_nature import QiskitNatureError
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.deprecation import deprecate_arguments, deprecate_property, warn_deprecated_type
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper, TaperedQubitMapper
 from qiskit_nature.second_q.operators import SparseLabelOp, VibrationalOp
 
 from .utils.vibration_excitation_generator import generate_vibration_excitations
 
 logger = logging.getLogger(__name__)
 
 
@@ -35,22 +36,20 @@
     """
     This trial wavefunction is a Unitary Vibrational Coupled-Cluster ansatz.
 
     This method constructs the requested excitations based on a
     :class:`~qiskit_nature.second_q.circuit.library.VSCF` reference state by default. When setting
     up a ``VQE`` algorithm using this ansatz and initial state, it is likely you will also want to
     use a :class:`~qiskit_nature.second_q.algorithms.initial_points.VSCFInitialPoint` that has been
-    configured using the corresponding ansatz parameters. When using a
-    :class:`~qiskit_nature.second_q.algorithms.VQEUVCCFactory` this is set by default. When directly
-    using ``VQE``, you can set it manually. For example:
+    configured using the corresponding ansatz parameters. This can be done as follows:
 
     .. code-block:: python
 
-        qubit_converter = QubitConverter(JordanWignerMapper())
-        uvcc = UVCC([2, 2], 'sd', qubit_converter)
+        qubit_mapper = JordanWignerMapper()
+        uvcc = UVCC([2, 2], 'sd', qubit_mapper)
         vscf_initial_point = VSCFInitialPoint()
         vscf_initial_point.ansatz = uvcc
         initial_point = vscf_initial_point.to_numpy_array()
         vqe = VQE(Estimator(), uvcc, SLSQP(), initial_point=initial_point)
 
     For more information, see Ollitrault Pauline J., Chemical science 11 (2020): 6842-6855.
     """
@@ -58,30 +57,40 @@
     _EXCITATION_TYPE = {
         "s": 1,
         "d": 2,
         "t": 3,
         "q": 4,
     }
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         num_modals: list[int] | None = None,
         excitations: str
         | int
         | list[int]
         | Callable[
             [int, tuple[int, int]],
             list[tuple[tuple[int, ...], tuple[int, ...]]],
         ]
         | None = None,
-        qubit_converter: QubitConverter | None = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
         reps: int = 1,
         initial_state: QuantumCircuit | None = None,
-    ):
+        qubit_converter: QubitConverter | QubitMapper | None = None,
+    ) -> None:
+        # pylint: disable=unused-argument
         """
 
         Args:
             num_modals: A list defining the number of modals per mode. E.g. for a 3 modes system
                 with 4 modals per mode ``num_modals = [4, 4, 4]``.
             excitations: This can be any of the following types:
 
@@ -93,32 +102,36 @@
                     of excitations (``[1, 2] == 'sd'``, etc.).
                 :`Callable`: A function which is used to generate the excitations.
                     The callable must take the *keyword* argument ``num_modals``
                     (with identical type to that explained above) and must return a
                     ``list[tuple[tuple[int, ...], tuple[int, ...]]]``. For more information on
                     how to write such a callable refer to the default method :meth:`~qiskit_nature.\
                     second_q.circuit.library.ansatzes.utils.generate_vibration_excitations`.
-            qubit_converter: The :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance
-                which takes care of mapping to a qubit operator.
+            qubit_mapper: The :class:`~qiskit_nature.second_q.mappers.QubitMapper` or
+                :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance (use of the latter
+                is deprecated) which takes care of mapping to a qubit operator.
             reps: The number of repetitions of basic module.
             initial_state: A ``QuantumCircuit`` object to prepend to the circuit. Note that this
                 setting does *not* influence the ``excitations``. When relying on the default
                 generation method (i.e. not providing a ``Callable`` to ``excitations``), these will
                 always be constructed with respect to a
                 :class:`~qiskit_nature.second_q.circuit.library.VSCF` reference state. When setting
                 up a ``VQE`` algorithm using this ansatz and initial state, it is likely you will
                 also want to use a
                 :class:`~qiskit_nature.second_q.algorithms.initial_points.VSCFInitialPoint` that has
                 been configured using the corresponding ansatz parameters.
+            qubit_converter: DEPRECATED The :class:`~qiskit_nature.second_q.mappers.QubitConverter`
+                or :class:`~qiskit_nature.second_q.mappers.QubitMapper` instance which takes care of
+                mapping to a qubit operator.
         """
-        self._qubit_converter = qubit_converter
+        self._qubit_mapper = qubit_mapper
         self._num_modals = num_modals
         self._excitations = excitations
 
-        super().__init__(reps=reps, evolution=PauliTrotterEvolution(), initial_state=initial_state)
+        super().__init__(reps=reps, initial_state=initial_state)
 
         # To give read access to the actual excitation list that UVCC is using.
         self._excitation_list: list[tuple[tuple[int, ...], tuple[int, ...]]] | None = None
 
         # We cache these, because the generation may be quite expensive (depending on the generator)
         # and the user may want quick access to inspect these. Also, it speeds up testing for the
         # same reason!
@@ -128,24 +141,42 @@
         # number of qubits, which it gets from the operators. Getting the
         # operators here will build them if configuration already allows.
         # This will allow the circuit to be fully built/valid when it's
         # possible at this stage.
         _ = self.operators
 
     @property
-    def qubit_converter(self) -> QubitConverter | None:
-        """The qubit operator converter."""
-        return self._qubit_converter
+    @deprecate_property("0.6.0", new_name="qubit_mapper")
+    def qubit_converter(self) -> QubitConverter | QubitMapper | None:
+        """DEPRECATED The qubit operator converter."""
+        return self._qubit_mapper
 
     @qubit_converter.setter
-    def qubit_converter(self, conv: QubitConverter) -> None:
+    def qubit_converter(self, conv: QubitConverter | QubitMapper) -> None:
         """Sets the qubit operator converter."""
+        self.qubit_mapper = conv
+
+    @property
+    def qubit_mapper(self) -> QubitConverter | QubitMapper | None:
+        """The qubit operator mapper."""
+        return self._qubit_mapper
+
+    @qubit_mapper.setter
+    def qubit_mapper(self, mapper: QubitConverter | QubitMapper) -> None:
+        """Sets the qubit operator mapper."""
+        if isinstance(mapper, QubitConverter):
+            warn_deprecated_type(
+                "0.6.0",
+                argument_name="mapper",
+                old_type="QubitConverter",
+                new_type="QubitMapper",
+            )
         self._operators = None
         self._invalidate()
-        self._qubit_converter = conv
+        self._qubit_mapper = mapper
 
     @property
     def num_modals(self) -> list[int] | None:
         """The number of modals."""
         return self._num_modals
 
     @num_modals.setter
@@ -194,34 +225,48 @@
             if self._check_uvcc_configuration(raise_on_failure=False):
                 # The qubit operators are cached by `EvolvedOperatorAnsatz` class. We only generate
                 # them from the `SparseLabelOp`s produced by the generators, if they're not
                 # already present. This behavior also enables the adaptive usage of the `UVCC` class
                 # by algorithms such as `AdaptVQE`.
                 excitation_ops = self.excitation_ops()
 
-                logger.debug("Converting SparseLabelOps into PauliSumOps...")
+                logger.debug("Converting second-quantized into qubit operators...")
                 # Convert operators according to saved state in converter from the conversion of the
                 # main operator since these need to be compatible. If Z2 Symmetry tapering was done
                 # it may be that one or more excitation operators do not commute with the symmetry.
                 # The converted operators are maintained at the same index by the converter
                 # inserting ``None`` as the result if an operator did not commute. To ensure that
                 # the ``excitation_list`` is transformed identically to the operators, we retain
                 # ``None`` for non-commuting operators in order to manually remove them in unison.
-                operators = self.qubit_converter.convert_match(excitation_ops, suppress_none=False)
-                valid_operators, valid_excitations = [], []
-                for op, ex in zip(operators, self._excitation_list):
-                    if op is not None:
-                        valid_operators.append(op)
-                        valid_excitations.append(ex)
+                if isinstance(self.qubit_mapper, QubitConverter):
+                    operators = self.qubit_mapper.convert_match(excitation_ops, suppress_none=False)
+                elif isinstance(self.qubit_mapper, TaperedQubitMapper):
+                    operators = self.qubit_mapper.map_clifford(excitation_ops)
+                    operators = self.qubit_mapper.taper_clifford(operators, suppress_none=False)
+                else:
+                    operators = self.qubit_mapper.map(excitation_ops)
 
-                self._excitation_list = valid_excitations
-                self.operators = valid_operators
+                self._filter_operators(operators=operators)
 
         return super(UVCC, self.__class__).operators.__get__(self)
 
+    def _filter_operators(self, operators):
+        valid_operators, valid_excitations = [], []
+        for op, ex in zip(operators, self._excitation_list):
+            if op is not None:
+                # TODO: remove wrapping into PauliSumOp after the EvolvedOperatorAnsatz supports
+                # SparsePauliOp instances, too: https://github.com/Qiskit/qiskit-terra/pull/9537
+                if not isinstance(op, PauliSumOp):
+                    op = PauliSumOp(op)
+                valid_operators.append(op)
+                valid_excitations.append(ex)
+
+        self._excitation_list = valid_excitations
+        self.operators = valid_operators
+
     def _invalidate(self):
         self._excitation_ops = None
         super()._invalidate()
 
     def _check_configuration(self, raise_on_failure: bool = True) -> bool:
         # Check our local config is valid first. The super class will check the
         # operators by getting them, and if we detect they are still None they
@@ -248,17 +293,17 @@
             return False
 
         if self.excitations is None:
             if raise_on_failure:
                 raise ValueError("The excitations cannot be `None`.")
             return False
 
-        if self.qubit_converter is None:
+        if self.qubit_mapper is None:
             if raise_on_failure:
-                raise ValueError("The qubit_converter cannot be `None`.")
+                raise ValueError("The qubit_mapper cannot be `None`.")
             return False
 
         return True
 
     def excitation_ops(self) -> list[SparseLabelOp]:
         """Parses the excitations and generates the list of operators.
 
@@ -283,15 +328,15 @@
     def _get_excitation_list(self) -> list[tuple[tuple[int, ...], tuple[int, ...]]]:
         generators = self._get_excitation_generators()
 
         logger.debug("Generating excitation list...")
         excitations = []
         for gen in generators:
             excitations.extend(
-                gen(
+                gen(  # pylint: disable=not-callable
                     num_modals=self.num_modals,
                 )
             )
 
         return excitations
 
     def _get_excitation_generators(self) -> list[Callable]:
@@ -344,13 +389,13 @@
             label = []
             for occ in exc[0]:
                 label.append(f"+_{VibrationalOp.build_dual_index(self.num_modals, occ)}")
             for unocc in exc[1]:
                 label.append(f"-_{VibrationalOp.build_dual_index(self.num_modals, unocc)}")
             op = VibrationalOp({" ".join(label): 1}, self.num_modals)
             op -= op.adjoint()
-            # we need to account for an additional imaginary phase in the exponent (see also
-            # `PauliTrotterEvolution.convert`)
+            # we need to account for an additional imaginary phase in the exponent accumulated from
+            # the first-order trotterization routine implemented in Qiskit Terra
             op *= 1j  # type: ignore
             operators.append(op)
 
         return operators
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/ansatzes/uvccsd.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/ansatzes/uvccsd.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,41 +12,56 @@
 """
 The UVCCSD Ansatz.
 """
 
 from __future__ import annotations
 
 from qiskit.circuit import QuantumCircuit
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.deprecation import deprecate_arguments
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from .uvcc import UVCC
 
 
 class UVCCSD(UVCC):
     """The UVCCSD Ansatz.
 
     This is a convenience subclass of the UVCC ansatz. For more information refer to :class:`UVCC`.
     """
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         num_modals: list[int] | None = None,
-        qubit_converter: QubitConverter | None = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
         reps: int = 1,
         initial_state: QuantumCircuit | None = None,
-    ):
+        qubit_converter: QubitConverter | QubitMapper | None = None,
+    ) -> None:
+        # pylint: disable=unused-argument
         """
         Args:
             num_modals: A list defining the number of modals per mode. E.g. for a 3-mode system
                 with 4 modals per mode ``num_modals = [4, 4, 4]``.
-            qubit_converter: The :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance
-                which takes care of mapping to a qubit operator.
+            qubit_mapper: The :class:`~qiskit_nature.second_q.mappers.QubitMapper` or
+                :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance (use of the latter
+                is deprecated) which takes care of mapping to a qubit operator.
             reps: The number of times to repeat the evolved operators.
             initial_state: A ``QuantumCircuit`` object to prepend to the circuit.
+            qubit_converter: DEPRECATED The :class:`~qiskit_nature.second_q.mappers.QubitConverter`
+                or :class:`~qiskit_nature.second_q.mappers.QubitMapper` instance which takes care of
+                mapping to a qubit operator.
         """
         super().__init__(
             num_modals=num_modals,
             excitations="sd",
-            qubit_converter=qubit_converter,
+            qubit_mapper=qubit_mapper,
             reps=reps,
             initial_state=initial_state,
         )
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/bogoliubov_transform.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/bogoliubov_transform.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Bogoliubov transform."""
 
 from __future__ import annotations
 
 from collections.abc import Iterator
-from typing import Optional
 
 import numpy as np
 from qiskit import QuantumCircuit, QuantumRegister
 from qiskit.circuit import Gate, Qubit
 from qiskit.circuit.library import RZGate, XXPlusYYGate
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from qiskit_nature.second_q.mappers import JordanWignerMapper
+from qiskit_nature.deprecation import deprecate_arguments
 from qiskit_nature.utils import apply_matrix_to_slices, givens_matrix
 from qiskit_nature.utils.linalg import fermionic_gaussian_decomposition_jw
 
 
 def _rows_are_orthonormal(mat: np.ndarray, rtol: float = 1e-5, atol: float = 1e-8) -> bool:
     m, _ = mat.shape
     return np.allclose(mat @ mat.T.conj(), np.eye(m), rtol=rtol, atol=atol)
@@ -126,31 +126,44 @@
         - `arXiv:1711.05395`_
         - `arXiv:1603.08788`_
 
     .. _arXiv:1711.05395: https://arxiv.org/abs/1711.05395
     .. _arXiv:1603.08788: https://arxiv.org/abs/1603.08788
     """
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         transformation_matrix: np.ndarray,
-        qubit_converter: Optional[QubitConverter] = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
         validate: bool = True,
         rtol: float = 1e-5,
         atol: float = 1e-8,
         **circuit_kwargs,
     ) -> None:
+        # pylint: disable=unused-argument
         r"""
         Args:
             transformation_matrix: The matrix :math:`W` that specifies the coefficients of the
                 new creation operators in terms of the original creation operators.
                 Should be either :math:`N \times N` or :math:`N \times 2N`.
-            qubit_converter: The qubit converter. The default behavior is to create
-                one using the call ``QubitConverter(JordanWignerMapper())``.
+            qubit_mapper: The ``QubitMapper`` or ``QubitConverter`` (use of the latter is
+                deprecated). The default behavior is to create one using the call
+                ``JordanWignerMapper()``.
+            qubit_converter: DEPRECATED The ``QubitConverter`` or ``QubitMapper``. The default
+                behavior is to create one using the call ``JordanWignerMapper()``.
             validate: Whether to validate the inputs.
             rtol: Relative numerical tolerance for input validation.
             atol: Absolute numerical tolerance for input validation.
             circuit_kwargs: Keyword arguments to pass to the ``QuantumCircuit`` initializer.
 
         Raises:
             ValueError: ``transformation_matrix`` must be a 2-dimensional array.
@@ -158,38 +171,37 @@
             ValueError: ``transformation_matrix`` does not describe a valid transformation
                 of fermionic ladder operators. If the transformation matrix is
                 :math:`N \times N`, then it should be unitary.
                 If the transformation matrix is :math:`N \times 2N`, then it should have the block form
                 :math:`(W_1 \quad W_2)` where :math:`W_1 W_1^\dagger + W_2 W_2^\dagger = I` and
                 :math:`W_1 W_2^T + W_2 W_1^T = 0`.
             NotImplementedError: Currently, only the Jordan-Wigner Transform is supported.
-                Please use
-                :class:`qiskit_nature.second_q.mappers.JordanWignerMapper`
-                to construct the qubit mapper.
+                Please use the :class:`qiskit_nature.second_q.mappers.JordanWignerMapper`.
         """
         if validate:
             _validate_transformation_matrix(transformation_matrix, rtol=rtol, atol=atol)
 
-        if qubit_converter is None:
-            qubit_converter = QubitConverter(JordanWignerMapper())
+        if qubit_mapper is None:
+            qubit_mapper = JordanWignerMapper()
 
         n, _ = transformation_matrix.shape
         register = QuantumRegister(n)
         super().__init__(register, **circuit_kwargs)
 
-        if isinstance(qubit_converter.mapper, JordanWignerMapper):
+        if (
+            isinstance(qubit_mapper, QubitConverter)
+            and isinstance(qubit_mapper.mapper, JordanWignerMapper)
+        ) or (isinstance(qubit_mapper, JordanWignerMapper)):
             operations = _bogoliubov_transform_jw(register, transformation_matrix)
             for gate, qubits in operations:
                 self.append(gate, qubits)
         else:
             raise NotImplementedError(
                 "Currently, only the Jordan-Wigner Transform is supported. "
-                "Please use "
-                "qiskit_nature.second_q.mappers.JordanWignerMapper "
-                "to construct the qubit mapper."
+                "Please use the qiskit_nature.second_q.mappers.JordanWignerMapper."
             )
 
 
 def _bogoliubov_transform_jw(
     register: QuantumRegister, transformation_matrix: np.ndarray
 ) -> Iterator[tuple[Gate, tuple[Qubit, ...]]]:
     n, p = transformation_matrix.shape  # pylint: disable=invalid-name
@@ -240,15 +252,15 @@
                     left_rotations.append((givens_mat, (target_index - 1, target_index)))
                     current_matrix = apply_matrix_to_slices(
                         current_matrix, givens_mat, [target_index - 1, target_index]
                     )
 
     # convert left rotations to right rotations
     for givens_mat, (i, j) in reversed(left_rotations):
-        givens_mat = givens_mat.T.conj()
+        givens_mat = givens_mat.T.conj().astype(complex, copy=False)
         givens_mat[:, 0] *= current_matrix[i, i]
         givens_mat[:, 1] *= current_matrix[j, j]
         new_givens_mat = givens_matrix(givens_mat[1, 1], givens_mat[1, 0])
         right_rotations.append((new_givens_mat.T, (i, j)))
         phase_matrix = givens_mat @ new_givens_mat
         current_matrix[i, i] = phase_matrix[0, 0]
         current_matrix[j, j] = phase_matrix[1, 1]
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/fermionic_gaussian_state.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/fermionic_gaussian_state.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,27 +1,29 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Fermionic Gaussian states."""
 
-from typing import Optional, Sequence
+from __future__ import annotations
+
+from typing import Sequence
 
 import numpy as np
 from qiskit import QuantumCircuit, QuantumRegister
-from qiskit_nature.second_q.mappers import QubitConverter
-from qiskit_nature.second_q.mappers import JordanWignerMapper
+from qiskit_nature.deprecation import deprecate_arguments
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper, JordanWignerMapper
 
 from .utils.givens_rotations import _prepare_fermionic_gaussian_state_jw
 
 
 def _validate_transformation_matrix(
     mat: np.ndarray, rtol: float = 1e-5, atol: float = 1e-8
 ) -> None:
@@ -108,72 +110,85 @@
     Currently, only the Jordan-Wigner transformation is supported.
 
     Reference: `arXiv:1711.05395`_
 
     .. _arXiv:1711.05395: https://arxiv.org/abs/1711.05395
     """
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         transformation_matrix: np.ndarray,
-        occupied_orbitals: Optional[Sequence[int]] = None,
-        qubit_converter: QubitConverter = None,
+        occupied_orbitals: Sequence[int] | None = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
         validate: bool = True,
         rtol: float = 1e-5,
         atol: float = 1e-8,
         **circuit_kwargs,
     ) -> None:
+        # pylint: disable=unused-argument
         r"""
         Args:
             transformation_matrix: The matrix :math:`W` that specifies the coefficients of the
                 new creation operators in terms of the original creation and annihilation operators.
                 This matrix must satisfy special constraints, as detailed above.
             occupied_orbitals: The pseudo-particle orbitals to fill. These refer to the indices
                 of the operators :math:`\{b^\dagger_j\}` from the main body of the docstring
                 of this function. The default behavior is to use the empty set of orbitals,
                 which corresponds to a state with zero pseudo-particles.
-            qubit_converter: The qubit converter. The default behavior is to create
-                one using the call ``QubitConverter(JordanWignerMapper())``.
+            qubit_mapper: The ``QubitMapper`` or ``QubitConverter`` (use of the latter is
+                deprecated). The default behavior is to create one using the call
+                ``JordanWignerMapper()``.
+            qubit_converter: DEPRECATED The ``QubitConverter`` or ``QubitMapper``. The default
+                behavior is to create one using the call ``JordanWignerMapper()``.
             validate: Whether to validate the inputs.
             rtol: Relative numerical tolerance for input validation.
             atol: Absolute numerical tolerance for input validation.
             circuit_kwargs: Keyword arguments to pass to the ``QuantumCircuit`` initializer.
 
         Raises:
             ValueError: transformation_matrix must be a 2-dimensional array.
             ValueError: transformation_matrix must have shape ``(n_orbitals, 2 * n_orbitals)``.
             ValueError: transformation_matrix does not describe a valid transformation
                 of fermionic ladder operators. A valid matrix has the block form
                 :math:`(W_1 \quad W_2)` where :math:`W_1 W_1^\dagger + W_2 W_2^\dagger = I` and
                 :math:`W_1 W_2^T + W_2 W_1^T = 0`.
 
             NotImplementedError: Currently, only the Jordan-Wigner Transform is supported.
-                Please use
-                :class:`qiskit_nature.second_q.mappers.JordanWignerMapper`
-                to construct the qubit mapper used to construct ``qubit_converter``.
+                Please use the :class:`qiskit_nature.second_q.mappers.JordanWignerMapper`.
         """
         if validate:
             _validate_transformation_matrix(transformation_matrix, rtol=rtol, atol=atol)
 
         if occupied_orbitals is None:
             occupied_orbitals = []
-        if qubit_converter is None:
-            qubit_converter = QubitConverter(JordanWignerMapper())
+
+        if qubit_mapper is None:
+            qubit_mapper = QubitConverter(JordanWignerMapper())
 
         n, _ = transformation_matrix.shape
         register = QuantumRegister(n)
         super().__init__(register, **circuit_kwargs)
 
-        if isinstance(qubit_converter.mapper, JordanWignerMapper):
+        if (
+            isinstance(qubit_mapper, QubitConverter)
+            and isinstance(qubit_mapper.mapper, JordanWignerMapper)
+        ) or (isinstance(qubit_mapper, JordanWignerMapper)):
             operations = _prepare_fermionic_gaussian_state_jw(
                 register, transformation_matrix, occupied_orbitals
             )
             for gate, qubits in operations:
                 self.append(gate, qubits)
         else:
             raise NotImplementedError(
                 "Currently, only the Jordan-Wigner Transform is supported. "
-                "Please use "
-                "qiskit_nature.second_q.mappers.JordanWignerMapper "
-                "to construct the qubit mapper used to construct qubit_converter."
+                "Please use the qiskit_nature.second_q.mappers.JordanWignerMapper."
             )
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/hartree_fock.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/hartree_fock.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,73 +1,113 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Hartree-Fock initial state."""
 
 from __future__ import annotations
-
+import warnings
 import numpy as np
 from qiskit import QuantumRegister
 from qiskit.circuit.library import BlueprintCircuit
 from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
 from qiskit.utils.validation import validate_min
 
-from qiskit_nature.second_q.mappers import BravyiKitaevSuperFastMapper, QubitConverter
+from qiskit_nature.second_q.mappers import (
+    BravyiKitaevSuperFastMapper,
+    QubitConverter,
+    QubitMapper,
+    TaperedQubitMapper,
+)
 from qiskit_nature.second_q.operators import FermionicOp
+from qiskit_nature.deprecation import deprecate_arguments, deprecate_property, warn_deprecated_type
 
 
 class HartreeFock(BlueprintCircuit):
     """A Hartree-Fock initial state."""
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         num_spatial_orbitals: int | None = None,
         num_particles: tuple[int, int] | None = None,
-        qubit_converter: QubitConverter | None = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
+        *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
     ) -> None:
+        # pylint: disable=unused-argument
         """
         Args:
             num_spatial_orbitals: The number of spatial orbitals.
             num_particles: The number of particles as a tuple storing the number of alpha and
                 beta-spin electrons in the first and second number, respectively.
-            qubit_converter: a :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance.
+            qubit_mapper: A :class:`~qiskit_nature.second_q.mappers.QubitMapper` or a
+                :class:`~qiskit_nature.second_q.mappers.QubitConverter` instance (use of the latter
+                is deprecated).
+            qubit_converter: DEPRECATED A :class:`~qiskit_nature.second_q.mappers.QubitConverter` or
+                a :class:`~qiskit_nature.second_q.mappers.QubitMapper` instance.
 
         Raises:
-            NotImplementedError: If ``qubit_converter`` contains
+            NotImplementedError: If ``qubit_mapper`` is (or uses) a
                 :class:`~qiskit_nature.second_q.mappers.BravyiKitaevSuperFastMapper`. See
                 https://github.com/Qiskit/qiskit-nature/issues/537 for more information.
         """
 
         super().__init__()
-        self._qubit_converter = qubit_converter
+        self._qubit_mapper = qubit_mapper
         self._num_spatial_orbitals = num_spatial_orbitals
         self._num_particles = num_particles
         self._bitstr: list[bool] | None = None
 
         self._reset_register()
 
     @property
-    def qubit_converter(self) -> QubitConverter:
-        """The qubit converter."""
-        return self._qubit_converter
+    @deprecate_property("0.6.0", new_name="qubit_mapper")
+    def qubit_converter(self) -> QubitConverter | QubitMapper | None:
+        """DEPRECATED The qubit converter."""
+        return self._qubit_mapper
 
     @qubit_converter.setter
-    def qubit_converter(self, conv: QubitConverter) -> None:
+    def qubit_converter(self, conv: QubitConverter | QubitMapper | None) -> None:
         """Sets the qubit converter."""
+        self.qubit_mapper = conv
+
+    @property
+    def qubit_mapper(self) -> QubitConverter | QubitMapper | None:
+        """The qubit mapper."""
+        return self._qubit_mapper
+
+    @qubit_mapper.setter
+    def qubit_mapper(self, mapper: QubitConverter | QubitMapper | None) -> None:
+        """Sets the qubit mapper."""
+        if isinstance(mapper, QubitConverter):
+            warn_deprecated_type(
+                "0.6.0",
+                argument_name="mapper",
+                old_type="QubitConverter",
+                new_type="QubitMapper",
+            )
         self._invalidate()
-        self._qubit_converter = conv
+        self._qubit_mapper = mapper
         self._reset_register()
 
     @property
     def num_spatial_orbitals(self) -> int:
         """The number of spatial orbitals."""
         return self._num_spatial_orbitals
 
@@ -101,16 +141,16 @@
 
         Raises:
             ValueError: If the number of spatial orbitals is not specified or less than one.
             ValueError: If the number of particles is not specified or less than zero.
             ValueError: If the number of particles of any kind is less than zero.
             ValueError: If the number of spatial orbitals is smaller than the number of particles
                 of any kind.
-            ValueError: If the qubit converter is not specified.
-            NotImplementedError: If the specified qubit converter is a
+            ValueError: If the qubit mapper is not specified.
+            NotImplementedError: If the specified qubit mapper is a
                 :class:`~qiskit_nature.second_q.mappers.BravyiKitaevSuperFastMapper` instance.
         """
         if self.num_spatial_orbitals is None:
             if raise_on_failure:
                 raise ValueError("The number of spatial orbitals cannot be 'None'.")
             return False
 
@@ -138,51 +178,61 @@
                 raise ValueError(
                     f"The number of spatial orbitals {self.num_spatial_orbitals}"
                     f"must be greater than or equal to the number of particles of "
                     f"any spin kind {self.num_particles}."
                 )
             return False
 
-        if self.qubit_converter is None:
+        if self.qubit_mapper is None:
             if raise_on_failure:
-                raise ValueError("The qubit converter cannot be `None`.")
+                raise ValueError("The qubit mapper cannot be `None`.")
             return False
 
-        if isinstance(self.qubit_converter.mapper, BravyiKitaevSuperFastMapper):
+        if isinstance(self.qubit_mapper, QubitConverter):
+            mapper = self.qubit_mapper.mapper
+        elif isinstance(self.qubit_mapper, TaperedQubitMapper):
+            # we also include the TaperedQubitMapper here, purely for the check done below
+            mapper = self.qubit_mapper.mapper
+        else:
+            mapper = self.qubit_mapper
+
+        if isinstance(mapper, BravyiKitaevSuperFastMapper):
             if raise_on_failure:
                 raise NotImplementedError(
-                    "Unsupported mapper in qubit converter: ",
-                    type(self.qubit_converter.mapper),
+                    "Unsupported mapper: ",
+                    type(mapper),
                     ". See https://github.com/Qiskit/qiskit-nature/issues/537",
                 )
             return False
 
         return True
 
     def _reset_register(self):
         """Reset the register and recompute the mapped Hartree-Fock bitstring."""
         self.qregs = []
         self._bitstr = None
 
         if self._check_configuration(raise_on_failure=False):
-            self._bitstr = hartree_fock_bitstring_mapped(
-                self.num_spatial_orbitals,
-                self.num_particles,
-                self.qubit_converter,
-                match_convert=True,
-            )
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore", category=DeprecationWarning)
+                self._bitstr = hartree_fock_bitstring_mapped(
+                    self.num_spatial_orbitals,
+                    self.num_particles,
+                    self.qubit_mapper,
+                    match_convert=True,
+                )
             self.qregs = [QuantumRegister(len(self._bitstr), name="q")]
 
     def _build(self) -> None:
         """
         Construct the Hartree-Fock initial state given its parameters.
         Returns:
             QuantumCircuit: a quantum circuit preparing the Hartree-Fock
             initial state given a number of spatial orbitals, number of particles and
-            a qubit converter.
+            a qubit mapper.
         """
         if self._is_built:
             return
 
         super()._build()
 
         # Construct the circuit for bitstring. Since this is defined as an initial state
@@ -190,57 +240,85 @@
         # the zero state. Hence we just need to account for all True entries and set those.
         if self._bitstr is not None:
             for i, bit in enumerate(self._bitstr):
                 if bit:
                     self.x(i)
 
 
+@deprecate_arguments(
+    "0.6.0",
+    {"qubit_converter": "qubit_mapper"},
+    additional_msg=(
+        ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+        "and support for it will be removed together with the qubit_converter argument."
+    ),
+)
+@deprecate_arguments(
+    "0.6.0",
+    {"match_convert": ""},
+    additional_msg=(
+        ". This argument is no longer necessary when working directly with QubitMapper objects "
+        "outside of a QubitConverter because TaperedQubitMapper instances are now built differently"
+    ),
+)
 def hartree_fock_bitstring_mapped(
     num_spatial_orbitals: int,
     num_particles: tuple[int, int],
-    qubit_converter: QubitConverter,
+    qubit_mapper: QubitConverter | QubitMapper,
     *,
+    qubit_converter: QubitConverter | QubitMapper | None = None,
     match_convert: bool = True,
 ) -> list[bool]:
+    # pylint: disable=unused-argument
     """Compute the bitstring representing the mapped Hartree-Fock state for the specified system.
 
     Args:
         num_spatial_orbitals: The number of spatial orbitals, has a min. value of 1.
         num_particles: The number of particles as a tuple (alpha, beta) containing the number of
             alpha- and  beta-spin electrons, respectively.
-        qubit_converter: A QubitConverter instance.
+        qubit_mapper: A QubitMapper or QubitConverter instance (use of the latter is deprecated).
+        qubit_converter: DEPRECATED A QubitConverter or QubitMapper instance.
         match_convert: Whether to use `convert_match` method of the qubit converter (default),
             or just do mapping and possibly two qubit reduction but no tapering. The latter
             is an advanced usage - e.g. if we are trying to auto-select the tapering sector
             then we would not want any match conversion done on a converter that was set to taper.
 
     Returns:
         The bitstring representing the mapped state of the Hartree-Fock state as array of bools.
     """
-
     # get the bitstring encoding the Hartree Fock state
     bitstr = hartree_fock_bitstring(num_spatial_orbitals, num_particles)
 
     # encode the bitstring as a `FermionicOp`
     bitstr_op = FermionicOp(
         {" ".join(f"+_{idx}" for idx, bit in enumerate(bitstr) if bit): 1.0},
         num_spin_orbitals=2 * num_spatial_orbitals,
     )
 
     # map the `FermionicOp` to a qubit operator
-    qubit_op: PauliSumOp = (
-        qubit_converter.convert_match(bitstr_op, check_commutes=False)
-        if match_convert
-        else qubit_converter.convert_only(bitstr_op, num_particles)
-    )
+    qubit_op: SparsePauliOp
+    if isinstance(qubit_mapper, QubitConverter):
+        if match_convert:
+            qubit_op = qubit_mapper.convert_match(bitstr_op, check_commutes=False)
+        else:
+            qubit_op = qubit_mapper.convert_only(bitstr_op, num_particles)
+    elif isinstance(qubit_mapper, TaperedQubitMapper):
+        # To avoid checking commutativity, we call the two methods separately.
+        qubit_op = qubit_mapper.map_clifford(bitstr_op)
+        qubit_op = qubit_mapper.taper_clifford(qubit_op, check_commutes=False)
+    else:
+        qubit_op = qubit_mapper.map(bitstr_op)
+
+    if isinstance(qubit_op, PauliSumOp):
+        qubit_op = qubit_op.primitive
 
     # We check the mapped operator `x` part of the paulis because we want to have particles
     # i.e. True, where the initial state introduced a creation (`+`) operator.
     bits = []
-    for bit in qubit_op.primitive.paulis.x[0]:
+    for bit in qubit_op.paulis.x[0]:
         bits.append(bit)
 
     return bits
 
 
 def hartree_fock_bitstring(num_spatial_orbitals: int, num_particles: tuple[int, int]) -> list[bool]:
     """Compute the bitstring representing the Hartree-Fock state for the specified system.
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/slater_determinant.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/slater_determinant.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Slater determinants."""
 
-from typing import Optional
+from __future__ import annotations
 
 import numpy as np
 from qiskit import QuantumCircuit, QuantumRegister
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from qiskit_nature.second_q.mappers import JordanWignerMapper
+from qiskit_nature.deprecation import deprecate_arguments
 
 from .utils.givens_rotations import _prepare_slater_determinant_jw
 
 
 def _rows_are_orthonormal(mat: np.ndarray, rtol: float = 1e-5, atol: float = 1e-8) -> bool:
     m, _ = mat.shape
     return np.allclose(mat @ mat.T.conj(), np.eye(m), rtol=rtol, atol=atol)
@@ -67,58 +68,70 @@
     Currently, only the Jordan-Wigner transformation is supported.
 
     Reference: `arXiv:1711.05395`_
 
     .. _arXiv:1711.05395: https://arxiv.org/abs/1711.05395
     """
 
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
     def __init__(
         self,
         transformation_matrix: np.ndarray,
-        qubit_converter: Optional[QubitConverter] = None,
+        qubit_mapper: QubitConverter | QubitMapper | None = None,
         *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
         validate: bool = True,
         rtol: float = 1e-5,
         atol: float = 1e-8,
         **circuit_kwargs,
     ) -> None:
+        # pylint: disable=unused-argument
         r"""
         Args:
             transformation_matrix: The matrix :math:`Q` that specifies the coefficients of the
                 new creation operators in terms of the original creation operators.
                 The rows of the matrix must be orthonormal.
-            qubit_converter: The qubit converter. The default behavior is to create
-                one using the call ``QubitConverter(JordanWignerMapper())``.
+            qubit_mapper: The ``QubitMapper`` or ``QubitConverter`` (use of the latter is
+                deprecated). The default behavior is to create one using the call
+                ``JordanWignerMapper()``.
+            qubit_converter: DEPRECATED The ``QubitConverter`` or ``QubitMapper``. The default
+                behavior is to create one using the call ``JordanWignerMapper()``.
             validate: Whether to validate the inputs.
             rtol: Relative numerical tolerance for input validation.
             atol: Absolute numerical tolerance for input validation.
             circuit_kwargs: Keyword arguments to pass to the ``QuantumCircuit`` initializer.
 
         Raises:
             ValueError: transformation_matrix must be a 2-dimensional array.
             ValueError: transformation_matrix must have orthonormal rows.
-            NotImplementedError: Currently, only the Jordan-Wigner transformation is supported.
-                Please use
-                :class:`qiskit_nature.second_q.mappers.JordanWignerMapper`
-                to construct the qubit mapper used to construct ``qubit_converter``.
+            NotImplementedError: Currently, only the Jordan-Wigner Transform is supported.
+                Please use the :class:`qiskit_nature.second_q.mappers.JordanWignerMapper`.
         """
         if validate:
             _validate_transformation_matrix(transformation_matrix, rtol=rtol, atol=atol)
 
-        if qubit_converter is None:
-            qubit_converter = QubitConverter(JordanWignerMapper())
+        if qubit_mapper is None:
+            qubit_mapper = JordanWignerMapper()
 
         _, n = transformation_matrix.shape
         register = QuantumRegister(n)
         super().__init__(register, **circuit_kwargs)
 
-        if isinstance(qubit_converter.mapper, JordanWignerMapper):
+        if (
+            isinstance(qubit_mapper, QubitConverter)
+            and isinstance(qubit_mapper.mapper, JordanWignerMapper)
+        ) or (isinstance(qubit_mapper, JordanWignerMapper)):
             operations = _prepare_slater_determinant_jw(register, transformation_matrix)
             for gate, qubits in operations:
                 self.append(gate, qubits)
         else:
             raise NotImplementedError(
                 "Currently, only the Jordan-Wigner Transform is supported. "
-                "Please use "
-                "qiskit_nature.second_q.mappers.JordanWignerMapper "
-                "to construct the qubit mapper used to construct qubit_converter."
+                "Please use the qiskit_nature.second_q.mappers.JordanWignerMapper."
             )
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/utils/givens_rotations.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/circuit/library/initial_states/utils/givens_rotations.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/circuit/library/initial_states/vscf.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/base_problem.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,217 +1,188 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
+# This code is part of Qiskit.
 
-"""Initial state for vibrational modes."""
+"""The Base Problem class."""
 
 from __future__ import annotations
 
-import logging
+from typing import Callable
 
 import numpy as np
-
-from qiskit import QuantumRegister
-from qiskit.circuit.library import BlueprintCircuit
+from qiskit.algorithms.eigensolvers import EigensolverResult
+from qiskit.algorithms.minimum_eigensolvers import MinimumEigensolverResult
 from qiskit.opflow import PauliSumOp
-from qiskit_nature.second_q.mappers import DirectMapper
-from qiskit_nature.second_q.mappers import QubitConverter
-from qiskit_nature.second_q.operators import VibrationalOp
+from qiskit.opflow.primitive_ops import Z2Symmetries as OpflowZ2Symmetries
+from qiskit.quantum_info.analysis.z2_symmetries import Z2Symmetries
+
+from qiskit_nature.deprecation import deprecate_function
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper, TaperedQubitMapper
+from qiskit_nature.second_q.operators import SparseLabelOp
+from qiskit_nature.second_q.hamiltonians import Hamiltonian
 
-logger = logging.getLogger(__name__)
+from .eigenstate_result import EigenstateResult
+from .properties_container import PropertiesContainer
 
 
-class VSCF(BlueprintCircuit):
-    r"""Initial state for vibrational modes.
+class BaseProblem:
+    """The base representation of a second-quantization problem.
 
-    Creates an occupation number vector as defined in [1].
-    As example, for 2 modes with 4 modals per mode it creates: :math:`|1000 1000\rangle`.
+    If none of the specific subclasses of this class fit your use case, you can instantiate this
+    class itself with your custom :class:`.Hamiltonian` instance and pass it into one of the
+    available algorithms.
 
-    References:
+    The following attributes can be read and updated once the ``BaseProblem`` object has been
+    constructed.
 
-        [1] Ollitrault Pauline J., Chemical science 11 (2020): 6842-6855.
+    Attributes:
+        properties (PropertiesContainer): a container for additional observable operator factories.
     """
 
-    def __init__(
-        self,
-        num_modals: list[int] | None = None,
-        qubit_converter: QubitConverter | None = None,
-    ) -> None:
+    def __init__(self, hamiltonian: Hamiltonian) -> None:
         """
+
         Args:
-            num_modals: Is a list defining the number of modals per mode. E.g. for a 3 modes system
-                with 4 modals per mode num_modals = [4,4,4]
-            qubit_converter: a QubitConverter instance. This argument is currently being ignored
-                because only a single use-case is supported at the time of release: that of the
-                :class:`DirectMapper`. However, for future-compatibility of this functions
-                signature, the argument has already been inserted.
-        """
-        super().__init__()
-        self._num_modals = num_modals
-        self._qubit_converter = qubit_converter
-        self._bitstr: list[bool] | None = None
-
-        self.qubit_converter = (
-            QubitConverter(DirectMapper()) if qubit_converter is None else qubit_converter
-        )
+            driver: A driver encoding the molecule information.
+            transformers: A list of transformations to be applied to the driver result.
+            main_property_name: A main property name for the problem
+        """
+        self._hamiltonian = hamiltonian
+        self.properties = PropertiesContainer()
 
     @property
-    def qubit_converter(self) -> QubitConverter:
-        """The qubit converter."""
-        return self._qubit_converter
-
-    @qubit_converter.setter
-    def qubit_converter(self, conv: QubitConverter) -> None:
-        """Sets the qubit converter."""
-        self._invalidate()
-        if not isinstance(conv.mapper, DirectMapper):
-            logger.warning(
-                "The only supported `QubitConverter` is one with a `DirectMapper` as the mapper "
-                "instance. However you specified %s as an input, which will be ignored until more "
-                "variants will be supported.",
-                type(conv.mapper),
-            )
-            conv = QubitConverter(DirectMapper())
-        self._qubit_converter = conv
-        self._reset_register()
+    def hamiltonian(self) -> Hamiltonian:
+        """Returns the hamiltonian wrapped by this problem."""
+        return self._hamiltonian
 
-    @property
-    def num_modals(self) -> list[int]:
-        """The number of modals per mode."""
-        return self._num_modals
-
-    @num_modals.setter
-    def num_modals(self, num_modals: list[int]) -> None:
-        """Sets the number of modals."""
-        self._invalidate()
-        self._num_modals = num_modals
-        self._reset_register()
+    def second_q_ops(self) -> tuple[SparseLabelOp, dict[str, SparseLabelOp]]:
+        """Returns the second quantized operators associated with this problem.
 
-    def _check_configuration(self, raise_on_failure: bool = True) -> bool:
-        """Check if the configuration of the VSCF class is valid.
-        Args:
-            raise_on_failure: Whether to raise on failure.
         Returns:
-            True, if the configuration is valid and the circuit can be constructed. Otherwise
-            an ValueError or TypeError is raised.
-        Raises:
-            ValueError: If the number of modals per mode is not specified.
-            ValueError: If any of the number of modals is less than zero.
-            ValueError: If the qubit converter is not specified.
-        """
-        if self.num_modals is None:
-            if raise_on_failure:
-                raise ValueError("The number of modals cannot be 'None'.")
-            return False
-
-        if any(n < 0 for n in self.num_modals):
-            if raise_on_failure:
-                raise ValueError(
-                    f"The number of modals cannot be smaller than 0 was {self.num_modals}."
-                )
-            return False
-
-        if self.qubit_converter is None:
-            if raise_on_failure:
-                raise ValueError("The qubit converter cannot be `None`.")
-            return False
-
-        return True
-
-    def _reset_register(self):
-        """Reset the register and recompute the mapped VSCF bitstring."""
-        self.qregs = []
-        self._bitstr = None
-
-        if self._check_configuration(raise_on_failure=False):
-            self._bitstr = vscf_bitstring_mapped(self.num_modals, self.qubit_converter)
-            self.qregs = [QuantumRegister(len(self._bitstr), name="q")]
-
-    def _build(self) -> None:
+            A tuple, with the first object being the main operator and the second being a dictionary
+            of auxiliary operators.
         """
-        Construct the VSCF initial state given its parameters.
+        main_op = self.hamiltonian.second_q_op()
+
+        aux_ops: dict[str, SparseLabelOp] = {}
+        for prop in self.properties:
+            aux_ops.update(prop.second_q_ops())
+
+        return main_op, aux_ops
+
+    # pylint: disable=bad-docstring-quotes
+    @deprecate_function(
+        "0.6.0",
+        additional_msg=(
+            ". This function is deprecated because it will be removed from the public API. It is "
+            "no longer necessary to be used when working directly with QubitMapper objects outside "
+            "a QubitConverter because a TaperedQubitMapper can now be obtained using the new "
+            "get_tapered_mapper function provided by the problem classes"
+        ),
+    )
+    def symmetry_sector_locator(
+        self,
+        z2_symmetries: OpflowZ2Symmetries | Z2Symmetries,
+        converter: QubitConverter | QubitMapper,
+    ) -> list[int] | None:
+        # pylint: disable=unused-argument
+        """Given the detected Z2Symmetries, it can determine the correct sector of the tapered
+        operators so the correct one can be returned
+
+        Args:
+            z2_symmetries: the z2 symmetries object.
+            converter: the ``QubitConverter`` or ``QubitMapper`` instance used for the operator
+                conversion that symmetries are to be determined for.
+
         Returns:
-            QuantumCircuit: a quantum circuit preparing the VSCF initial state
-            given a number of modals per mode and a qubit converter.
+            the sector of the tapered operators with the problem solution
         """
-        if self._is_built:
-            return
+        return None
+
+    def _symmetry_sector_locator(
+        self,
+        z2_symmetries: OpflowZ2Symmetries | Z2Symmetries,
+        mapper: QubitConverter | QubitMapper,
+    ) -> list[int] | None:
+        # pylint: disable=unused-argument
+        """Given the detected Z2Symmetries, it can determine the correct sector of the tapered
+        operators so the correct one can be returned
 
-        super()._build()
+        Args:
+            z2_symmetries: the z2 symmetries object.
+            mapper: the ``QubitMapper`` or ``QubitConverter`` instance (use of the latter is
+                deprecated) used for the operator conversion that symmetries are to be determined
+                for.
 
-        # Construct the circuit for bitstring. Since this is defined as an initial state
-        # circuit its assumed that this is applied first to the qubits that are initialized to
-        # the zero state. Hence we just need to account for all True entries and set those.
-        if self._bitstr is not None:
-            for i, bit in enumerate(self._bitstr):
-                if bit:
-                    self.x(i)
-
-
-def vscf_bitstring_mapped(
-    num_modals: list[int],
-    qubit_converter: QubitConverter,
-) -> list[bool]:
-    """Compute the bitstring representing the mapped VSCF initial state
-    based on the given the number of modals per mode and qubit converter.
-
-    Args:
-        num_modals: A list defining the number of modals per mode. E.g. for a 3 modes system
-            with 4 modals per mode num_modals = [4,4,4].
-        qubit_converter: A QubitConverter instance.
+        Returns:
+            the sector of the tapered operators with the problem solution
+        """
+        return None
 
-    Returns:
-        The bitstring representing the mapped state of the VSCF initial state as array of bools.
-    """
+    def get_tapered_mapper(self, mapper: QubitMapper) -> TaperedQubitMapper:
+        """Builds a ``TaperedQubitMapper`` from one of the mappers.
+        This simplifies the identification of the Pauli operator symmetries and of the symmetry sector
+        in which lies the solution of the problem.
 
-    # get the bitstring encoding initial state
-    bitstr = vscf_bitstring(num_modals)
+        Args:
+            mapper: ``QubitMapper`` object implementing the mapping of second quantized operators to
+                Pauli operators.
 
-    # encode the bitstring in a `VibrationalOp`
-    bitstr_op = VibrationalOp(
-        {
-            " ".join(
-                f"+_{VibrationalOp.build_dual_index(num_modals, idx)}"
-                for idx, bit in enumerate(bitstr)
-                if bit
-            ): 1.0
-        },
-        num_modals=num_modals,
-    )
-    # map the `VibrationalOp` to a qubit operator
-    qubit_op: PauliSumOp = qubit_converter.convert_match(bitstr_op, check_commutes=False)
+        Raises:
+            ValueError: If the mapper is a ``TaperedQubitMapper``.
 
-    # We check the mapped operator `x` part of the paulis because we want to have particles
-    # i.e. True, where the initial state introduced a creation (`+`) operator.
-    bits = []
-    for bit in qubit_op.primitive.paulis.x[0]:
-        bits.append(bit)
+        Returns:
+            A ``TaperedQubitMapper`` with pre-built symmetry specifications.
+        """
+        if isinstance(mapper, TaperedQubitMapper):
+            raise ValueError(
+                "TaperedQubitMapper instance cannot be built from another "
+                "TaperedQubitMapper. If you want to update your TaperedQubitMapper "
+                "instance please build a new one starting from the standard mappers."
+            )
 
-    return bits
+        qubit_op, _ = self.second_q_ops()
+        mapped_op = mapper.map(qubit_op)
+        if isinstance(mapped_op, PauliSumOp):
+            mapped_op = mapped_op.primitive
+        z2_symmetries = Z2Symmetries.find_z2_symmetries(mapped_op)
+        # pylint: disable=assignment-from-none
+        # Known issue for abstract class methods https://github.com/PyCQA/pylint/issues/2559
+        tapering_values = self._symmetry_sector_locator(z2_symmetries, mapper)
+        z2_symmetries.tapering_values = tapering_values
+        return TaperedQubitMapper(mapper, z2_symmetries)
 
+    def interpret(
+        self,
+        raw_result: EigenstateResult | EigensolverResult | MinimumEigensolverResult,
+    ) -> EigenstateResult:
+        """Interprets an EigenstateResult in the context of this problem.
 
-def vscf_bitstring(num_modals: list[int]) -> list[bool]:
-    """Compute the bitstring representing the VSCF initial state based on the modals per mode.
+        Args:
+            raw_result: an eigenstate result object.
 
-    Args:
-        num_modals: Is a list defining the number of modals per mode. E.g. for a 3 modes system
-            with 4 modals per mode num_modals = [4,4,4].
+        Returns:
+            An interpreted `EigenstateResult` in the form of a subclass of it. The actual type
+            depends on the problem that implements this method.
+        """
+        return EigenstateResult.from_result(raw_result)
 
-    Returns:
-        The bitstring representing the state of the VSCF state as array of bools.
-    """
-    num_qubits = sum(num_modals)
-    bitstr = np.zeros(num_qubits, bool)
-    count = 0
-    for modal in num_modals:
-        bitstr[count] = True
-        count += modal
+    def get_default_filter_criterion(
+        self,
+    ) -> Callable[[list | np.ndarray, float, list[float] | None], bool] | None:
+        """Returns a default filter criterion method to filter the eigenvalues computed by the
+        eigen solver. For more information see also
+        qiskit.algorithms.eigen_solvers.NumPyEigensolver.filter_criterion.
 
-    return bitstr.tolist()
+        In the fermionic case the default filter ensures that the number of particles is being
+        preserved.
+        """
+        return None
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/base_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/base_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/electronic_structure_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/electronic_structure_driver.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -29,14 +29,15 @@
     QCModel,
     QCProperties,
     QCProvenance,
     QCSchema,
     QCTopology,
     QCWavefunction,
 )
+from qiskit_nature.second_q.operators import Tensor
 from qiskit_nature.second_q.problems import ElectronicBasis, ElectronicStructureProblem
 
 from .base_driver import BaseDriver
 
 
 @dataclass
 class _QCSchemaData:
@@ -230,14 +231,18 @@
         properties.calcinfo_nbeta = data.nbeta
         properties.return_energy = data.e_ref
         properties.nuclear_repulsion_energy = data.e_nuc
         properties.nuclear_dipole_moment = data.dip_nuc
         properties.scf_dipole_moment = data.dip_ref
 
         def format_np_array(arr):
+            if isinstance(arr, Tensor):
+                # NOTE: this also deals with symmetry-reduced integral classes and ensures that
+                # they are not automatically unfolded to 1-fold symmetry
+                arr = arr.array
             return arr.ravel().tolist()
 
         wavefunction = QCWavefunction(basis=data.basis)
         if data.mo_coeff is not None:
             wavefunction.orbitals_a = "scf_orbitals_a"
             wavefunction.scf_orbitals_a = format_np_array(data.mo_coeff)
         if data.mo_coeff_b is not None:
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/LICENSE.txt` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/QCMatEl.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/QCMatEl.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/QCOpMat.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/QCOpMat.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.F` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.F`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussian_forces_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussian_forces_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_result.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_result.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -16,33 +16,35 @@
 
 import math
 from typing import List, Sequence, Tuple, Union, cast
 import copy
 import logging
 import re
 
+import numpy as np
+
 from qiskit_nature.second_q.formats.watson import WatsonHamiltonian
 import qiskit_nature.optionals as _optionals
 
 if _optionals.HAS_SPARSE:
     # pylint: disable=import-error
     from sparse import as_coo
 else:
 
     def as_coo(*args):
         """Empty as_coo function
         Replacement if sparse.as_coo is not present.
         """
         del args
+        return 0
 
 
 logger = logging.getLogger(__name__)
 
 
-@_optionals.HAS_SPARSE.require_in_instance
 class GaussianLogResult:
     """Result for Gaussian™ 16 log driver.
 
     This result allows access to selected data from the log file that is not available
     via the use Gaussian 16 interfacing code when using the MatrixElement file.
     Since this parses the text output it is subject to the format of the log file.
     """
@@ -270,14 +272,32 @@
         )
         quartic_data, quartic_max_index = self._force_constants_array(
             self.quartic_force_constants, factor=4.0, normalize=normalize
         )
 
         max_index = max(quadratic_max_index, cubic_max_index, quartic_max_index)
 
-        watson = WatsonHamiltonian(
-            as_coo(quadratic_data, shape=(max_index,) * 2),
-            as_coo(cubic_data, shape=(max_index,) * 3),
-            as_coo(quartic_data, shape=(max_index,) * 4),
-            -as_coo(quadratic_data, shape=(max_index,) * 2),
-        )
+        if _optionals.HAS_SPARSE:
+            watson = WatsonHamiltonian(
+                as_coo(quadratic_data, shape=(max_index,) * 2),
+                as_coo(cubic_data, shape=(max_index,) * 3),
+                as_coo(quartic_data, shape=(max_index,) * 4),
+                -as_coo(quadratic_data, shape=(max_index,) * 2),
+            )
+        else:
+            quadratic_numpy = np.zeros((max_index,) * 2)
+            for coord, value in quadratic_data.items():
+                quadratic_numpy[coord] = value
+            cubic_numpy = np.zeros((max_index,) * 3)
+            for coord, value in cubic_data.items():
+                cubic_numpy[coord] = value
+            quartic_numpy = np.zeros((max_index,) * 4)
+            for coord, value in quartic_data.items():
+                quartic_numpy[coord] = value
+            watson = WatsonHamiltonian(
+                quadratic_numpy,
+                cubic_numpy,
+                quartic_numpy,
+                -quadratic_numpy,
+            )
+
         return watson
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussian_utils.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussian_utils.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/gaussiand/gaussiandriver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/gaussiand/gaussiandriver.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -29,14 +29,15 @@
 from qiskit_nature.exceptions import UnsupportMethodError
 import qiskit_nature.optionals as _optionals
 from qiskit_nature.settings import settings
 from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
 from qiskit_nature.second_q.formats.qcschema import QCSchema
 from qiskit_nature.second_q.formats.qcschema_translator import qcschema_to_problem
 from qiskit_nature.second_q.problems import ElectronicBasis, ElectronicStructureProblem
+from qiskit_nature.utils import get_einsum
 
 from .gaussian_utils import run_g16
 from ..electronic_structure_driver import ElectronicStructureDriver, MethodType, _QCSchemaData
 
 if TYPE_CHECKING:
     from .gauopen.QCMatEl import MatEl
 
@@ -289,14 +290,15 @@
         return _mel
 
     def to_qcschema(self, *, include_dipole: bool = True) -> QCSchema:
         return GaussianDriver._qcschema_from_matrix_file(self._mel, include_dipole=include_dipole)
 
     @staticmethod
     def _qcschema_from_matrix_file(mel: MatEl, *, include_dipole: bool = True) -> QCSchema:
+        einsum_func, _ = get_einsum()
         data = _QCSchemaData()
 
         data.mo_coeff = GaussianDriver._get_matrix(mel, "ALPHA MO COEFFICIENTS")
         data.mo_coeff_b = GaussianDriver._get_matrix(mel, "BETA MO COEFFICIENTS")
         if np.array_equal(data.mo_coeff, data.mo_coeff_b):
             logger.debug("ALPHA and BETA MO COEFFS identical, keeping only ALPHA")
             data.mo_coeff_b = None
@@ -317,14 +319,18 @@
         data.hij_mo = np.dot(np.dot(data.mo_coeff.T, data.hij), data.mo_coeff)
         if data.mo_coeff_b is not None:
             data.hij_mo_b = np.dot(
                 np.dot(data.mo_coeff_b.T, data.hij_b if data.hij_b is not None else data.hij),
                 data.mo_coeff_b,
             )
 
+        # TODO: add support for symmetry-reduced integrals
+        # NOTE: supporting this will likely require changes to the _augment_config method where we
+        # currently enforce Symm=NoInt. Support for symmetry-reduced integrals in the matrix file
+        # produced by Gaussian will need to be investigated.
         data.eri = GaussianDriver._get_matrix(mel, "REGULAR 2E INTEGRALS")
         logger.debug("REGULAR 2E INTEGRALS %s", data.eri.shape)
         useao2e = False
         if data.mo_coeff_b is None and mel.matlist.get("BB MO 2E INTEGRALS") is not None:
             # It seems that when using ROHF, where alpha and beta coeffs are
             # the same, that integrals
             # for BB and BA are included in the output, as well as just AA
@@ -337,34 +343,34 @@
             logger.info(
                 "Identical A and B coeffs but BB ints are present - using regular 2E ints instead"
             )
         if useao2e:
             # eri are 2-body in AO. We can convert to MO via the ElectronicBasisTransform but using
             # ints in MO already, as in the else here, is better
             einsum_ao_to_mo = "pqrs,pi,qj,rk,sl->ijkl"
-            data.eri_mo = np.einsum(
+            data.eri_mo = einsum_func(
                 einsum_ao_to_mo,
                 data.eri,
                 data.mo_coeff,
                 data.mo_coeff,
                 data.mo_coeff,
                 data.mo_coeff,
                 optimize=settings.optimize_einsum,
             )
             if data.mo_coeff_b is not None:
-                data.eri_mo_ba = np.einsum(
+                data.eri_mo_ba = einsum_func(
                     einsum_ao_to_mo,
                     data.eri,
                     data.mo_coeff_b,
                     data.mo_coeff_b,
                     data.mo_coeff,
                     data.mo_coeff,
                     optimize=settings.optimize_einsum,
                 )
-                data.eri_mo_bb = np.einsum(
+                data.eri_mo_bb = einsum_func(
                     einsum_ao_to_mo,
                     data.eri,
                     data.mo_coeff_b,
                     data.mo_coeff_b,
                     data.mo_coeff_b,
                     data.mo_coeff_b,
                     optimize=settings.optimize_einsum,
@@ -404,29 +410,29 @@
         data.nmo = data.mo_coeff.shape[0]
         data.nalpha = (mel.ne + mel.multip - 1) // 2
         data.nbeta = (mel.ne - mel.multip + 1) // 2
 
         if include_dipole:
             # dipole moment
             dipints = GaussianDriver._get_matrix(mel, "DIPOLE INTEGRALS")
-            dipints = np.einsum("ijk->kji", dipints)
+            dipints = einsum_func("ijk->kji", dipints)
 
             data.dip_x = dipints[0]
             data.dip_y = dipints[1]
             data.dip_z = dipints[2]
             data.dip_mo_x_a = np.dot(np.dot(data.mo_coeff.T, data.dip_x), data.mo_coeff)
             data.dip_mo_y_a = np.dot(np.dot(data.mo_coeff.T, data.dip_y), data.mo_coeff)
             data.dip_mo_z_a = np.dot(np.dot(data.mo_coeff.T, data.dip_z), data.mo_coeff)
             if data.mo_coeff_b is not None:
                 data.dip_mo_x_b = np.dot(np.dot(data.mo_coeff_b.T, data.dip_x), data.mo_coeff_b)
                 data.dip_mo_y_b = np.dot(np.dot(data.mo_coeff_b.T, data.dip_y), data.mo_coeff_b)
                 data.dip_mo_z_b = np.dot(np.dot(data.mo_coeff_b.T, data.dip_z), data.mo_coeff_b)
 
             coords = np.reshape(mel.c, (len(mel.ian), 3))
-            nucl_dip = np.einsum("i,ix->x", mel.ian, coords)
+            nucl_dip = einsum_func("i,ix->x", mel.ian, coords)
             nucl_dip = np.round(nucl_dip, decimals=8)
             ref_dip = GaussianDriver._get_matrix(mel, "ELECTRIC DIPOLE MOMENT")
             ref_dip = np.round(ref_dip, decimals=8)
             elec_dip = ref_dip - nucl_dip
 
             logger.info("HF Electronic dipole moment: %s", elec_dip)
             logger.info("Nuclear dipole moment: %s", nucl_dip)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/psi4d/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/psi4d/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/psi4d/_template.txt` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/psi4d/_template.txt`

 * *Files 4% similar despite different names*

```diff
@@ -11,22 +11,23 @@
 _has_B   = not _q_hf_wavefn.same_a_b_orbs()
 _q_h1 = _q_hf_wavefn.H()
 _q_h1b = _q_h1.clone() if _has_B else None
 
 data = _QCSchemaData()
 data.hij = np.asarray(_q_h1.clone())
 data.hij_b = None
-data.eri = np.asarray(_q_mints.ao_eri())
 _q_h1.transform(_q_hf_wavefn.Ca())
 data.hij_mo = np.asarray(_q_h1)
 data.hij_mo_b = None
 if _has_B:
     _q_h1b.transform(_q_hf_wavefn.Cb())
     data.hij_mo_b = np.asarray(_q_h1b)
 
+# TODO: add support for symmetry-reduced integrals
+data.eri = np.asarray(_q_mints.ao_eri())
 data.eri_mo = np.asarray(_q_mints.mo_eri(_q_hf_wavefn.Ca(), _q_hf_wavefn.Ca(),
                                          _q_hf_wavefn.Ca(), _q_hf_wavefn.Ca()))
 data.eri_mo_ba = None
 data.eri_mo_bb = None
 if _has_B:
     data.eri_mo_bb = np.asarray(_q_mints.mo_eri(_q_hf_wavefn.Cb(), _q_hf_wavefn.Cb(),
                                                 _q_hf_wavefn.Cb(), _q_hf_wavefn.Cb()))
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/psi4d/psi4driver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/psi4d/psi4driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/pyscfd/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/pyscfd/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/pyscfd/pyscfdriver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/pyscfd/pyscfdriver.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -26,17 +26,19 @@
 from qiskit.utils.validation import validate_min
 
 from qiskit_nature.units import DistanceUnit
 from qiskit_nature.exceptions import QiskitNatureError
 from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
 from qiskit_nature.second_q.formats.qcschema import QCSchema
 from qiskit_nature.second_q.formats.qcschema_translator import qcschema_to_problem
+from qiskit_nature.second_q.operators.symmetric_two_body import fold
 from qiskit_nature.second_q.problems import ElectronicBasis, ElectronicStructureProblem
 from qiskit_nature.settings import settings
 import qiskit_nature.optionals as _optionals
+from qiskit_nature.utils import get_einsum
 
 from ..electronic_structure_driver import ElectronicStructureDriver, MethodType, _QCSchemaData
 
 logger = logging.getLogger(__name__)
 
 warnings.filterwarnings("ignore", category=DeprecationWarning, module="pyscf")
 
@@ -501,22 +503,25 @@
                 self._calc.converged,
                 self._calc.e_tot,
             )
 
     def to_qcschema(self, *, include_dipole: bool = True) -> QCSchema:
         # pylint: disable=import-error
         from pyscf import __version__ as pyscf_version
-        from pyscf import gto
+        from pyscf import ao2mo, gto
         from pyscf.tools import dump_mat
 
+        einsum_func, _ = get_einsum()
         data = _QCSchemaData()
 
-        data.mo_coeff, data.mo_coeff_b = self._extract_mo_data("mo_coeff", array_dimension=3)
-        data.mo_energy, data.mo_energy_b = self._extract_mo_data("mo_energy")
-        data.mo_occ, data.mo_occ_b = self._extract_mo_data("mo_occ")
+        data.mo_coeff, data.mo_coeff_b = self._expand_mo_object(
+            self._calc.mo_coeff, array_dimension=3
+        )
+        data.mo_energy, data.mo_energy_b = self._expand_mo_object(self._calc.mo_energy)
+        data.mo_occ, data.mo_occ_b = self._expand_mo_object(self._calc.mo_occ)
 
         if logger.isEnabledFor(logging.DEBUG):
             # Add some more to PySCF output...
             # First analyze() which prints extra information about MO energy and occupation
             self._mol.stdout.write("\n")
             self._calc.analyze()
             # Now labelled orbitals for contributions to the MOs for s,p,d etc of each atom
@@ -527,44 +532,58 @@
                 dump_mat.dump_mo(self._mol, data.mo_coeff_b, digits=7, start=1)
             self._mol.stdout.flush()
 
         data.hij = self._calc.get_hcore()
         data.hij_mo = np.dot(np.dot(data.mo_coeff.T, data.hij), data.mo_coeff)
         if data.mo_coeff_b is not None:
             data.hij_mo_b = np.dot(np.dot(data.mo_coeff_b.T, data.hij), data.mo_coeff_b)
-        data.eri = self._mol.intor("int2e", aosym=1)
+
         einsum_ao_to_mo = "pqrs,pi,qj,rk,sl->ijkl"
-        data.eri_mo = np.einsum(
-            einsum_ao_to_mo,
-            data.eri,
-            data.mo_coeff,
-            data.mo_coeff,
-            data.mo_coeff,
-            data.mo_coeff,
-            optimize=settings.optimize_einsum,
-        )
-        if data.mo_coeff_b is not None:
-            data.eri_mo_ba = np.einsum(
+        if settings.use_symmetry_reduced_integrals:
+            data.eri = self._mol.intor("int2e", aosym=8)
+            data.eri_mo = fold(ao2mo.full(self._mol, data.mo_coeff, aosym=4))
+            if data.mo_coeff_b is not None:
+                data.eri_mo_bb = fold(ao2mo.full(self._mol, data.mo_coeff_b, aosym=4))
+                data.eri_mo_ba = fold(
+                    ao2mo.general(
+                        self._mol,
+                        [data.mo_coeff_b, data.mo_coeff_b, data.mo_coeff, data.mo_coeff],
+                        aosym=4,
+                    )
+                )
+        else:
+            data.eri = self._mol.intor("int2e", aosym=1)
+            data.eri_mo = einsum_func(
                 einsum_ao_to_mo,
                 data.eri,
-                data.mo_coeff_b,
-                data.mo_coeff_b,
+                data.mo_coeff,
+                data.mo_coeff,
                 data.mo_coeff,
                 data.mo_coeff,
                 optimize=settings.optimize_einsum,
             )
-            data.eri_mo_bb = np.einsum(
-                einsum_ao_to_mo,
-                data.eri,
-                data.mo_coeff_b,
-                data.mo_coeff_b,
-                data.mo_coeff_b,
-                data.mo_coeff_b,
-                optimize=settings.optimize_einsum,
-            )
+            if data.mo_coeff_b is not None:
+                data.eri_mo_ba = einsum_func(
+                    einsum_ao_to_mo,
+                    data.eri,
+                    data.mo_coeff_b,
+                    data.mo_coeff_b,
+                    data.mo_coeff,
+                    data.mo_coeff,
+                    optimize=settings.optimize_einsum,
+                )
+                data.eri_mo_bb = einsum_func(
+                    einsum_ao_to_mo,
+                    data.eri,
+                    data.mo_coeff_b,
+                    data.mo_coeff_b,
+                    data.mo_coeff_b,
+                    data.mo_coeff_b,
+                    optimize=settings.optimize_einsum,
+                )
 
         data.e_nuc = gto.mole.energy_nuc(self._mol)
         data.e_ref = self._calc.e_tot
         data.symbols = [self._mol.atom_pure_symbol(i) for i in range(self._mol.natm)]
         data.coords = self._mol.atom_coords(unit="Bohr").ravel().tolist()
         data.multiplicity = self._spin + 1
         data.charge = self._charge
@@ -583,17 +602,17 @@
             ao_dip = self._mol.intor_symmetric("int1e_r", comp=3)
 
             d_m = self._calc.make_rdm1(self._calc.mo_coeff, self._calc.mo_occ)
 
             if not (isinstance(d_m, np.ndarray) and d_m.ndim == 2):
                 d_m = d_m[0] + d_m[1]
 
-            elec_dip = np.negative(np.einsum("xij,ji->x", ao_dip, d_m).real)
+            elec_dip = np.negative(einsum_func("xij,ji->x", ao_dip, d_m).real)
             elec_dip = np.round(elec_dip, decimals=8)
-            nucl_dip = np.einsum("i,ix->x", self._mol.atom_charges(), self._mol.atom_coords())
+            nucl_dip = einsum_func("i,ix->x", self._mol.atom_charges(), self._mol.atom_coords())
             nucl_dip = np.round(nucl_dip, decimals=8)
             ref_dip = nucl_dip + elec_dip
 
             logger.info("HF Electronic dipole moment: %s", elec_dip)
             logger.info("Nuclear dipole moment: %s", nucl_dip)
             logger.info("Total dipole moment: %s", ref_dip)
             data.dip_nuc = nucl_dip
@@ -623,44 +642,40 @@
         problem = qcschema_to_problem(qcschema, basis=basis, include_dipole=include_dipole)
 
         if include_dipole and problem.properties.electronic_dipole_moment is not None:
             problem.properties.electronic_dipole_moment.reverse_dipole_sign = True
 
         return problem
 
-    def _extract_mo_data(
-        self, name: str, array_dimension: int = 2
+    def _expand_mo_object(
+        self,
+        mo_object: tuple[np.ndarray | None, np.ndarray | None] | np.ndarray,
+        array_dimension: int = 2,
     ) -> tuple[np.ndarray, np.ndarray]:
-        """Extract molecular orbital data from a PySCF calculation object.
+        """Expands the molecular orbital object into alpha- and beta-spin components.
+
+        Since PySCF 1.6.2, the alpha and beta components are no longer stored as a tuple but as a
+        multi-dimensional numpy array. This utility takes care of differentiating these cases.
 
         Args:
-            name: the name of the molecular orbital data field to extract.
-            array_dimension: since PySCF 1.6.2, the alpha and beta components are no longer stored
-                as a tuple but as a multi-dimensional numpy array. This argument specifies the
-                dimension of that array in such a case. Making this configurable permits this
-                function to be used to extract both, MO coefficients (3D array) and MO energies (2D
-                array).
+            mo_object: the molecular orbital object to expand.
+            array_dimension:  This argument specifies the dimension of the numpy array (if a tuple
+                is not encountered). Making this configurable permits this function to be used to
+                expand both, MO coefficients (3D array) and MO energies (2D array).
 
         Returns:
             The (alpha, beta) tuple of MO data.
         """
-        attr = getattr(self._calc, name)
-        if isinstance(attr, tuple):
-            attr_alpha = attr[0]
-            attr_beta = attr[1]
-        else:
-            # Since PySCF 1.6.2, instead of a tuple it could be a multi-dimensional array with the
-            # first dimension indexing the arrays for alpha and beta
-            if len(attr.shape) == array_dimension:
-                attr_alpha = attr[0]
-                attr_beta = attr[1]
-            else:
-                attr_alpha = attr
-                attr_beta = None
-        return attr_alpha, attr_beta
+        if isinstance(mo_object, tuple):
+            return mo_object
+
+        if len(mo_object.shape) == array_dimension:
+            return mo_object[0], mo_object[1]
+
+        return mo_object, None
 
     def _process_pyscf_log(self, logfile: str) -> None:
         """Processes a PySCF logfile.
 
         Args:
             logfile: the path of the PySCF logfile.
         """
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/drivers/vibrational_structure_driver.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/drivers/vibrational_structure_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump/dumper.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump/dumper.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -37,14 +37,16 @@
 
 def _dump_2e_ints(
     hijkl: np.ndarray, mos: Union[range, List[int]], outfile: TextIO, beta: int = 0
 ) -> None:
     idx_offsets = [1, 1]
     for b in range(beta):
         idx_offsets[1 - b] += len(mos)
+
+    # TODO: refactor to leverage symmetry-reduced integral containers
     hijkl_elements = set()
     for elem in itertools.product(mos, repeat=4):
         if np.isclose(hijkl[elem], 0.0, atol=1e-14):
             continue
         if len(set(elem)) == 1:
             _write_to_outfile(
                 outfile,
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/fcidump_translator.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/fcidump_translator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/molecule_info.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/molecule_info.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_base.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_base.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,32 +1,33 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """The QCSchema Base class."""
 # pylint: disable=invalid-name
 
 from __future__ import annotations
 
-from dataclasses import asdict
+from dataclasses import asdict, dataclass
 from pathlib import Path
 from typing import Any
 
 import json
 import h5py
 
 
+@dataclass
 class _QCBase:
     """A base class for the QCSchema dataclasses.
 
     This base class is used to implement schema-wide conversion utility methods.
     """
 
     def to_dict(self) -> dict[str, Any]:
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_basis_set.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_basis_set.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_error.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_error.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_model.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_properties.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_properties.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_provenance.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_provenance.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_schema.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_schema.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_schema_input.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_schema_input.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_topology.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_topology.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema/qc_wavefunction.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema/qc_wavefunction.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/qcschema_translator.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/qcschema_translator.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -18,21 +18,27 @@
 
 import numpy as np
 
 from qiskit_nature.units import DistanceUnit
 from qiskit_nature.second_q.problems import ElectronicBasis, ElectronicStructureProblem
 from qiskit_nature.second_q.hamiltonians import ElectronicEnergy
 from qiskit_nature.second_q.operators import ElectronicIntegrals
+from qiskit_nature.second_q.operators.symmetric_two_body import (
+    S1Integrals,
+    S4Integrals,
+    S8Integrals,
+)
 from qiskit_nature.second_q.properties import (
     AngularMomentum,
     ElectronicDipoleMoment,
     Magnetization,
     ParticleNumber,
 )
 from qiskit_nature.second_q.transformers import BasisTransformer
+from qiskit_nature.settings import settings
 
 from .molecule_info import MoleculeInfo
 from .qcschema import QCSchema
 
 
 def qcschema_to_problem(
     qcschema: QCSchema,
@@ -125,53 +131,68 @@
 
 
 def _reshape_2(arr, dim, dim_2=None):
     return np.asarray(arr).reshape((dim, dim_2 if dim_2 is not None else dim))
 
 
 def _reshape_4(arr, dim):
-    return np.asarray(arr).reshape((dim,) * 4)
+    npair = dim * (dim + 1) // 2
+
+    if len(arr) == npair * (npair + 1) // 2:
+        return S8Integrals(np.asarray(arr))
+
+    if len(arr) == npair**2:
+        return S4Integrals(np.asarray(arr).reshape((npair,) * 2))
+
+    if len(arr) == dim**4:
+        if not settings.use_symmetry_reduced_integrals:
+            return np.asarray(arr).reshape((dim,) * 4)
+        return S1Integrals(np.asarray(arr).reshape((dim,) * 4))
+
+    return arr
 
 
-def _get_ao_hamiltonian(qcschema) -> ElectronicEnergy:
+def _get_ao_hamiltonian(qcschema: QCSchema) -> ElectronicEnergy:
     nao = int(np.sqrt(len(qcschema.wavefunction.scf_fock_a)))
     hcore = _reshape_2(qcschema.wavefunction.scf_fock_a, nao)
     hcore_b = None
     if qcschema.wavefunction.scf_fock_b is not None:
         hcore_b = _reshape_2(qcschema.wavefunction.scf_fock_b, nao)
     eri = _reshape_4(qcschema.wavefunction.scf_eri, nao)
 
     hamiltonian = ElectronicEnergy.from_raw_integrals(hcore, eri, hcore_b)
 
     return hamiltonian
 
 
-def _get_mo_hamiltonian(qcschema) -> ElectronicEnergy:
+def _get_mo_hamiltonian(qcschema: QCSchema) -> ElectronicEnergy:
     if qcschema.wavefunction.scf_fock_mo_a is not None:
         return _get_mo_hamiltonian_direct(qcschema)
 
     hamiltonian = _get_ao_hamiltonian(qcschema)
     transformer = get_ao_to_mo_from_qcschema(qcschema)
 
     return cast(ElectronicEnergy, transformer.transform_hamiltonian(hamiltonian))
 
 
-def _get_mo_hamiltonian_direct(qcschema) -> ElectronicEnergy:
+def _get_mo_hamiltonian_direct(qcschema: QCSchema) -> ElectronicEnergy:
     norb = qcschema.properties.calcinfo_nmo
     hij = _reshape_2(qcschema.wavefunction.scf_fock_mo_a, norb)
     hijkl = _reshape_4(qcschema.wavefunction.scf_eri_mo_aa, norb)
     hij_b = None
     hijkl_bb = None
     hijkl_ba = None
     if qcschema.wavefunction.scf_fock_mo_b is not None:
         hij_b = _reshape_2(qcschema.wavefunction.scf_fock_mo_b, norb)
     if qcschema.wavefunction.scf_eri_mo_bb is not None:
         hijkl_bb = _reshape_4(qcschema.wavefunction.scf_eri_mo_bb, norb)
     if qcschema.wavefunction.scf_eri_mo_ba is not None:
         hijkl_ba = _reshape_4(qcschema.wavefunction.scf_eri_mo_ba, norb)
+    if qcschema.wavefunction.scf_eri_mo_ab is not None and hijkl_ba is None:
+        hijkl_ba = np.transpose(_reshape_4(qcschema.wavefunction.scf_eri_mo_ab, norb))
 
     hamiltonian = ElectronicEnergy.from_raw_integrals(hij, hijkl, hij_b, hijkl_bb, hijkl_ba)
 
     return hamiltonian
 
 
 def _get_ao_dipole(qcschema, axis) -> ElectronicIntegrals | None:
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/watson/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/watson/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/watson/watson_hamiltonian.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/watson/watson_hamiltonian.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -19,31 +19,30 @@
 
 import numpy as np
 
 import qiskit_nature.optionals as _optionals
 
 if _optionals.HAS_SPARSE:
     # pylint: disable=import-error
-    from sparse import COO, SparseArray
+    from sparse import SparseArray, as_coo
 else:
 
-    class COO:  # type: ignore
-        """Empty COO class
-        Replacement if sparse.COO is not present.
-        """
-
-        pass
-
     class SparseArray:  # type: ignore
         """Empty SparseArray class
         Replacement if sparse.SparseArray is not present.
         """
 
         pass
 
+    def as_coo(*args):
+        """Empty as_coo function
+        Replacement if sparse.as_coo is not present.
+        """
+        del args
+
 
 @dataclass
 class WatsonHamiltonian:
     r"""A dataclass for the force and kinetic coefficients describing a Watson Hamiltonian.
 
     .. math::
         \mathcal{H}_{vib}(Q_1, \ldots, Q_L) =
@@ -71,15 +70,15 @@
     ) -> Generator[tuple[complex, tuple[int, ...]], None, None]:
         if isinstance(array, np.ndarray):
             for index in np.ndindex(*array.shape):
                 value = array[index]
                 if value:
                     yield value, tuple((-1) ** kinetic * (i + 1) for i in index)
         elif isinstance(array, SparseArray):
-            coo = COO(array)
+            coo = as_coo(array)
             for value, *index in zip(coo.data, *coo.coords):
                 yield value, tuple((-1) ** kinetic * (i + 1) for i in index)
 
     def __iter__(self) -> Generator[tuple[complex, tuple[int, ...]], None, None]:
         for value, index in self._iter_array(self.quadratic_force_constants):
             yield value, index
         for value, index in self._iter_array(self.cubic_force_constants):
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/formats/watson_translator.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/formats/watson_translator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/electronic_energy.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/electronic_energy.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -16,15 +16,20 @@
 
 from copy import copy
 from typing import MutableMapping
 
 import numpy as np
 
 import qiskit_nature  # pylint: disable=unused-import
-from qiskit_nature.second_q.operators import ElectronicIntegrals, FermionicOp, PolynomialTensor
+from qiskit_nature.second_q.operators import (
+    ElectronicIntegrals,
+    FermionicOp,
+    PolynomialTensor,
+    Tensor,
+)
 
 from .hamiltonian import Hamiltonian
 
 
 class ElectronicEnergy(Hamiltonian):
     r"""The electronic energy Hamiltonian.
 
@@ -214,29 +219,40 @@
             J_{qr} = \sum g_{pqrs} D_{ps}
 
         Args:
             density: the reduced density matrix.
 
         Returns:
             The Coulomb operator coefficients.
+
+        Raises:
+            NotImplementedError: when encountering :class:`.SymmetricTwoBodyIntegrals` inside of
+                :attr:`.ElectronicEnergy.electronic_integrals`.
         """
+        two_body_aa = self.electronic_integrals.alpha.get("++--", None)
+        # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+        if not isinstance(two_body_aa, Tensor):
+            two_body_aa = Tensor(two_body_aa)
+
+        einsum = f"{''.join(two_body_aa._reverse_label_template('pqrs'))},ps->qr"
         coulomb = ElectronicIntegrals.einsum(
-            {"pqrs,ps->qr": ("++--", "+-", "+-")}, self.electronic_integrals, density
+            {einsum: ("++--", "+-", "+-")}, self.electronic_integrals, density
         )
 
         if self.electronic_integrals.beta_alpha.is_empty():
             coulomb *= 2.0  # type: ignore
         else:
             coulomb.alpha += PolynomialTensor.einsum(
-                {"pqrs,ps->qr": ("++--", "+-", "+-")},
+                {einsum: ("++--", "+-", "+-")},
                 self.electronic_integrals.beta_alpha,
                 density.beta,
             )
+            einsum = einsum[2:4] + einsum[:2] + einsum[4:]
             coulomb.beta += PolynomialTensor.einsum(
-                {"rspq,ps->rq": ("++--", "+-", "+-")},
+                {einsum: ("++--", "+-", "+-")},
                 self.electronic_integrals.beta_alpha,
                 density.alpha,
             )
 
         return coulomb
 
     def exchange(self, density: ElectronicIntegrals) -> ElectronicIntegrals:
@@ -246,17 +262,27 @@
             K_{pr} = \sum g_{pqrs} D_{qs}
 
         Args:
             density: the reduced density matrix.
 
         Returns:
             The Exchange operator coefficients.
+
+        Raises:
+            NotImplementedError: when encountering :class:`.SymmetricTwoBodyIntegrals` inside of
+                :attr:`.ElectronicEnergy.electronic_integrals`.
         """
+        two_body_aa = self.electronic_integrals.alpha.get("++--", None)
+        # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+        if not isinstance(two_body_aa, Tensor):
+            two_body_aa = Tensor(two_body_aa)
+
+        einsum = f"{''.join(two_body_aa._reverse_label_template('pqrs'))},qs->pr"
         exchange = ElectronicIntegrals.einsum(
-            {"pqrs,qs->pr": ("++--", "+-", "+-")}, self.electronic_integrals, density
+            {einsum: ("++--", "+-", "+-")}, self.electronic_integrals, density
         )
         return exchange
 
     def fock(self, density: ElectronicIntegrals) -> ElectronicIntegrals:
         r"""Computes the Fock operator for the given reduced density matrix.
 
         .. math::
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/fermi_hubbard_model.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/fermi_hubbard_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/hamiltonian.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/hamiltonian.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/heisenberg_model.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/heisenberg_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/ising_model.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/ising_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattice_model.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattice_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/boundary_condition.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/boundary_condition.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/hyper_cubic_lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/hyper_cubic_lattice.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -26,15 +26,15 @@
 class HyperCubicLattice(Lattice):
     """Hyper-cubic lattice in :math:`d` dimensions.
 
     The :class:`HyperCubicLattice` can be initialized with
     tuples of `size`, `edge_parameters`, and `boundary_conditions`.
     For example,
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         from qiskit_nature.second_q.hamiltonians.lattices import (
             BoundaryCondition,
             HyperCubicLattice,
             )
 
         lattice = HyperCubicLattice(
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/line_lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/line_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/square_lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/square_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/lattices/triangular_lattice.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/lattices/triangular_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/quadratic_hamiltonian.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/quadratic_hamiltonian.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/hamiltonians/vibrational_energy.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/hamiltonians/vibrational_energy.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/bksf.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/bksf.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,31 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """The Bravyi-Kitaev Super-Fast (BKSF) Mapper."""
 
 from __future__ import annotations
 
 from enum import Enum
-from typing import List, Tuple
 import numpy as np
 
 from qiskit.opflow import PauliSumOp
-from qiskit.quantum_info.operators import Pauli, SparsePauliOp
+from qiskit.quantum_info import SparsePauliOp
+from qiskit.quantum_info.operators import Pauli
 
+from qiskit_nature import settings
 from qiskit_nature.second_q.operators import FermionicOp
 from .fermionic_mapper import FermionicMapper
 
 
 class BravyiKitaevSuperFastMapper(FermionicMapper):
     """The Bravyi-Kitaev super-fast fermion-to-qubit mapping.
 
@@ -32,33 +33,34 @@
 
     References:
         [1] Kanav Setia and James D. Whitfield, "Bravyi-Kitaev Superfast
         simulation of electronic structure on a quantum computer", J. Chem.
         Phys. 148, 164104 (2018). https://doi.org/10.1063/1.5019371
     """
 
-    def __init__(self):
-        """The BKSF mapping."""
-        super().__init__(allows_two_qubit_reduction=False)
+    def _map_single(
+        self, second_q_op: FermionicOp, *, register_length: int | None = None
+    ) -> SparsePauliOp | PauliSumOp:
+        if register_length is None:
+            register_length = second_q_op.register_length
 
-    def map(self, second_q_op: FermionicOp) -> PauliSumOp:
         if not isinstance(second_q_op, FermionicOp):
             raise TypeError("Type ", type(second_q_op), " not supported.")
 
-        edge_list = _bksf_edge_list_fermionic_op(second_q_op)
+        edge_list = _bksf_edge_list_fermionic_op(second_q_op, register_length)
         sparse_pauli = _convert_operator(second_q_op, edge_list)
 
         ## Simplify and sort the result
         sparse_pauli = sparse_pauli.simplify()
         indices = sparse_pauli.paulis.argsort()
         table = sparse_pauli.paulis[indices]
         coeffs = sparse_pauli.coeffs[indices]
         sorted_sparse_pauli = SparsePauliOp(table, coeffs)
 
-        return PauliSumOp(sorted_sparse_pauli)
+        return PauliSumOp(sorted_sparse_pauli) if settings.use_pauli_sum_op else sorted_sparse_pauli
 
 
 class TermType(Enum):
     """Denotes the type of interaction of a Fermionic operator."""
 
     NUMBER = 1
     EXCITATION = 2
@@ -150,15 +152,15 @@
         return qubit_op2
     elif qubit_op2 is None:
         return qubit_op1
     else:
         return qubit_op1 + qubit_op2
 
 
-def _analyze_term(terms: list[tuple[str, int]]) -> Tuple[TermType, List[Tuple[int, str]]]:
+def _analyze_term(terms: list[tuple[str, int]]) -> tuple[TermType, list[tuple[int, str]]]:
     """Return the type of interaction represented by `term_str` and
     a list of the factors and their indices in `term_str`.
 
     Args:
       terms: a list of pairs consisting of `+` or `-` chars and indices.
 
     Returns:
@@ -166,22 +168,22 @@
       `_interaction_type`. The second is a list of factors as returned by `_unpack_term`.
     """
     (n_number, n_raise, n_lower), facs = _unpack_term(terms, compress_number_op=False)
     _type = _interaction_type(n_number, n_raise, n_lower)
     return _type, facs
 
 
-def _operator_string(term: Tuple) -> list[tuple[str, int]]:
+def _operator_string(term: tuple) -> list[tuple[str, int]]:
     """Return the list of pairs describing the operators in the term extracted from a `FermionicOp`
     given by `term`.
     """
     return term[0]
 
 
-def _operator_coefficient(term: Tuple) -> float:
+def _operator_coefficient(term: tuple) -> float:
     """Return the coefficient of the multi-mode operator term extracted from a `FermionicOp`."""
     return term[1]
 
 
 def _pauli_id(n_qubits: int, coeff=None) -> SparsePauliOp:
     """Return the identity for `SparsePauliOp` on `n_qubits` qubits."""
     if coeff is None:
@@ -355,15 +357,15 @@
     else:
         raise ValueError(f"unexpected sequence of indices: {p}, {q}, {r}, {s}")
     return (final_coeff * h2_pqrs) * qubit_op
 
 
 def _unpack_term(
     terms: list[tuple[str, int]], compress_number_op: bool
-) -> Tuple[Tuple[int, int, int], List[Tuple[int, str]]]:
+) -> tuple[tuple[int, int, int], list[tuple[int, str]]]:
     """Return a tuple specifying the counts of kinds of operators in `term_str` and
     a list of the factors and their indices in `term_str`.
 
     The factors are represented by tuples of the form `(i, c)`, where `i` is an index
     and `c` is a character.
     Allowed characters in `term_str` are 'N+-I`.
     The returned tuple contains counts for `N`, `+`, and `-`, in that order. Identity operators
@@ -442,29 +444,29 @@
             raise ValueError("unexpected number of number operators: ", n_number)
     elif n_raise == 2 and n_lower == 2:
         return TermType.DOUBLE_EXCITATION
     else:
         raise ValueError(f"n_raise ({n_raise}) not equal to n_lower ({n_lower})")
 
 
-def _get_adjacency_matrix(fer_op: FermionicOp) -> np.ndarray:
+def _get_adjacency_matrix(fer_op: FermionicOp, register_length: int) -> np.ndarray:
     """Return an adjacency matrix specifying the edges in the BKSF graph for the
     operator `fer_op`.
 
     The graph is undirected, so we choose to return the edges in the upper triangle.
     (There are no self edges.) The lower triangle entries are all `False`.
 
     Args:
       fer_op: The Fermionic operator.
+      register_length: the register length of the operator.
 
     Returns:
       numpy.ndarray(dtype=bool): edge_matrix the adjacency matrix.
     """
-    n_modes = fer_op.register_length
-    edge_matrix = np.zeros((n_modes, n_modes), dtype=bool)
+    edge_matrix = np.zeros((register_length, register_length), dtype=bool)
     for term in fer_op.terms():
         if _operator_coefficient(term) != 0:
             _add_edges_for_term(edge_matrix, _operator_string(term))
     return edge_matrix
 
 
 def _add_one_edge(edge_matrix: np.ndarray, i: int, j: int) -> None:
@@ -501,27 +503,28 @@
     elif _type == TermType.DOUBLE_EXCITATION:
         raise_inds = [i for (i, c) in facs if c == "+"]
         lower_inds = [i for (i, c) in facs if c == "-"]
         _add_one_edge(edge_matrix, *raise_inds)
         _add_one_edge(edge_matrix, *lower_inds)
 
 
-def _bksf_edge_list_fermionic_op(ferm_op: FermionicOp) -> np.ndarray:
+def _bksf_edge_list_fermionic_op(ferm_op: FermionicOp, register_length: int) -> np.ndarray:
     """Construct edge list required for the BKSF algorithm.
 
     Args:
         ferm_op: the fermionic operator in the second quantized form
+        register_length: the register length of the operator.
 
     Returns:
         numpy.ndarray: edge_list, a 2xE matrix, where E is total number of edges.
                        The `i`th edge is given by `(edge_list[0, i], edge_list[1, i])`,
                        where the index `i` starts at zero.
 
     """
-    edge_matrix = _get_adjacency_matrix(ferm_op)
+    edge_matrix = _get_adjacency_matrix(ferm_op, register_length)
     edge_list_as_2d_array = np.asarray(np.nonzero(edge_matrix))
     return edge_list_as_2d_array
 
 
 def _edge_operator_aij(edge_list: np.ndarray, i: int, j: int) -> SparsePauliOp:
     """Return the edge operator A_ij.
 
@@ -579,15 +582,15 @@
     v = np.zeros(edge_list.shape[1])
     w = np.copy(v)
     v[qubit_position] = 1
     qubit_op = Pauli((v, w))
     return SparsePauliOp(qubit_op)
 
 
-def _to_physicist_index_order(facs: List[Tuple[int, str]]) -> Tuple[List[Tuple[int, str]], int]:
+def _to_physicist_index_order(facs: list[tuple[int, str]]) -> tuple[list[tuple[int, str]], int]:
     """Reorder the factors `facs` to be two raising operators followed by two lowering operators and
     return the new factors and the phase incurred by the reordering. Note that `facs` are not in
     chemists' order, but rather sorted by index with least index first.
 
     Args:
       facs: a list of factors where each element is `(i, c)` where `i` is an integer index and
         `c` is either `-` or `+`.
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/bravyi_kitaev_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/bravyi_kitaev_mapper.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -14,29 +14,30 @@
 
 from __future__ import annotations
 
 from functools import lru_cache
 
 import numpy as np
 
-from qiskit.opflow import PauliSumOp
 from qiskit.quantum_info.operators import Pauli
 
-from qiskit_nature.second_q.operators import FermionicOp
+from qiskit_nature.deprecation import deprecate_arguments
 from .fermionic_mapper import FermionicMapper
 
 
-class BravyiKitaevMapper(FermionicMapper):  # pylint: disable=missing-class-docstring
-    def __init__(self):
-        """The Bravyi-Kitaev fermion-to-qubit mapping."""
-        super().__init__(allows_two_qubit_reduction=False)
+class BravyiKitaevMapper(FermionicMapper):
+    """The Bravyi-Kitaev fermion-to-qubit mapping."""
 
     @classmethod
+    @deprecate_arguments("0.6.0", {"nmodes": "register_length"})
     @lru_cache(maxsize=32)
-    def pauli_table(cls, nmodes: int) -> list[tuple[Pauli, Pauli]]:
+    def pauli_table(
+        cls, register_length: int, *, nmodes: int | None = None
+    ) -> list[tuple[Pauli, Pauli]]:
+        # pylint: disable=unused-argument
         def parity_set(j, n):
             """
             Computes the parity set of the j-th orbital in n modes.
 
             Args:
                 j (int) : the orbital index
                 n (int) : the total number of modes
@@ -99,56 +100,70 @@
                     np.append(indices, flip_set(j - n / 2, n / 2) + n / 2), n / 2 - 1
                 )
             return indices
 
         pauli_table = []
         # FIND BINARY SUPERSET SIZE
         bin_sup = 1
-        while nmodes > np.power(2, bin_sup):
+        while register_length > np.power(2, bin_sup):
             bin_sup += 1
         # DEFINE INDEX SETS FOR EVERY FERMIONIC MODE
         update_sets = []
         update_pauli = []
 
         parity_sets = []
         parity_pauli = []
 
         flip_sets = []
 
         remainder_sets = []
         remainder_pauli = []
-        for j in range(nmodes):
+        for j in range(register_length):
 
             update_sets.append(update_set(j, np.power(2, bin_sup)))
-            update_sets[j] = update_sets[j][update_sets[j] < nmodes]
+            update_sets[j] = update_sets[j][update_sets[j] < register_length]
 
             parity_sets.append(parity_set(j, np.power(2, bin_sup)))
-            parity_sets[j] = parity_sets[j][parity_sets[j] < nmodes]
+            parity_sets[j] = parity_sets[j][parity_sets[j] < register_length]
 
             flip_sets.append(flip_set(j, np.power(2, bin_sup)))
-            flip_sets[j] = flip_sets[j][flip_sets[j] < nmodes]
+            flip_sets[j] = flip_sets[j][flip_sets[j] < register_length]
 
             remainder_sets.append(np.setdiff1d(parity_sets[j], flip_sets[j]))
 
-            update_pauli.append(Pauli((np.zeros(nmodes, dtype=bool), np.zeros(nmodes, dtype=bool))))
-            parity_pauli.append(Pauli((np.zeros(nmodes, dtype=bool), np.zeros(nmodes, dtype=bool))))
+            update_pauli.append(
+                Pauli(
+                    (np.zeros(register_length, dtype=bool), np.zeros(register_length, dtype=bool))
+                )
+            )
+            parity_pauli.append(
+                Pauli(
+                    (np.zeros(register_length, dtype=bool), np.zeros(register_length, dtype=bool))
+                )
+            )
             remainder_pauli.append(
-                Pauli((np.zeros(nmodes, dtype=bool), np.zeros(nmodes, dtype=bool)))
+                Pauli(
+                    (np.zeros(register_length, dtype=bool), np.zeros(register_length, dtype=bool))
+                )
             )
-            for k in range(nmodes):
+            for k in range(register_length):
                 if np.in1d(k, update_sets[j]):
                     update_pauli[j].x[k] = True
                 if np.in1d(k, parity_sets[j]):
                     parity_pauli[j].z[k] = True
                 if np.in1d(k, remainder_sets[j]):
                     remainder_pauli[j].z[k] = True
 
-            x_j = Pauli((np.zeros(nmodes, dtype=bool), np.zeros(nmodes, dtype=bool)))
+            x_j = Pauli(
+                (np.zeros(register_length, dtype=bool), np.zeros(register_length, dtype=bool))
+            )
             x_j.x[j] = True
-            y_j = Pauli((np.zeros(nmodes, dtype=bool), np.zeros(nmodes, dtype=bool)))
+            y_j = Pauli(
+                (np.zeros(register_length, dtype=bool), np.zeros(register_length, dtype=bool))
+            )
             y_j.z[j] = True
             y_j.x[j] = True
             pauli_table.append(
                 (
                     parity_pauli[j] & x_j & update_pauli[j],
                     remainder_pauli[j] & y_j & update_pauli[j],
                 )
@@ -157,10 +172,7 @@
         # PauliList has the phase information.
         # Here, phase is unnecessary, so the following removes phase.
         for pauli1, pauli2 in pauli_table:
             pauli1.phase = 0
             pauli2.phase = 0
 
         return pauli_table
-
-    def map(self, second_q_op: FermionicOp) -> PauliSumOp:
-        return BravyiKitaevMapper.mode_based_mapping(second_q_op, second_q_op.register_length)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/direct_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/direct_mapper.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -14,40 +14,37 @@
 
 from __future__ import annotations
 
 from functools import lru_cache
 
 import numpy as np
 
-from qiskit.opflow import PauliSumOp
 from qiskit.quantum_info.operators import Pauli
 
-from qiskit_nature.second_q.operators import VibrationalOp
+from qiskit_nature.deprecation import deprecate_arguments
 from .vibrational_mapper import VibrationalMapper
 
 
-class DirectMapper(VibrationalMapper):  # pylint: disable=missing-class-docstring
-    def __init__(self):
-        """The Direct mapper.
-
-        This mapper maps a :class:`~.VibrationalOp` to a
-        :class:`~qiskit.opflow.primitive_ops.PauliSumOp`. In doing so, each modal
-        of the the ``VibrationalOp`` gets mapped to a single qubit.
-        """
-        super().__init__(allows_two_qubit_reduction=False)
+class DirectMapper(VibrationalMapper):
+    """The Direct mapper.
+
+    This mapper maps a :class:`~.VibrationalOp` to a qubit operator. In doing so, each modal of the
+    ``VibrationalOp`` gets mapped to a single qubit.
+    """
 
     @classmethod
+    @deprecate_arguments("0.6.0", {"nmodes": "register_length"})
     @lru_cache(maxsize=32)
-    def pauli_table(cls, nmodes: int) -> list[tuple[Pauli, Pauli]]:
+    def pauli_table(
+        cls, register_length: int, *, nmodes: int | None = None
+    ) -> list[tuple[Pauli, Pauli]]:
+        # pylint: disable=unused-argument
         pauli_table = []
 
-        for i in range(nmodes):
-            a_z = np.asarray([0] * i + [0] + [0] * (nmodes - i - 1), dtype=bool)
-            a_x = np.asarray([0] * i + [1] + [0] * (nmodes - i - 1), dtype=bool)
-            b_z = np.asarray([0] * i + [1] + [0] * (nmodes - i - 1), dtype=bool)
-            b_x = np.asarray([0] * i + [1] + [0] * (nmodes - i - 1), dtype=bool)
+        for i in range(register_length):
+            a_z = np.asarray([0] * i + [0] + [0] * (register_length - i - 1), dtype=bool)
+            a_x = np.asarray([0] * i + [1] + [0] * (register_length - i - 1), dtype=bool)
+            b_z = np.asarray([0] * i + [1] + [0] * (register_length - i - 1), dtype=bool)
+            b_x = np.asarray([0] * i + [1] + [0] * (register_length - i - 1), dtype=bool)
             pauli_table.append((Pauli((a_z, a_x)), Pauli((b_z, b_x))))
 
         return pauli_table
-
-    def map(self, second_q_op: VibrationalOp) -> PauliSumOp:
-        return DirectMapper.mode_based_mapping(second_q_op, sum(second_q_op.num_modals))
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/fermionic_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/fermionic_mapper.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,37 +1,34 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Fermionic Mapper."""
 
-from abc import abstractmethod
+from __future__ import annotations
 
 from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
+
 from qiskit_nature.second_q.operators import FermionicOp
 
-from .qubit_mapper import QubitMapper
+from .qubit_mapper import ListOrDictType, QubitMapper
 
 
 class FermionicMapper(QubitMapper):
     """Mapper of Fermionic Operator to Qubit Operator"""
 
-    @abstractmethod
-    def map(self, second_q_op: FermionicOp) -> PauliSumOp:
-        """Maps a :class:`~qiskit_nature.second_q.operators.FermionicOp`
-        to a `PauliSumOp`.
-
-        Args:
-            second_q_op: the `FermionicOp` to be mapped.
-
-        Returns:
-            The `PauliSumOp` corresponding to the problem-Hamiltonian in the qubit space.
-        """
-        raise NotImplementedError()
+    def map(
+        self,
+        second_q_ops: FermionicOp | ListOrDictType[FermionicOp],
+        *,
+        register_length: int | None = None,
+    ) -> SparsePauliOp | PauliSumOp | ListOrDictType[SparsePauliOp | PauliSumOp]:
+        return super().map(second_q_ops, register_length=register_length)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/jordan_wigner_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/jordan_wigner_mapper.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -14,38 +14,36 @@
 
 from __future__ import annotations
 
 from functools import lru_cache
 
 import numpy as np
 
-from qiskit.opflow import PauliSumOp
 from qiskit.quantum_info.operators import Pauli
 
-from qiskit_nature.second_q.operators import FermionicOp
+from qiskit_nature.deprecation import deprecate_arguments
 from .fermionic_mapper import FermionicMapper
 
 
-class JordanWignerMapper(FermionicMapper):  # pylint: disable=missing-class-docstring
-    def __init__(self):
-        """The Jordan-Wigner fermion-to-qubit mapping."""
-        super().__init__(allows_two_qubit_reduction=False)
+class JordanWignerMapper(FermionicMapper):
+    """The Jordan-Wigner fermion-to-qubit mapping."""
 
     @classmethod
+    @deprecate_arguments("0.6.0", {"nmodes": "register_length"})
     @lru_cache(maxsize=32)
-    def pauli_table(cls, nmodes: int) -> list[tuple[Pauli, Pauli]]:
+    def pauli_table(
+        cls, register_length: int, *, nmodes: int | None = None
+    ) -> list[tuple[Pauli, Pauli]]:
+        # pylint: disable=unused-argument
         pauli_table = []
 
-        for i in range(nmodes):
-            a_z = np.asarray([1] * i + [0] + [0] * (nmodes - i - 1), dtype=bool)
-            a_x = np.asarray([0] * i + [1] + [0] * (nmodes - i - 1), dtype=bool)
-            b_z = np.asarray([1] * i + [1] + [0] * (nmodes - i - 1), dtype=bool)
-            b_x = np.asarray([0] * i + [1] + [0] * (nmodes - i - 1), dtype=bool)
-            # c_z = np.asarray([0] * i + [1] + [0] * (nmodes - i - 1), dtype=bool)
-            # c_x = np.asarray([0] * nmodes, dtype=bool)
+        for i in range(register_length):
+            a_z = np.asarray([1] * i + [0] + [0] * (register_length - i - 1), dtype=bool)
+            a_x = np.asarray([0] * i + [1] + [0] * (register_length - i - 1), dtype=bool)
+            b_z = np.asarray([1] * i + [1] + [0] * (register_length - i - 1), dtype=bool)
+            b_x = np.asarray([0] * i + [1] + [0] * (register_length - i - 1), dtype=bool)
+            # c_z = np.asarray([0] * i + [1] + [0] * (register_length - i - 1), dtype=bool)
+            # c_x = np.asarray([0] * register_length, dtype=bool)
             pauli_table.append((Pauli((a_z, a_x)), Pauli((b_z, b_x))))
             # TODO add Pauli 3-tuple to lookup table
 
         return pauli_table
-
-    def map(self, second_q_op: FermionicOp) -> PauliSumOp:
-        return JordanWignerMapper.mode_based_mapping(second_q_op, second_q_op.register_length)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/linear_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/linear_mapper.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -18,26 +18,29 @@
 from collections import defaultdict
 from fractions import Fraction
 from functools import reduce
 
 import numpy as np
 
 from qiskit.opflow import PauliSumOp
-from qiskit.quantum_info.operators import Pauli, SparsePauliOp
+from qiskit.quantum_info import Pauli, SparsePauliOp
 
+from qiskit_nature import settings
 from qiskit_nature.second_q.operators import SpinOp
 from .spin_mapper import SpinMapper
 
 
-class LinearMapper(SpinMapper):  # pylint: disable=missing-class-docstring
-    def __init__(self):
-        """The Linear spin-to-qubit mapping."""
-        super().__init__(allows_two_qubit_reduction=False)
+class LinearMapper(SpinMapper):
+    """The Linear spin-to-qubit mapping."""
 
-    def map(self, second_q_op: SpinOp) -> PauliSumOp:
+    def _map_single(
+        self, second_q_op: SpinOp, *, register_length: int | None = None
+    ) -> SparsePauliOp | PauliSumOp:
+        if register_length is None:
+            register_length = second_q_op.register_length
 
         qubit_ops_list: list[PauliSumOp] = []
 
         # get linear encoding of the general spin matrices
         spinx, spiny, spinz, identity = self._linear_encoding(second_q_op.spin)
         ordered_op = second_q_op.index_order()
 
@@ -46,21 +49,20 @@
         for terms, coeff in ordered_op.terms():
             mat = defaultdict(list)  # type: dict[int, list]
             for op, idx in terms:
                 if idx not in mat:
                     mat[idx] = identity
                 mat[idx] = mat[idx] @ char_map[op]
 
-            operatorlist = [mat[i] if i in mat else identity for i in range(ordered_op.num_spins)]
+            operatorlist = [mat[i] if i in mat else identity for i in range(register_length)]
             # Now, we can tensor all operators in this list
             qubit_ops_list.append(coeff * reduce(operator.xor, reversed(operatorlist)))
 
         qubit_op = reduce(operator.add, qubit_ops_list)
-
-        return qubit_op
+        return qubit_op if settings.use_pauli_sum_op else qubit_op.primitive.simplify()
 
     def _linear_encoding(self, spin: Fraction | float) -> list[PauliSumOp]:
         """
         Generates a 'linear_encoding' of the spin S operators 'X', 'Y', 'Z' and 'identity'
         to qubit operators (linear combinations of pauli strings).
         In this 'linear_encoding' each individual spin S system is represented via
         2S+1 qubits and the state |s> is mapped to the state |00...010..00>, where the s-th qubit is
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/logarithmic_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/logarithmic_mapper.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -18,16 +18,18 @@
 from collections import defaultdict
 from fractions import Fraction
 from functools import reduce
 
 import numpy as np
 
 from qiskit.opflow import PauliSumOp
-from qiskit.quantum_info.operators import SparsePauliOp, Operator
+from qiskit.quantum_info import SparsePauliOp
+from qiskit.quantum_info.operators import Operator
 
+from qiskit_nature import settings
 from qiskit_nature.second_q.operators import SpinOp
 from .spin_mapper import SpinMapper
 
 
 class LogarithmicMapper(SpinMapper):
     r"""A mapper for Logarithmic spin-to-qubit mapping.
     In this local encoding transformation, each individual spin S system is represented via
@@ -64,27 +66,31 @@
                 .. math::
                     \begin{pmatrix}
                         \text{padding} * I & 0 \\
                         0 & \text{matrix}
                     \end{pmatrix}
 
         """
-        super().__init__(allows_two_qubit_reduction=False)
         self._padding = padding
         self._embed_upper = embed_upper
 
-    def map(self, second_q_op: SpinOp) -> PauliSumOp:
+    def _map_single(
+        self, second_q_op: SpinOp, *, register_length: int | None = None
+    ) -> SparsePauliOp | PauliSumOp:
         """Map spins to qubits using the Logarithmic encoding.
 
         Args:
             second_q_op: Spins mapped to qubits.
 
         Returns:
             Qubit operators generated by the Logarithmic encoding
         """
+        if register_length is None:
+            register_length = second_q_op.register_length
+
         qubit_ops_list: list[PauliSumOp] = []
 
         # get logarithmic encoding of the general spin matrices.
         spinx, spiny, spinz, identity = self._logarithmic_encoding(second_q_op.spin)
         ordered_op = second_q_op.index_order()
 
         char_map = {"X": spinx, "Y": spiny, "Z": spinz}
@@ -92,21 +98,21 @@
         for terms, coeff in ordered_op.terms():
 
             mat = defaultdict(tuple)  # type: dict[int, tuple]
 
             for op, idx in terms:
                 mat[idx] = mat[idx] @ char_map[op] if idx in mat else char_map[op]
 
-            operatorlist = [mat[i] if i in mat else identity for i in range(ordered_op.num_spins)]
+            operatorlist = [mat[i] if i in mat else identity for i in range(register_length)]
             # Now, we can tensor all operators in this list
             qubit_ops_list.append(coeff * reduce(operator.xor, reversed(operatorlist)))
 
         qubit_op = reduce(operator.add, qubit_ops_list)
 
-        return qubit_op
+        return qubit_op if settings.use_pauli_sum_op else qubit_op.primitive
 
     def _logarithmic_encoding(
         self, spin: Fraction | int
     ) -> tuple[PauliSumOp, PauliSumOp, PauliSumOp, PauliSumOp]:
         """The logarithmic encoding.
 
         Args:
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/qubit_converter.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/qubit_converter.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,86 +12,36 @@
 
 """A converter from Second-Quantized to Qubit Operators."""
 
 from __future__ import annotations
 
 import copy
 import logging
-from typing import (
-    cast,
-    Callable,
-    Dict,
-    Generator,
-    Generic,
-    Iterable,
-    List,
-    Optional,
-    Tuple,
-    TypeVar,
-    Union,
-)
+from typing import Callable
 
 import numpy as np
 
 from qiskit.algorithms.list_or_dict import ListOrDict as ListOrDictType
 from qiskit.opflow import PauliSumOp
-from qiskit.opflow.converters import TwoQubitReduction
+from qiskit.quantum_info import SparsePauliOp
 from qiskit.opflow.primitive_ops import Z2Symmetries
 
-from qiskit_nature import QiskitNatureError
-
+from qiskit_nature import QiskitNatureError, settings
+from qiskit_nature.deprecation import warn_deprecated, DeprecatedType
 from qiskit_nature.second_q.operators import SparseLabelOp
-from .qubit_mapper import QubitMapper
 
-# pylint: disable=invalid-name
-T = TypeVar("T")
+from .qubit_mapper import QubitMapper, _ListOrDict
+from .parity_mapper import ParityMapper
+from .tapered_qubit_mapper import TaperedQubitMapper
 
 logger = logging.getLogger(__name__)
 
 
-class _ListOrDict(Dict, Iterable, Generic[T]):
-    """The ListOrDict utility class.
-
-    This is a utility which allows seamless iteration of a `list` or `dict` object.
-    """
-
-    def __init__(self, values: Optional[ListOrDictType] = None):
-        """
-        Args:
-            values: an optional object of `list` or `dict` type.
-        """
-        if isinstance(values, list):
-            values = dict(enumerate(values))
-        elif values is None:
-            values = {}
-        super().__init__(values)
-
-    def __iter__(self) -> Generator[Tuple[Union[int, str], T], T, None]:
-        """Return the generator-iterator method."""
-        return self._generator()
-
-    def _generator(self) -> Generator[Tuple[Union[int, str], T], T, None]:
-        """Return generator method iterating the contents of this class.
-
-        This generator yields the `(key, value)` pairs of the underlying dictionary. If this object
-        was constructed from a list, the keys in this generator are simply the numeric indices.
-
-        This generator also supports overriding the yielded value upon receiving any value other
-        than `None` from a `send` [1] instruction.
-
-        [1]: https://docs.python.org/3/reference/expressions.html#generator.send
-        """
-        for key, value in self.items():
-            new_value = yield (key, value)
-            if new_value is not None:
-                self[key] = new_value
-
-
 class QubitConverter:
-    """A converter from Second-Quantized to Qubit Operators.
+    """DEPRECATED A converter from Second-Quantized to Qubit Operators.
 
     This converter can be configured with a mapper instance which will later be used
     when 2nd quantized operators are requested to be converted (mapped) to qubit operators.
 
     For a Fermionic system, when its a electronic problem, there are certain mappers, such as
     the :class:`~qiskit_nature.second_q.mappers.ParityMapper` that introduces known
     symmetries, by virtue of the mapping, that can be exploited to reduce the size of the
@@ -107,15 +57,15 @@
     """
 
     def __init__(
         self,
         mapper: QubitMapper,
         *,
         two_qubit_reduction: bool = False,
-        z2symmetry_reduction: Optional[Union[str, List[int]]] = None,
+        z2symmetry_reduction: str | list[int] | None = None,
         sort_operators: bool = False,
     ):
         """
 
         Args:
             mapper: A mapper instance used to convert second quantized to qubit operators
             two_qubit_reduction: Whether to carry out two qubit reduction when possible
@@ -130,23 +80,41 @@
                 sector can be provided (a list of int of values -1, and 1). The default is None
                 meaning no symmetry reduction is done.
             sort_operators: Whether or not the second-quantized operators should be sorted before
                 mapping them to the qubit space. Enable this if you encounter non-reproducible
                 results which can occur when operator terms are not consistently ordered.
                 This is disabled by default, because in practice the Pauli-terms will be grouped
                 later on anyways.
-        """
 
+        Raises:
+            ValueError: If the mapper is a ``TaperedQubitMapper``.
+        """
+        warn_deprecated(
+            "0.6.0",
+            DeprecatedType.CLASS,
+            "QubitConverter",
+            additional_msg=(
+                ". Instead you should directly use the QubitMapper instance which you used to pass "
+                "into the QubitConverter as the first argument. Refer to the documentation of the "
+                "qiskit_nature.second_q.mappers module for more information"
+            ),
+        )
+        if isinstance(mapper, TaperedQubitMapper):
+            raise ValueError(
+                "The TaperedQubitMapper is not supported by the QubitConverter. "
+                "If you want to use tapering please either use the tapering built "
+                "directly into the QubitConverter (see its documentation) "
+                "or use the TaperedQubitMapper standalone (recommended)."
+            )
         self._mapper: QubitMapper = mapper
-        self._two_qubit_reduction: bool = two_qubit_reduction
-        self._z2symmetry_reduction: Optional[Union[str, List[int]]] = None
-        self.z2symmetry_reduction = z2symmetry_reduction  # Setter does validation
 
-        self._did_two_qubit_reduction: bool = False
-        self._num_particles: Optional[Tuple[int, int]] = None
+        self._two_qubit_reduction: bool = two_qubit_reduction
+        self._z2symmetry_reduction: str | list[int] | None = None
+        # We use the setter for the additional validation
+        self.z2symmetry_reduction = z2symmetry_reduction
         self._z2symmetries: Z2Symmetries = self._no_symmetries
 
         self._sort_operators: bool = sort_operators
 
     @property
     def _no_symmetries(self) -> Z2Symmetries:
         return Z2Symmetries([], [], [], None)
@@ -170,20 +138,20 @@
     @two_qubit_reduction.setter
     def two_qubit_reduction(self, value: bool) -> None:
         """Set two_qubit_reduction"""
         self._two_qubit_reduction = value
         self._z2symmetries = None  # Reset as symmetries my change due to this reduction
 
     @property
-    def z2symmetry_reduction(self) -> Optional[Union[str, List[int]]]:
+    def z2symmetry_reduction(self) -> str | list[int] | None:
         """Get z2symmetry_reduction"""
         return self._z2symmetry_reduction
 
     @z2symmetry_reduction.setter
-    def z2symmetry_reduction(self, z2symmetry_reduction: Optional[Union[str, List[int]]]) -> None:
+    def z2symmetry_reduction(self, z2symmetry_reduction: str | list[int] | None) -> None:
         """Set z2symmetry_reduction"""
         if z2symmetry_reduction is not None:
             if isinstance(z2symmetry_reduction, str):
                 if z2symmetry_reduction != "auto":
                     raise ValueError(
                         "The only string-like option for z2symmetry_reduction is "
                         f"'auto', not {z2symmetry_reduction}"
@@ -193,39 +161,49 @@
                     "z2symmetry_reduction tapering values list must "
                     f"contain -1's and/or 1's only but was {z2symmetry_reduction}"
                 )
 
         self._z2symmetry_reduction = z2symmetry_reduction
 
     @property
-    def num_particles(self) -> Optional[Tuple[int, int]]:
+    def num_particles(self) -> tuple[int, int] | None:
         """Get the number of particles as supplied to :meth:`convert`.
 
         This can also be set, for advanced usage, using :meth:`force_match`
         """
-        return self._num_particles
+        if isinstance(self._mapper, ParityMapper):
+            return self._mapper.num_particles
+        else:
+            return None
 
     @property
     def z2symmetries(self) -> Z2Symmetries:
         """Get Z2Symmetries as detected from conversion via :meth:`convert`.
 
         This may indicate no symmetries, i.e. be empty, if none were detected.
 
         This can also be set, for advanced usage, using :meth:`force_match`
         """
         return copy.deepcopy(self._z2symmetries)
 
+    def _check_reset_mapper(self) -> None:
+        """Resets the ``ParityMapper`` if the attribute :attr:`two_qubit_reduction` is set to False. This
+        makes the behavior of the QubitConverter compatible with the new ParityMapper class which only
+        has one attribute :attr:`num_particles`. This must be called right before any mapping method of
+        the mappers.
+        """
+        if not self.two_qubit_reduction and isinstance(self._mapper, ParityMapper):
+            self._mapper.num_particles = None
+
     def convert(
         self,
         second_q_op: SparseLabelOp,
-        num_particles: Optional[Tuple[int, int]] = None,
-        sector_locator: Optional[
-            Callable[[Z2Symmetries, "QubitConverter"], Optional[List[int]]]
-        ] = None,
-    ) -> PauliSumOp:
+        num_particles: tuple[int, int] | None = None,
+        sector_locator: Callable[[Z2Symmetries, "QubitConverter"], list[int] | None] | None = None,
+    ) -> SparsePauliOp | PauliSumOp:
         """
         Map the given second quantized operator to a qubit operators. Also it will
         carry out z2 symmetry reduction on the qubit operators if z2symmetry_reduction has
         been specified whether via the constructor or indirectly via the sector locator which
         is passed the detected symmetries to inform the determination.
 
         Args:
@@ -234,69 +212,76 @@
                 not supplied, even if two_qubit_reduction is possible, it will not be done.
             sector_locator: An optional callback, that given the detected Z2Symmetries, and also
                 the instance of the converter, can determine the correct sector of the tapered
                 operators so the correct one can be returned, which contains the problem solution,
                 out of the set that are the result of tapering.
 
         Returns:
-            PauliSumOp qubit operator
+            A qubit operator.
         """
-        qubit_op = self._map(second_q_op)
-        reduced_op = self._two_qubit_reduce(qubit_op, num_particles)
-        tapered_op, z2symmetries = self._find_taper_op(reduced_op, sector_locator)
+        if isinstance(self._mapper, ParityMapper):
+            self._mapper.num_particles = num_particles
+
+        self._check_reset_mapper()
+
+        reduced_op = self._mapper.map(second_q_op)
+        tapered_op, z2symmetries = self.find_taper_op(reduced_op, sector_locator)
 
-        self._num_particles = num_particles
         self._z2symmetries = z2symmetries
 
         return tapered_op
 
     def convert_only(
         self,
         second_q_op: SparseLabelOp,
-        num_particles: Optional[Tuple[int, int]] = None,
-    ) -> PauliSumOp:
+        num_particles: tuple[int, int] | None = None,
+    ) -> SparsePauliOp | PauliSumOp:
         """
         Map the given second quantized operator to a qubit operators using the mapper
         and possibly two qubit reduction. No tapering is done, nor is any conversion state saved,
         as is done in :meth:`convert` where a later :meth:`convert_match` will convert
         further operators in an identical manner.
 
         Args:
             second_q_op: A second quantized operator.
             num_particles: Needed for two qubit reduction to determine correct sector. If
                 not supplied, even if two_qubit_reduction is possible, it will not be done.
 
         Returns:
-            PauliSumOp qubit operator
+            A qubit operator.
         """
-        qubit_op = self._map(second_q_op)
-        reduced_op = self._two_qubit_reduce(qubit_op, num_particles)
+        if num_particles is not None and isinstance(self._mapper, ParityMapper):
+            self._mapper.num_particles = num_particles
+
+        self._check_reset_mapper()
+
+        reduced_op = self._mapper.map(second_q_op)
 
         return reduced_op
 
     def force_match(
         self,
         *,
-        num_particles: Optional[Tuple[int, int]] = None,
-        z2symmetries: Optional[Z2Symmetries] = None,
+        num_particles: tuple[int, int] | None = None,
+        z2symmetries: Z2Symmetries | None = None,
     ) -> None:
         """This is for advanced use where :meth:`convert` may not have been called or the
         converter should be used to taper to some external characteristics to be matched
         when using :meth:`convert_match`. Parameters passed here, when not None,
         will override any values stored from :meth:`convert`.
 
         Args:
             num_particles: The number or particles pertaining to two qubit reduction
             z2symmetries: Z2Symmetry information for tapering
 
         Raises:
             ValueError: If format of Z2Symmetry tapering values is invalid
         """
-        if num_particles is not None:
-            self._num_particles = num_particles
+        if num_particles is not None and isinstance(self._mapper, ParityMapper):
+            self._mapper.num_particles = num_particles
 
         if z2symmetries is not None:
             if not z2symmetries.is_empty():
                 if len(z2symmetries.tapering_values) != len(z2symmetries.sq_list):
                     raise ValueError(
                         f"Z2Symmetries tapering value length was "
                         f"{len(z2symmetries.tapering_values)} but expected "
@@ -312,133 +297,95 @@
 
     def convert_match(
         self,
         second_q_ops: SparseLabelOp | ListOrDictType[SparseLabelOp],
         *,
         suppress_none: bool = False,
         check_commutes: bool = True,
-    ) -> Union[PauliSumOp, ListOrDictType[PauliSumOp]]:
+    ) -> SparsePauliOp | PauliSumOp | ListOrDictType[SparsePauliOp | PauliSumOp]:
         """Convert further operators to match that done in :meth:`convert`, or as set by
             :meth:`force_match`.
 
         Args:
             second_q_ops: A second quantized operator or list thereof to be converted
             suppress_none: If None should be placed in the output list where an operator
                 did not commute with symmetry, to maintain order, or whether that should
                 be suppressed where the output list length may then be smaller than the input
-            check_commutes: If True (default) a tapered operator must commute with the
+            check_commutes: If True (default) an operator must commute with the
                 symmetry to be tapered otherwise None is returned for that operator. When
                 False the operator is tapered with no check so due consideration needs to
                 be given in this case to how such operator(s) are eventually used.
 
         Returns:
             A qubit operator or list thereof of the same length as the second_q_ops list. All
             operators in the second_q_ops list must commute with the symmetry detected when
             :meth:`convert` was called. If it does not then the position in the output list
             will be set to `None` to preserve the order, unless suppress_none is set; or None may
             be directly returned in the case when a single operator is provided (that cannot be
             suppressed as it's a single value)
         """
+
+        self._check_reset_mapper()
+
         # To allow a single operator to be converted, but use the same logic that does the
         # actual conversions, we make a single entry list of it here and unwrap to return.
         wrapped_type = type(second_q_ops)
 
         if isinstance(second_q_ops, SparseLabelOp):
             second_q_ops = [second_q_ops]
             suppress_none = False  # When only a single op we will return None back
 
         wrapped_second_q_ops: _ListOrDict[SparseLabelOp] = _ListOrDict(second_q_ops)
 
-        qubit_ops: _ListOrDict[PauliSumOp] = _ListOrDict()
-        for name, second_q_op in iter(wrapped_second_q_ops):
-            qubit_ops[name] = self._map(second_q_op)
-
         reduced_ops: _ListOrDict[PauliSumOp] = _ListOrDict()
-        for name, qubit_op in iter(qubit_ops):
-            reduced_ops[name] = self._two_qubit_reduce(qubit_op, self._num_particles)
-
-        tapered_ops = self._symmetry_reduce(reduced_ops, check_commutes)
-
-        returned_ops: Union[PauliSumOp, ListOrDictType[PauliSumOp]]
-
-        if issubclass(wrapped_type, SparseLabelOp):
-            returned_ops = list(iter(tapered_ops))[0][1]
-        elif wrapped_type == list:
-            if suppress_none:
-                returned_ops = [op for _, op in iter(tapered_ops) if op is not None]
-            else:
-                returned_ops = [op for _, op in iter(tapered_ops)]
-        elif wrapped_type == dict:
-            returned_ops = dict(iter(tapered_ops))
+        for name, second_q_op in iter(wrapped_second_q_ops):
+            reduced_op = self._mapper.map(second_q_op)
+            # NOTE: we ensure all operators are PauliSumOp here, because this is required by the
+            # opflow-based Z2Symmetries class still used by the QubitConverter
+            reduced_ops[name] = (
+                PauliSumOp(reduced_op) if not isinstance(reduced_op, PauliSumOp) else reduced_op
+            )
+
+        tapered_ops: _ListOrDict[PauliSumOp] = self._symmetry_reduce(reduced_ops, check_commutes)
+
+        # NOTE: _ListOrDict.unwrap takes care of the conversion to/from PauliSumOp based on
+        # settings.use_pauli_sum_op
+        returned_ops: PauliSumOp | ListOrDictType[PauliSumOp] = tapered_ops.unwrap(
+            wrapped_type, suppress_none=suppress_none
+        )
 
         return returned_ops
 
-    def map(
+    def find_taper_op(
         self,
-        second_q_ops: SparseLabelOp | ListOrDictType[SparseLabelOp],
-    ) -> Union[PauliSumOp, ListOrDictType[PauliSumOp]]:
-        """A convenience method to map second quantized operators based on current mapper.
+        qubit_op: SparsePauliOp | PauliSumOp,
+        sector_locator: Callable[[Z2Symmetries, "QubitConverter"], list[int] | None] | None = None,
+    ) -> tuple[SparsePauliOp | PauliSumOp, Z2Symmetries]:
+        r"""
+        Find the $Z_2$-symmetries associated with the qubit operator and taper it accordingly.
 
         Args:
-            second_q_ops: A second quantized operator, or list thereof
+            qubit_op: Qubit main operator - often the hamiltonian - from which symmetries
+                will be identified.
+            sector_locator: Method associated to the problem of interest which identifies the
+                symmetry sector of the solution. Defaults to None.
+
+        Raises:
+            QiskitNatureError: The user-specified or identified symmetry sector is not compatible with
+                the symmetries found for this problem.
+            QiskitNatureError: The main operator does not commute with its expected symmetries.
 
         Returns:
-            A qubit operator in the form of a PauliSumOp, or list thereof if a list of
-            second quantized operators was supplied
+            Tuple of the form (tapered qubit operator, identified $Z_2$-symmetry object)
         """
-        if isinstance(second_q_ops, SparseLabelOp):
-            qubit_ops = self._map(second_q_ops)
-        else:
-            wrapped_type = type(second_q_ops)
-
-            wrapped_second_q_ops: _ListOrDict[SparseLabelOp] = _ListOrDict(second_q_ops)
-
-            qubit_ops = _ListOrDict()
-            for name, second_q_op in iter(wrapped_second_q_ops):
-                qubit_ops[name] = self._map(second_q_op)
-
-            if wrapped_type == list:
-                qubit_ops = [op for _, op in iter(qubit_ops)]
-            elif wrapped_type == dict:
-                qubit_ops = dict(iter(qubit_ops))
-
-        return qubit_ops
-
-    def _map(self, second_q_op: SparseLabelOp) -> PauliSumOp:
-        if self._sort_operators and isinstance(second_q_op, SparseLabelOp):
-            second_q_op = second_q_op.sort()
-        return self._mapper.map(second_q_op)
-
-    def _two_qubit_reduce(
-        self, qubit_op: PauliSumOp, num_particles: Optional[Tuple[int, int]]
-    ) -> PauliSumOp:
-        reduced_op = qubit_op
-
-        if num_particles is not None:
-            if self._two_qubit_reduction and self._mapper.allows_two_qubit_reduction:
-                if qubit_op.num_qubits <= 2:
-                    logger.warning(
-                        "The original qubit operator only contains %s qubits! Skipping the requested "
-                        "two-qubit reduction!",
-                        qubit_op.num_qubits,
-                    )
-                    return reduced_op
-
-                two_q_reducer = TwoQubitReduction(num_particles)
-                reduced_op = cast(PauliSumOp, two_q_reducer.convert(qubit_op))
-
-        return reduced_op
+        if not isinstance(qubit_op, PauliSumOp):
+            # NOTE: we ensure the operator is a PauliSumOp here, because this is required by the
+            # opflow-based Z2Symmetries class still used by the QubitConverter
+            qubit_op = PauliSumOp(qubit_op)
 
-    def _find_taper_op(
-        self,
-        qubit_op: PauliSumOp,
-        sector_locator: Optional[
-            Callable[[Z2Symmetries, "QubitConverter"], Optional[List[int]]]
-        ] = None,
-    ) -> Tuple[PauliSumOp, Z2Symmetries]:
         # Return operator unchanged and empty symmetries if we do not taper
         tapered_qubit_op = qubit_op
         z2_symmetries = self._no_symmetries
 
         # If we were given a sector, or one might be located, we first need to find any symmetries
         if self.z2symmetry_reduction is not None:
             z2_symmetries = Z2Symmetries.find_Z2_symmetries(qubit_op)
@@ -482,14 +429,21 @@
                     "Z2 symmetry failure. The operator must commute "
                     "with symmetries found from it!"
                 )
 
             z2_symmetries.tapering_values = self._z2symmetry_reduction
             tapered_qubit_op = z2_symmetries.taper(qubit_op) if commutes else None
 
+        if (
+            tapered_qubit_op is not None
+            and not isinstance(tapered_qubit_op, SparsePauliOp)
+            and not settings.use_pauli_sum_op
+        ):
+            tapered_qubit_op = tapered_qubit_op.primitive
+
         return tapered_qubit_op, z2_symmetries
 
     def _symmetry_reduce(
         self,
         qubit_ops: _ListOrDict[PauliSumOp],
         check_commutes: bool,
     ) -> _ListOrDict[PauliSumOp]:
@@ -517,16 +471,111 @@
                 logger.debug("Tapering operators whether they commute with symmetry or not:")
                 tapered_qubit_ops = _ListOrDict()
                 for name, qubit_op in iter(qubit_ops):
                     tapered_qubit_ops[name] = self._z2symmetries.taper(qubit_ops[name])
 
         return tapered_qubit_ops
 
+    def symmetry_reduce_clifford(
+        self,
+        converted_ops: ListOrDictType[SparsePauliOp | PauliSumOp],
+        *,
+        check_commutes: bool = True,
+    ) -> ListOrDictType[SparsePauliOp | PauliSumOp]:
+        """
+        Applies the tapering to a list of operators previously converted with the Clifford
+        transformation from the current symmetry.
+
+        Args:
+            converted_ops: Operators to taper.
+            check_commutes: If True (default) an operator must commute with the
+                symmetry to be tapered otherwise None is returned for that operator. When
+                False the operator is tapered with no check so due consideration needs to
+                be given in this case to how such operator(s) are eventually used.
+
+        Returns:
+            Tapered operators.
+        """
+        if converted_ops is None or self._z2symmetries is None or self._z2symmetries.is_empty():
+            return_ops = converted_ops
+        else:
+            wrapped_converted_ops, wrapped_type = _ListOrDict.wrap(converted_ops)
+
+            pauli_sum_ops: ListOrDictType[PauliSumOp] = _ListOrDict()
+            for name, qubit_op in iter(wrapped_converted_ops):
+                if not isinstance(qubit_op, PauliSumOp):
+                    qubit_op = PauliSumOp(qubit_op)
+                pauli_sum_ops[name] = qubit_op
+
+            if check_commutes:
+                logger.debug("Checking operators commute with symmetry:")
+                symmetry_ops = []
+                for sq_pauli in self._z2symmetries._sq_paulis:
+                    symmetry_ops.append(PauliSumOp.from_list([(sq_pauli.to_label(), 1.0)]))
+                commuted = {}
+                for name, qubit_op in iter(pauli_sum_ops):
+                    commutes = QubitConverter._check_commutes(symmetry_ops, qubit_op)
+                    commuted[name] = commutes
+                    logger.debug("Qubit operator '%s' commuted with symmetry: %s", name, commutes)
+
+                # Tapering values were set from prior convert, so we go ahead and taper operators
+                tapered_qubit_ops: _ListOrDict[PauliSumOp] = _ListOrDict()
+                for name, commutes in commuted.items():
+                    if commutes:
+                        tapered_qubit_ops[name] = self._z2symmetries.taper_clifford(
+                            pauli_sum_ops[name]
+                        )
+            else:
+                logger.debug("Tapering operators whether they commute with symmetry or not:")
+                tapered_qubit_ops = _ListOrDict()
+                for name, qubit_op in iter(pauli_sum_ops):
+                    tapered_qubit_ops[name] = self._z2symmetries.taper_clifford(pauli_sum_ops[name])
+
+            # NOTE: _ListOrDict.unwrap takes care of the conversion to/from PauliSumOp based on
+            # settings.use_pauli_sum_op
+            return_ops = tapered_qubit_ops.unwrap(wrapped_type)
+
+        return return_ops
+
+    def convert_clifford(
+        self,
+        qubit_ops: SparsePauliOp | PauliSumOp | ListOrDictType[SparsePauliOp | PauliSumOp],
+    ) -> SparsePauliOp | PauliSumOp | ListOrDictType[SparsePauliOp | PauliSumOp]:
+        """
+        Applies the Clifford transformation from the current symmetry to all operators.
+
+        Args:
+            qubit_ops: Operators to convert.
+
+        Returns:
+            Converted operators
+        """
+        if qubit_ops is None or self._z2symmetries is None or self._z2symmetries.is_empty():
+            converted_ops = qubit_ops
+        else:
+            wrapped_second_q_ops, wrapped_type = _ListOrDict.wrap(qubit_ops)
+
+            pauli_sum_ops: ListOrDictType[PauliSumOp] = _ListOrDict()
+            for name, qubit_op in iter(wrapped_second_q_ops):
+                if not isinstance(qubit_op, PauliSumOp):
+                    qubit_op = PauliSumOp(qubit_op)
+                pauli_sum_ops[name] = qubit_op
+
+            converted_ops = _ListOrDict()
+            for name, second_q_op in iter(pauli_sum_ops):
+                converted_ops[name] = self._z2symmetries.convert_clifford(second_q_op)
+
+            # NOTE: _ListOrDict.unwrap takes care of the conversion to/from PauliSumOp based on
+            # settings.use_pauli_sum_op
+            converted_ops = converted_ops.unwrap(wrapped_type)
+
+        return converted_ops
+
     @staticmethod
-    def _check_commutes(cliffords: List[PauliSumOp], qubit_op: PauliSumOp) -> bool:
+    def _check_commutes(cliffords: list[PauliSumOp], qubit_op: PauliSumOp) -> bool:
         commutes = []
         for clifford in cliffords:
             commuting_rows = qubit_op.primitive.paulis.commutes_with_all(clifford.primitive.paulis)
             commutes.append(len(commuting_rows) == qubit_op.primitive.size)
         does_commute = bool(np.all(commutes))
         logger.debug("  '%s' commutes: %s, %s", id(qubit_op), does_commute, commutes)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/spin_mapper.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/mappers/spin_mapper.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,36 +1,34 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Spin Mapper."""
 
-from abc import abstractmethod
+from __future__ import annotations
 
 from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
+
 from qiskit_nature.second_q.operators import SpinOp
 
-from .qubit_mapper import QubitMapper
+from .qubit_mapper import ListOrDictType, QubitMapper
 
 
 class SpinMapper(QubitMapper):
     """Mapper of Spin Operator to Qubit Operator"""
 
-    @abstractmethod
-    def map(self, second_q_op: SpinOp) -> PauliSumOp:
-        """Maps a :class:`~qiskit_nature.second_q.operators.SpinOp` to a `PauliSumOp`.
-
-        Args:
-            second_q_op: the `SpinOp` to be mapped.
-
-        Returns:
-            The `PauliSumOp` corresponding to the problem-Hamiltonian in the qubit space.
-        """
-        raise NotImplementedError()
+    def map(
+        self,
+        second_q_ops: SpinOp | ListOrDictType[SpinOp],
+        *,
+        register_length: int | None = None,
+    ) -> SparsePauliOp | PauliSumOp | ListOrDictType[SparsePauliOp | PauliSumOp]:
+        return super().map(second_q_ops, register_length=register_length)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/mappers/vibrational_mapper.py` & `qiskit-nature-0.6.0/test/second_q/mappers/test_interleaved_qubit_mapper.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,37 +1,58 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
-"""Vibrational Mapper."""
+""" Test InterleavedQubitMapper """
 
-from abc import abstractmethod
+import unittest
+from test import QiskitNatureTestCase
+
+from ddt import data, ddt
 
 from qiskit.opflow import PauliSumOp
-from qiskit_nature.second_q.operators import VibrationalOp
+from qiskit.quantum_info import SparsePauliOp
+
+from qiskit_nature.second_q.mappers import InterleavedQubitMapper, JordanWignerMapper
+from qiskit_nature.second_q.operators import FermionicOp
+from qiskit_nature.settings import settings
+
+
+@ddt
+class TestInterleavedQubitMapper(QiskitNatureTestCase):
+    """Test InterleavedQubitMapper"""
+
+    def tearDown(self) -> None:
+        super().tearDown()
+        settings.use_pauli_sum_op = True
+
+    @data(True, False)
+    def test_mapping(self, use_pauli_sum_op: bool) -> None:
+        """Test the actual mapping procedure."""
+        settings.use_pauli_sum_op = use_pauli_sum_op
 
-from .qubit_mapper import QubitMapper
+        ferm_op = FermionicOp({"+_0 -_1": 1}, num_spin_orbitals=4)
 
+        interleaved_mapper = InterleavedQubitMapper(JordanWignerMapper())
 
-class VibrationalMapper(QubitMapper):
-    """Mapper of Vibrational Operator to Qubit Operator"""
+        qubit_op = interleaved_mapper.map(ferm_op)
+        if isinstance(qubit_op, PauliSumOp):
+            qubit_op = qubit_op.primitive
 
-    @abstractmethod
-    def map(self, second_q_op: VibrationalOp) -> PauliSumOp:
-        """Maps a :class:`~qiskit_nature.second_q.operators.VibrationalOp`
-        to a `PauliSumOp`.
+        self.assertEqual(
+            qubit_op,
+            SparsePauliOp.from_list(
+                [("IXIY", -0.25j), ("IYIY", 0.25), ("IXIX", 0.25), ("IYIX", 0.25j)]
+            ),
+        )
 
-        Args:
-            second_q_op: the `VibrationalOp` to be mapped.
 
-        Returns:
-            The `PauliSumOp` corresponding to the problem-Hamiltonian in the qubit space.
-        """
-        raise NotImplementedError()
+if __name__ == "__main__":
+    unittest.main()
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -24,35 +24,39 @@
    ElectronicIntegrals
    FermionicOp
    SparseLabelOp
    SpinOp
    VibrationalOp
    VibrationalIntegrals
    PolynomialTensor
+   Tensor
 
 Modules
 -------
 
 .. autosummary::
    :toctree:
 
    tensor_ordering
+   symmetric_two_body
    commutators
 """
 
 from .electronic_integrals import ElectronicIntegrals
 from .fermionic_op import FermionicOp
 from .spin_op import SpinOp
 from .vibrational_op import VibrationalOp
 from .vibrational_integrals import VibrationalIntegrals
 from .polynomial_tensor import PolynomialTensor
 from .sparse_label_op import SparseLabelOp
+from .tensor import Tensor
 
 __all__ = [
     "ElectronicIntegrals",
     "FermionicOp",
     "SpinOp",
     "VibrationalOp",
     "VibrationalIntegrals",
     "PolynomialTensor",
     "SparseLabelOp",
+    "Tensor",
 ]
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/_bits_container.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/_bits_container.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -31,15 +31,15 @@
 
         1. if a `+` has been applied
         2. if a `-` has been applied
         3. whether a `+` or `-` was applied first
         4. whether the last applied operator was a `+` or `-`.
     """
 
-    def __init__(self):
+    def __init__(self) -> None:
         self.data: dict[T, int] = {}
 
     def get_plus(self, index: T) -> int:
         """Returns the value of the `+`-register.
 
         Args:
             index: the internal data key (corresponding to the vibrational mode).
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/commutators.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/commutators.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -41,15 +41,15 @@
     Args:
         op_a: Operator A.
         op_b: Operator B.
 
     Returns:
         The computed commutator.
     """
-    return (op_a @ op_b - op_b @ op_a).simplify()
+    return (op_a @ op_b - op_b @ op_a).simplify(atol=0)
 
 
 def anti_commutator(op_a: SparseLabelOp, op_b: SparseLabelOp) -> SparseLabelOp:
     r"""Compute anti-commutator of `op_a` and `op_b`.
 
     .. math::
         AB + BA.
@@ -57,15 +57,15 @@
     Args:
         op_a: Operator A.
         op_b: Operator B.
 
     Returns:
         The computed anti-commutator.
     """
-    return (op_a @ op_b + op_b @ op_a).simplify()
+    return (op_a @ op_b + op_b @ op_a).simplify(atol=0)
 
 
 def double_commutator(
     op_a: SparseLabelOp,
     op_b: SparseLabelOp,
     op_c: SparseLabelOp,
     sign: bool = False,
@@ -116,8 +116,8 @@
 
     res = (
         op_abc
         - sign_num * op_cba
         + 0.5 * (-op_bac + sign_num * op_cab - op_acb + sign_num * op_bca)
     )
 
-    return res.simplify()
+    return res.simplify(atol=0)
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/electronic_integrals.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/electronic_integrals.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,24 +12,26 @@
 
 """A container class for electronic operator coefficients (a.k.a. electronic integrals)."""
 
 from __future__ import annotations
 
 from collections.abc import Callable
 from numbers import Number
-from typing import cast
+from typing import Tuple, cast
 
 import numpy as np
 
 from qiskit.quantum_info.operators.mixins import LinearMixin
 
 from qiskit_nature.exceptions import QiskitNatureError
 import qiskit_nature.optionals as _optionals
 
-from .polynomial_tensor import ARRAY_TYPE, PolynomialTensor
+from .polynomial_tensor import PolynomialTensor
+from .symmetric_two_body import SymmetricTwoBodyIntegrals
+from .tensor import Tensor
 from .tensor_ordering import (
     IndexType,
     find_index_order,
     to_physicist_ordering,
 )
 
 if _optionals.HAS_SPARSE:
@@ -252,16 +254,26 @@
 
         These get reconstructed from :attr:`beta_alpha` by transposing in the physicist' ordering
         convention.
         """
         if self.beta_alpha.is_empty():
             return self.beta_alpha
 
-        beta_alpha = cast(ARRAY_TYPE, self.beta_alpha["++--"])
-        alpha_beta = np.moveaxis(beta_alpha, (0, 1), (2, 3))
+        two_body_ba = self.beta_alpha["++--"]
+        if isinstance(two_body_ba, SymmetricTwoBodyIntegrals):
+            # NOTE: to ensure proper inter-operability with the symmetry-aware integral containers,
+            # we delegate the conjugation to the objects themselves
+            return PolynomialTensor({"++--": two_body_ba.conjugate()}, validate=False)
+
+        alpha_beta: Tensor | np.ndarray | SparseArray
+        if not isinstance(two_body_ba, Tensor):
+            # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+            alpha_beta = Tensor(np.moveaxis(Tensor(two_body_ba), (0, 1), (2, 3)))
+        else:
+            alpha_beta = np.moveaxis(two_body_ba, (0, 1), (2, 3))
         return PolynomialTensor({"++--": alpha_beta}, validate=False)
 
     @property
     def one_body(self) -> ElectronicIntegrals:
         """Returns only the one-body integrals."""
         alpha: PolynomialTensor = None
         if "+-" in self.alpha:
@@ -374,15 +386,15 @@
             beta,
             self.beta_alpha + other.beta_alpha,
         )
 
     @classmethod
     def apply(
         cls,
-        function: Callable[..., np.ndarray | SparseArray | Number],
+        function: Callable[..., np.ndarray | SparseArray | complex],
         *operands: ElectronicIntegrals,
         validate: bool = True,
     ) -> ElectronicIntegrals:
         """Exposes the :meth:`qiskit_nature.second_q.operators.PolynomialTensor.apply` method.
 
         This behaves identical to the ``apply`` implementation of the ``PolynomialTensor``, applied
         to the :attr:`alpha`, :attr:`beta`, and :attr:`beta_alpha` attributes of the provided
@@ -511,15 +523,15 @@
 
         Returns:
             The resulting ``ElectronicIntegrals``.
         """
         alpha_dict = {"+-": h1_a}
 
         if h2_aa is not None:
-            if auto_index_order:
+            if auto_index_order and not isinstance(h2_aa, SymmetricTwoBodyIntegrals):
                 index_order = find_index_order(h2_aa)
                 if index_order == IndexType.UNKNOWN:
                     raise QiskitNatureError(
                         f"The index ordering of the `h2_aa` argument, {index_order}, is invalid.\n"
                         "Provide the two-body matrices in either chemists' or physicists' order, "
                         "or disable the automatic transformation to enforce these matrices to be "
                         "used (`auto_index_order=False`)."
@@ -564,26 +576,40 @@
             The ``PolynomialTensor`` representing the entire system.
         """
         beta_empty = self.beta.is_empty()
         beta_alpha_empty = self.beta_alpha.is_empty()
 
         kron_one_body = np.zeros((2, 2))
         kron_two_body = np.zeros((2, 2, 2, 2))
-        kron_tensor = PolynomialTensor(
-            {"": cast(Number, 1.0), "+-": kron_one_body, "++--": kron_two_body}
-        )
+        kron_tensor = PolynomialTensor({"": 1.0, "+-": kron_one_body, "++--": kron_two_body})
+
+        ba_index = (1, 0, 0, 1)
+        ab_index = (0, 1, 1, 0)
 
         if beta_empty and beta_alpha_empty:
             kron_one_body[(0, 0)] = 1
             kron_one_body[(1, 1)] = 1
             kron_two_body[(0, 0, 0, 0)] = 0.5
-            kron_two_body[(0, 1, 1, 0)] = 0.5
-            kron_two_body[(1, 0, 0, 1)] = 0.5
             kron_two_body[(1, 1, 1, 1)] = 0.5
 
+            aa_tensor = self.alpha.get("++--", None)
+            if aa_tensor is not None:
+                if not isinstance(aa_tensor, Tensor):
+                    aa_tensor = Tensor(aa_tensor)
+
+                ba_index = cast(
+                    Tuple[int, int, int, int], tuple(aa_tensor._reverse_label_template(ba_index))
+                )
+                ab_index = cast(
+                    Tuple[int, int, int, int], tuple(aa_tensor._reverse_label_template(ab_index))
+                )
+
+            kron_two_body[ba_index] = 0.5
+            kron_two_body[ab_index] = 0.5
+
             tensor_blocked_spin_orbitals = PolynomialTensor.apply(np.kron, kron_tensor, self.alpha)
             return tensor_blocked_spin_orbitals
 
         tensor_blocked_spin_orbitals = PolynomialTensor({})
         # pure alpha spin
         kron_one_body[(0, 0)] = 1
         kron_two_body[(0, 0, 0, 0)] = 0.5
@@ -595,25 +621,37 @@
         kron_two_body[(1, 1, 1, 1)] = 0.5
         tensor_blocked_spin_orbitals += PolynomialTensor.apply(np.kron, kron_tensor, self.beta)
         kron_one_body[(1, 1)] = 0
         kron_two_body[(1, 1, 1, 1)] = 0
         # beta_alpha spin
         if not beta_alpha_empty:
             kron_tensor = PolynomialTensor({"++--": kron_two_body})
-            kron_two_body[(1, 0, 0, 1)] = 0.5
+
+            ba_tensor = self.beta_alpha["++--"]
+            if not isinstance(ba_tensor, Tensor):
+                ba_tensor = Tensor(ba_tensor)
+
+            ba_index = cast(
+                Tuple[int, int, int, int], tuple(ba_tensor._reverse_label_template(ba_index))
+            )
+            ab_index = cast(
+                Tuple[int, int, int, int], tuple(ba_tensor._reverse_label_template(ab_index))
+            )
+
+            kron_two_body[ba_index] = 0.5
             tensor_blocked_spin_orbitals += PolynomialTensor.apply(
                 np.kron, kron_tensor, self.beta_alpha
             )
-            kron_two_body[(1, 0, 0, 1)] = 0
+            kron_two_body[ba_index] = 0
             # extract transposed beta_alpha term
-            kron_two_body[(0, 1, 1, 0)] = 0.5
+            kron_two_body[ab_index] = 0.5
             tensor_blocked_spin_orbitals += PolynomialTensor.apply(
                 np.kron, kron_tensor, self.alpha_beta
             )
-            kron_two_body[(0, 1, 1, 0)] = 0
+            kron_two_body[ab_index] = 0
 
         return tensor_blocked_spin_orbitals
 
     def trace_spin(self) -> PolynomialTensor:
         """Returns a :class:`~.PolynomialTensor` where the spin components have been traced out.
 
         This will sum the :attr:`alpha` and :attr:`beta` components, tracing out the spin.
@@ -623,21 +661,18 @@
         """
         beta_empty = self.beta.is_empty()
         beta_alpha_empty = self.beta_alpha.is_empty()
 
         if beta_empty and beta_alpha_empty:
             return cast(PolynomialTensor, 2.0 * self.alpha)
 
-        one_body = self.one_body
         two_body = self.two_body
         tensor_spin_traced = PolynomialTensor({})
-        tensor_spin_traced += one_body.alpha
-        tensor_spin_traced += one_body.beta
-        tensor_spin_traced += two_body.alpha
-        tensor_spin_traced += two_body.beta
+        tensor_spin_traced += self.alpha
+        tensor_spin_traced += self.beta
         if beta_alpha_empty:
             tensor_spin_traced += two_body.alpha
             tensor_spin_traced += two_body.beta
         else:
             tensor_spin_traced += two_body.beta_alpha
             tensor_spin_traced += two_body.alpha_beta
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/fermionic_op.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/fermionic_op.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -18,20 +18,21 @@
 from collections import defaultdict
 from collections.abc import Collection, Mapping
 from typing import cast, Iterator
 
 import numpy as np
 from scipy.sparse import csc_matrix
 
+from qiskit_nature.deprecation import deprecate_method
 from qiskit_nature.exceptions import QiskitNatureError
-import qiskit_nature.optionals as _optionals
 
 from ._bits_container import _BitsContainer
 from .polynomial_tensor import PolynomialTensor
 from .sparse_label_op import _TCoeff, SparseLabelOp, _to_number
+from .tensor import Tensor
 
 
 class FermionicOp(SparseLabelOp):
     r"""N-mode Fermionic operator.
 
     A ``FermionicOp`` represents a weighted sum of fermionic creation/annihilation operator terms.
     These terms are encoded as sparse labels, which are strings consisting of a space-separated list of
@@ -42,15 +43,15 @@
     0-based, the maximum value an index can take is given by :code:`num_spin_orbitals-1`).
 
     **Initialization**
 
     A ``FermionicOp`` is initialized with a dictionary, mapping terms to their respective
     coefficients:
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         from qiskit_nature.second_q.operators import FermionicOp
 
         op = FermionicOp(
             {
                 "+_0 -_0": 1.0,
                 "+_1 -_1": -1.0,
@@ -58,15 +59,15 @@
             num_spin_orbitals=2,
         )
 
     By default, this way of initializing will create a full copy of the dictionary of coefficients.
     If you have very restricted memory resources available, or would like to avoid the additional
     copy, the dictionary will be stored by reference if you disable ``copy`` like so:
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         some_big_data = {
             "+_0 -_0": 1.0,
             "+_1 -_1": -1.0,
             # ...
         }
 
@@ -87,61 +88,50 @@
 
     This class supports the following basic arithmetic operations: addition, subtraction, scalar
     multiplication, operator multiplication, and adjoint.
     For example,
 
     Addition
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       FermionicOp({"+_1": 1}, num_spin_orbitals=2) + FermionicOp({"+_0": 1}, num_spin_orbitals=2)
 
     Sum
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       sum(FermionicOp({label: 1}, num_spin_orbitals=3) for label in ["+_0", "-_1", "+_2 -_2"])
 
     Scalar multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       0.5 * FermionicOp({"+_1": 1}, num_spin_orbitals=2)
 
     Operator multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       op1 = FermionicOp({"+_0 -_1": 1}, num_spin_orbitals=2)
       op2 = FermionicOp({"-_0 +_0 +_1": 1}, num_spin_orbitals=2)
       print(op1 @ op2)
 
     Tensor multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       op = FermionicOp({"+_0 -_1": 1}, num_spin_orbitals=2)
       print(op ^ op)
 
     Adjoint
 
-    .. jupyter-execute::
-
-      FermionicOp({"+_0 -_1": 1j}, num_spin_orbitals=2).adjoint()
-
-    In principle, you can also add `FermionicOp` and integers, but the only valid case is the
-    addition of `0 + FermionicOp`. This makes the `sum` operation from the example above possible
-    and it is useful in the following scenario:
-
     .. code-block:: python
 
-        fermion = 0
-        for i in some_iterable:
-            # some processing
-            fermion += FermionicOp(somedata)
+      FermionicOp({"+_0 -_1": 1j}, num_spin_orbitals=2).adjoint()
 
     **Iteration**
 
     Instances of ``FermionicOp`` are iterable. Iterating a ``FermionicOp`` yields (term, coefficient)
     pairs describing the terms contained in the operator.
 
     Attributes:
@@ -254,31 +244,25 @@
 
         for key in tensor:
             if key == "":
                 # TODO: deal with complexity
                 data[""] = cast(float, tensor[key])
                 continue
 
-            label_template = " ".join(f"{op}_{{}}" for op in key)
+            mat = tensor[key]
 
-            # PERF: the following matrix unpacking is a performance bottleneck!
-            # We could consider using Rust in the future to improve upon this.
+            if not isinstance(mat, Tensor):
+                # TODO: this case is to be removed once qiskit_nature.settings.tensor_unwrapping is
+                # deprecated and the PolynomialTensor item is guaranteed to be of type Tensor
+                mat = Tensor(mat)
 
-            mat = tensor[key]
-            if isinstance(mat, np.ndarray):
-                for index in np.ndindex(*mat.shape):
-                    data[label_template.format(*index)] = mat[index]
-            else:
-                _optionals.HAS_SPARSE.require_now("SparseArray")
-                import sparse as sp  # pylint: disable=import-error
-
-                if isinstance(mat, sp.SparseArray):
-                    coo = sp.as_coo(mat)
-                    for value, *index in zip(coo.data, *coo.coords):
-                        data[label_template.format(*index)] = value
+            label_template = mat.label_template.format(*key)
+
+            for value, index in mat.coord_iter():
+                data[label_template.format(*index)] = value
 
         return cls(data, copy=False, num_spin_orbitals=tensor.register_length).chop()
 
     def __repr__(self) -> str:
         data_str = f"{dict(self.items())}"
 
         return "FermionicOp(" f"{data_str}, " f"num_spin_orbitals={self.num_spin_orbitals}, " ")"
@@ -344,18 +328,28 @@
                     new_data[new_label] = cf1 * cf2
 
         new_op = a._new_instance(new_data, other=b)
         if offset:
             new_op.num_spin_orbitals = a.num_spin_orbitals + b.num_spin_orbitals
         return new_op
 
-    # TODO: do we want to change the returned type to be non-scipy sparse matrix?
+    # pylint: disable=bad-docstring-quotes
+    @deprecate_method(
+        "0.6.0",
+        additional_msg=(
+            ". This method has no direct replacement. Instead, use the "
+            "`qiskit_nature.second_q.mappers.JordanWignerMapper` to create a qubit operator and "
+            "subsequently use its `to_matrix()` method. Be advised, that the basis state ordering "
+            "of that output will differ due to the bitstring endianness. For more information "
+            "refer to https://github.com/Qiskit/qiskit-nature/issues/875."
+        ),
+    )
     def to_matrix(self, sparse: bool | None = True) -> csc_matrix | np.ndarray:
-        """Convert to a matrix representation over the full fermionic Fock space in the occupation
-        number basis.
+        """DEPRECATED Convert to a matrix representation over the full fermionic Fock space in the
+        occupation number basis.
 
         The basis states are ordered in increasing bitstring order as 0000, 0001, ..., 1111.
 
         Args:
             sparse: If true, the matrix is returned as a sparse matrix, otherwise it is returned as
                 a dense numpy array.
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/polynomial_tensor.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/polynomial_tensor.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -14,38 +14,34 @@
 
 from __future__ import annotations
 
 from collections.abc import Callable, Mapping
 from itertools import product
 from numbers import Number
 from typing import Iterator, Type, Union, cast
-import string
 
 import numpy as np
 
 from qiskit.quantum_info.operators.mixins import (
     LinearMixin,
     GroupMixin,
     TolerancesMixin,
 )
 
 from qiskit_nature.settings import settings
 import qiskit_nature.optionals as _optionals
+from qiskit_nature.utils import get_einsum
+
+from .tensor import Tensor
 
 if _optionals.HAS_SPARSE:
     # pylint: disable=import-error
-    from sparse import SparseArray, COO, DOK, GCXS, zeros_like
+    from sparse import SparseArray, COO, DOK, GCXS
 else:
 
-    def zeros_like(*args):
-        """Empty zeros_like function
-        Replacement if sparse.zeros_like is not present.
-        """
-        del args
-
     class COO:  # type: ignore
         """Empty COO class
         Replacement if sparse.COO is not present.
         """
 
         pass
 
@@ -67,134 +63,150 @@
         """Empty SparseArray class
         Replacement if sparse.SparseArray is not present.
         """
 
         pass
 
 
-# pylint: disable=invalid-name
-ARRAY_TYPE = Union[np.ndarray, SparseArray]
-
-
 class PolynomialTensor(LinearMixin, GroupMixin, TolerancesMixin, Mapping):
     """A container class to store arbitrary operator coefficients.
 
-    This class generalizes the storing of operator coefficients in matrix format. Actual operators
+    This class generalizes the storing of operator coefficients in tensor format. Actual operators
     can be extracted from it using the
     :meth:`qiskit_nature.second_q.operators.SparseLabelOp.from_polynomial_tensor` method on the
     respective subclasses of the ``SparseLabelOp``.
 
-    The storage format maps from string keys to matrix values. By design, **no** assumptions are
-    made about the *contents* of the keys. However, the length of each key determines the dimension
-    of the matrix which it maps, too. For example:
+    Internally, this class stores tensors as instances of
+    :class:`~qiskit_nature.second_q.operators.Tensor`. Refer to its documentation for more details.
+    The storage format maps from string keys to these ``Tensor`` objects. By design, **no**
+    assumptions are made about the *contents* of the keys. However, the length of each key
+    determines the dimension of the tensor which it maps, too. For example (using numpy arrays for
+    the sake of simplicity):
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         import numpy as np
 
         data = {}
         # the empty string, maps to a 0-dimensional matrix, a single number
         data[""] = 1.0
         # a string of length 1, must map to a 1-dimensional array
         data["+"] = np.array([1, 2])
         # a string of length 2, must map to a 2-dimensional array
         data["+-"] = np.array([[1, 2], [3, 4]])
         # ... and so on
 
     In general, the idea is that each character in a key will be associated with the corresponding
-    axis of the matrix, when an operator gets built from the tensor. This means, that the previous
-    example would expand for example like so:
+    axis of the tensor, when an operator gets built from the ``PolynomialTensor`` instance. This
+    means, that the previous example would expand for example like so:
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         from qiskit_nature.second_q.operators import FermionicOp, PolynomialTensor
 
         tensor = PolynomialTensor(data)
         operator = FermionicOp.from_polynomial_tensor(tensor)
 
         print(operator)
+        # Fermionic Operator
+        # number spin orbitals=2, number terms=7
+        #   1.0
+        # + 1 * ( +_0 )
+        # + 2 * ( +_1 )
+        # + 1 * ( +_0 -_0 )
+        # + 2 * ( +_0 -_1 )
+        # + 3 * ( +_1 -_0 )
+        # + 4 * ( +_1 -_1 )
 
     **Algebra**
 
     This class supports the following basic arithmetic operations: addition, subtraction, scalar
     multiplication, and operator multiplication.
     For example,
 
     Addition
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       matrix = np.array([[0, 1], [2, 3]], dtype=float)
       0.5 * PolynomialTensor({"+-": matrix}) + PolynomialTensor({"+-": matrix})
 
     Operator multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       tensor = PolynomialTensor({"+-": matrix})
       print(tensor @ tensor)
 
     Tensor multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       print(tensor ^ tensor)
 
     You can also implement more advanced arithmetic via the :meth:`apply` and :meth:`einsum`
     methods.
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       print(PolynomialTensor.apply(np.transpose, tensor))
       print(PolynomialTensor.apply(np.conjugate, 1j * tensor))
       print(PolynomialTensor.apply(np.kron, tensor, tensor))
 
       print(PolynomialTensor.einsum({"ij,ji": ("+-", "+-", "")}, tensor, tensor))
 
     **Sparse Arrays**
 
-    Furthermore, the ``PolynomialTensor`` supports both, dense numpy arrays and sparse arrays. Since
-    it needs to support more than 2-dimensional arrays, we rely on the
+    Furthermore, since the ``PolynomialTensor`` is building on top of the
+    :class:`~qiskit_nature.second_q.operators.Tensor` class it supports both, dense numpy arrays and
+    sparse arrays. Since it needs to support more than 2-dimensional arrays, we rely on the
     `sparse <https://sparse.pydata.org/en/stable/index.html>`_ library.
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         import sparse as sp
 
         sparse_matrix = sp.as_coo(matrix)
         print(PolynomialTensor({"+-": sparse_matrix}))
 
     One can convert between dense and sparse representation of the same tensor via the
     :meth:`to_dense` and :meth:`to_sparse` methods, respectively.
     """
 
     def __init__(
         self,
-        data: Mapping[str, np.ndarray | SparseArray | Number],
+        data: Mapping[str, np.ndarray | SparseArray | complex | Tensor],
         *,
         validate: bool = True,
     ) -> None:
         """
         Args:
-            data: mapping of string-based operator keys to coefficient matrix values.
+            data: mapping of string-based operator keys to coefficient tensor values. If the values
+                are not already of type :class:`~qiskit_nature.second_q.operators.Tensor`, they will
+                automatically be wrapped into one. Upon retrieval via item access (``__getitem__``)
+                automatically wrapped objects will be unwrapped again depending on the value of
+                :attr:`~qiskit_nature.settings.tensor_unwrapping`.
             validate: when set to False the ``data`` will not be validated. Disable this setting with
                 care!
 
         Raises:
             ValueError: when length of operator key does not match dimensions of value matrix.
             ValueError: when value matrix does not have consistent dimensions.
             ValueError: when some or all value matrices in ``data`` have different dimensions.
         """
-        copy_dict: dict[str, ARRAY_TYPE] = {}
+        copy_dict: dict[str, Tensor] = {}
 
         dim: int | None = None
 
         for key, value in data.items():
-            if isinstance(value, Number):
-                value = np.asarray(value)
+            if not isinstance(value, Tensor):
+                value = Tensor(value)
+                # NOTE: the following monkey patch attribute is used only for the deprecation period
+                # during which this Tensor class is being introduced into the stack
+                value._monkey_patched_unwrap_toggle = True
 
             if validate and len(value.shape) != len(key):
                 raise ValueError(
                     f"Data key {key} of length {len(key)} does not match "
                     f"data value matrix of dimensions {value.shape}"
                 )
 
@@ -222,15 +234,16 @@
 
     @property
     def register_length(self) -> int | None:
         """The size of the operator that can be generated from this ``PolynomialTensor``."""
         for key in self._data:
             if key == "":
                 continue
-            return cast(ARRAY_TYPE, self[key]).shape[0]
+            # TODO: remove unnecessary cast once settings.tensor_unwrapping is removed
+            return cast(Union[np.ndarray, SparseArray, Tensor], self[key]).shape[0]
         return None
 
     def __repr__(self) -> str:
         data_str = f"{dict(self.items())}"
 
         return "PolynomialTensor(" f"{data_str})"
 
@@ -251,105 +264,109 @@
     def is_empty(self) -> bool:
         """Returns whether this tensor is empty or not."""
         return len(self) == 0
 
     @_optionals.HAS_SPARSE.require_in_call
     def is_sparse(self) -> bool:
         """Returns whether all matrices in this tensor are sparse."""
-        return all(isinstance(self[key], SparseArray) for key in self if key != "")
+        # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+        return all(Tensor(self[key]).is_sparse() for key in self if key != "")
 
     def is_dense(self) -> bool:
         """Returns whether all matrices in this tensor are dense."""
-        return all(isinstance(self[key], np.ndarray) for key in self if key != "")
+        # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+        return all(Tensor(self[key]).is_dense() for key in self if key != "")
 
-    def __getitem__(self, __k: str) -> (np.ndarray | SparseArray | Number):
+    def __getitem__(self, __k: str) -> np.ndarray | SparseArray | Number | Tensor:
         """Gets the value from the ``PolynomialTensor``.
 
         Args:
             __k: operator key string in the ``PolynomialTensor``.
 
         Returns:
-            Value corresponding to the operator key ``__k``.
+            Value corresponding to the operator key ``__k``. If
+            :attr:`~qiskit_nature.settings.tensor_unwrapping` is ``False``, the returned is
+            guaranteed to be of type :class:`~qiskit_nature.second_q.operators.Tensor`.
         """
-        return self._data.__getitem__(__k)
+        item = self._data.__getitem__(__k)
+
+        if settings.tensor_unwrapping and hasattr(item, "_monkey_patched_unwrap_toggle"):
+            return item.array
+
+        return item
 
     def __len__(self) -> int:
         """Returns the length of the ``PolynomialTensor``."""
         return self._data.__len__()
 
     def __iter__(self) -> Iterator[str]:
         """Returns an iterator of the ``PolynomialTensor``."""
         return self._data.__iter__()
 
     def to_dense(self) -> PolynomialTensor:
-        """Returns a new instance where all matrices are now dense numpy arrays.
+        """Returns a new instance where all matrices are now dense tensors.
 
         If the instance on which this method was called already fulfilled this requirement, it is
         returned unchanged.
         """
         if self.is_dense():
             return self
 
         _optionals.HAS_SPARSE.require_now("SparseArray")
-        dense_dict: dict[str, ARRAY_TYPE] = {}
+        dense_dict: dict[str, Tensor] = {}
         for key, value in self._data.items():
-            if isinstance(value, SparseArray):
-                dense_dict[key] = value.todense()
-            else:
-                dense_dict[key] = value
+            dense_dict[key] = value.to_dense()
         return PolynomialTensor(dense_dict, validate=False)
 
     # TODO: change the following type-hint if/when SparseArray dictates the existence of from_numpy
     @_optionals.HAS_SPARSE.require_in_call
     def to_sparse(
         self, *, sparse_type: Type[COO] | Type[DOK] | Type[GCXS] = COO
     ) -> PolynomialTensor:
-        """Returns a new instance where all matrices are now sparse arrays.
+        """Returns a new instance where all matrices are now sparse tensors.
 
         If the instance on which this method was called already fulfilled this requirement, it is
         returned unchanged.
 
         Args:
             sparse_type: the type to use for the conversion to sparse matrices. Note, that this will
-                only be applied to matrices which were previously dense numpy arrays. Sparse arrays
-                of another type will not be explicitly converted.
+                only be applied to matrices which were previously dense tensors. Sparse arrays of
+                another type will not be explicitly converted.
 
         Returns:
             A new ``PolynomialTensor`` with all its matrices converted to the requested sparse array
             type.
         """
         if self.is_sparse():
             return self
 
-        sparse_dict: dict[str, ARRAY_TYPE] = {}
+        sparse_dict: dict[str, Tensor] = {}
         for key, value in self._data.items():
-            if isinstance(value, np.ndarray):
-                sparse_dict[key] = sparse_type.from_numpy(value)
-            else:
-                sparse_dict[key] = value
+            sparse_dict[key] = value.to_sparse(sparse_type=sparse_type)
+
         return PolynomialTensor(sparse_dict, validate=False)
 
     def _multiply(self, other: complex) -> PolynomialTensor:
         """Scalar multiplication of a PolynomialTensor with a scalar.
 
         Args:
             other: scalar to be multiplied with the ``PolynomialTensor``.
 
         Returns:
             The new ``PolynomialTensor`` product object.
 
         Raises:
-            TypeError: if ``other`` is not a ``Number``.
+            TypeError: if ``other`` is not a number.
         """
         if not isinstance(other, Number):
             raise TypeError(f"other {other} must be a number")
 
-        prod_dict: dict[str, ARRAY_TYPE] = {}
+        prod_dict: dict[str, Tensor] = {}
         for key, matrix in self._data.items():
-            prod_dict[key] = np.multiply(matrix, other)
+            prod_dict[key] = other * matrix
 
         return PolynomialTensor(prod_dict, validate=False)
 
     def _add(self, other: PolynomialTensor, qargs=None) -> PolynomialTensor:
         """Addition of ``PolynomialTensor`` instances.
 
         Args:
@@ -368,133 +385,88 @@
 
         sum_dict = {key: value + other._data.get(key, 0) for key, value in self._data.items()}
         other_unique = {key: other._data[key] for key in other._data.keys() - self._data.keys()}
         sum_dict.update(other_unique)
 
         return PolynomialTensor(sum_dict, validate=False)
 
-    # pylint: disable=too-many-return-statements
     def __eq__(self, other: object) -> bool:
         """Check equality of ``PolynomialTensor`` instances.
 
         .. note::
-            This check only assert the internal matrix elements for equality but ignores the type of
-            the matrices. As such, it will indicate equality of two ``PolynomialTensor`` instances
-            even if one contains sparse and the other dense numpy arrays, as long as their elements
-            are identical.
+            This check only asserts the internal matrix elements for equality but ignores the type
+            of the matrices. As such, it will indicate equality of two ``PolynomialTensor``
+            instances even if one contains sparse and the other dense numpy arrays, as long as their
+            elements are identical.
 
         Args:
-            other: second ``PolynomialTensor`` object to be compared with the first.
+            other: the second ``PolynomialTensor`` object to be compared with the first.
 
         Returns:
-            True when ``PolynomialTensor`` objects are equal, False when unequal.
+            True when the ``PolynomialTensor`` objects are equal, False when unequal.
         """
         if not isinstance(other, PolynomialTensor):
             return False
 
         if self._data.keys() != other._data.keys():
             return False
 
         for key, value in self._data.items():
             other_value = other._data[key]
 
-            self_is_sparse = isinstance(value, SparseArray)
-            other_is_sparse = isinstance(other_value, SparseArray)
-
-            if self_is_sparse:
-                value = cast(SparseArray, value)
-                if other_is_sparse:
-                    other_value = cast(SparseArray, other_value)
-                    if value.ndim != other_value.ndim:
-                        return False
-                    if value.nnz != other_value.nnz:
-                        return False
-                    if value.size != other_value.size:
-                        return False
-                    diff = value - other_value
-                    if diff.nnz != 0:
-                        return False
-                    continue
-                value = value.todense()
-            elif other_is_sparse:
-                other_value = cast(SparseArray, other_value).todense()
-
-            if not np.array_equal(value, other_value):
+            if value != other_value:
                 return False
 
         return True
 
-    # pylint: disable=too-many-return-statements
     def equiv(self, other: object) -> bool:
         """Check equivalence of ``PolynomialTensor`` instances.
 
         .. note::
-            This check only assert the internal matrix elements for equivalence but ignores the type
-            of the matrices. As such, it will indicate equivalence of two ``PolynomialTensor``
+            This check only asserts the internal matrix elements for equivalence but ignores the
+            type of the matrices. As such, it will indicate equivalence of two ``PolynomialTensor``
             instances even if one contains sparse and the other dense numpy arrays, as long as their
             elements match.
 
         Args:
-            other: second ``PolynomialTensor`` object to be compared with the first.
+            other: the second ``PolynomialTensor`` object to be compared with the first.
 
         Returns:
-            True when ``PolynomialTensor`` objects are equivalent, False when not.
+            True when the ``PolynomialTensor`` objects are equivalent, False when not.
         """
         if not isinstance(other, PolynomialTensor):
             return False
 
         if self._data.keys() != other._data.keys():
             return False
 
         for key, value in self._data.items():
             other_value = other._data[key]
 
-            self_is_sparse = isinstance(value, SparseArray)
-            other_is_sparse = isinstance(other_value, SparseArray)
-
-            if self_is_sparse:
-                value = cast(SparseArray, value)
-                if other_is_sparse:
-                    other_value = cast(SparseArray, other_value)
-                    if value.ndim != other_value.ndim:
-                        return False
-                    diff = value - other_value
-                    if not np.allclose(
-                        diff.todense(),
-                        zeros_like(diff).todense(),
-                        atol=self.atol,
-                        rtol=self.rtol,
-                    ):
-                        return False
-                    continue
-                value = value.todense()
-            elif other_is_sparse:
-                other_value = cast(SparseArray, other_value).todense()
-
-            if not np.allclose(value, other_value, atol=self.atol, rtol=self.rtol):
+            if not value.equiv(other_value):
                 return False
 
         return True
 
     def compose(
         self, other: PolynomialTensor, qargs: None = None, front: bool = False
     ) -> PolynomialTensor:
         r"""Returns the matrix multiplication with another ``PolynomialTensor``.
 
         Args:
             other: the other PolynomialTensor.
             qargs: UNUSED.
-            front: If True composition uses right matrix multiplication, otherwise left
+            front: If ``True``, composition uses right matrix multiplication, otherwise left
                 multiplication is used (the default).
 
         Raises:
             NotImplementedError: when the two tensors do not have the same :attr:`register_length`.
 
         Returns:
-            The operator resulting from the composition.
+            The tensor resulting from the composition.
 
         .. note::
             Composition (``&``) by default is defined as `left` matrix multiplication for operators,
             while ``@`` (equivalent to :meth:`dot`) is defined as `right` matrix multiplication.
             This means that ``A & B == A.compose(B)`` is equivalent to ``B @ A == B.dot(A)`` when
             ``A`` and ``B`` are of the same type.
 
@@ -504,22 +476,27 @@
         """
         a = self if front else other
         b = other if front else self
 
         if a.register_length != b.register_length:
             raise NotImplementedError()
 
-        new_data: dict[str, ARRAY_TYPE | Number] = {}
+        new_data: dict[str, Tensor] = {}
         for akey, bkey in product(a, b):
             new_key = akey + bkey
 
-            amat = cast(ARRAY_TYPE, a[akey])
-            bmat = cast(ARRAY_TYPE, b[bkey])
+            atensor = a[akey]
+            btensor = b[bkey]
+            # TODO: remove these once settings.tensor_unwrapping is removed
+            if not isinstance(atensor, Tensor):
+                atensor = Tensor(atensor)
+            if not isinstance(btensor, Tensor):
+                btensor = Tensor(btensor)
 
-            outer = np.outer(amat, bmat).reshape(amat.shape + bmat.shape)
+            outer = atensor.compose(btensor, qargs=qargs, front=True)
 
             if new_key in new_data:
                 new_data[new_key] = new_data[new_key] + outer
             else:
                 new_data[new_key] = outer
 
         return PolynomialTensor(new_data)
@@ -536,15 +513,15 @@
         Returns:
             The tensor resulting from the tensor product, :math:`self \otimes other`.
 
         .. note::
             The tensor product can be obtained using the ``^`` binary operator.
             Hence ``a.tensor(b)`` is equivalent to ``a ^ b``.
 
-        .. note:
+        .. note::
             Tensor uses reversed operator ordering to :meth:`expand`.
             For two tensors of the same type ``a.tensor(b) = b.expand(a)``.
         """
         return self._tensor(self, other)
 
     def expand(self, other: PolynomialTensor) -> PolynomialTensor:
         r"""Returns the reverse-order tensor product with another ``PolynomialTensor``.
@@ -552,71 +529,52 @@
         Args:
             other: the other PolynomialTensor.
 
         Raises:
             NotImplementedError: when the two tensors do not have the same :attr:`register_length`.
 
         Returns:
-            The tensor resulting from the tensor product, :math:`othr \otimes self`.
+            The tensor resulting from the tensor product, :math:`other \otimes self`.
 
-        .. note:
+        .. note::
             Expand is the opposite operator ordering to :meth:`tensor`.
             For two tensors of the same type ``a.expand(b) = b.tensor(a)``.
         """
         return self._tensor(other, self)
 
     @classmethod
     def _tensor(cls, a: PolynomialTensor, b: PolynomialTensor) -> PolynomialTensor:
         if a.register_length != b.register_length:
             raise NotImplementedError()
 
-        # NOTE: mypy really does not like Number, so a lot of casts are necessary for the time being
-        new_data: dict[str, ARRAY_TYPE | Number] = {}
+        new_data: dict[str, Tensor] = {}
         for akey, bkey in product(a, b):
-            # expand a-matrix into upper left sector
-            amat = cast(ARRAY_TYPE, a[akey])
-            adim = len(amat.shape)
-            aones = np.zeros((2,) * adim)
-            aones[(0,) * adim] = 1.0
-            amat = np.kron(aones, amat)
-            aeinsum = string.ascii_lowercase[:adim] if adim > 0 else ""
-
-            # expand b-matrix into lower right sector
-            bmat = cast(ARRAY_TYPE, b[bkey])
-            bdim = len(bmat.shape)
-            bones = np.zeros((2,) * bdim)
-            bones[(1,) * bdim] = 1.0
-            bmat = np.kron(bones, bmat)
-            beinsum = string.ascii_lowercase[-bdim:] if bdim > 0 else ""
-
-            make_sparse = False
-            if isinstance(amat, SparseArray):
-                # pylint: disable=no-member
-                amat = amat.todense()
-                make_sparse = True
-            if isinstance(bmat, SparseArray):
-                # pylint: disable=no-member
-                bmat = bmat.todense()
-                make_sparse = True
-            einsum = np.einsum(f"{aeinsum},{beinsum}", amat, bmat)
-            if make_sparse:
-                einsum = COO(einsum)
+
+            atensor = a[akey]
+            btensor = b[bkey]
+            # TODO: remove these once settings.tensor_unwrapping is removed
+            if not isinstance(atensor, Tensor):
+                atensor = Tensor(atensor)
+            if not isinstance(btensor, Tensor):
+                btensor = Tensor(btensor)
+
+            einsum = atensor.tensor(btensor)
 
             new_key = akey + bkey
             if new_key in new_data:
                 new_data[new_key] = new_data[new_key] + einsum
             else:
                 new_data[new_key] = einsum
 
         return PolynomialTensor(new_data)
 
     @classmethod
     def apply(
         cls,
-        function: Callable[..., np.ndarray | SparseArray | Number],
+        function: Callable[..., np.ndarray | SparseArray | complex],
         *operands: PolynomialTensor,
         validate: bool = True,
     ) -> PolynomialTensor:
         """Applies the provided function to the common set of keys of the provided tensors.
 
         The usage of this method is best explained by some examples:
 
@@ -659,17 +617,17 @@
             validate: when set to False the `data` will not be validated. Disable this setting with
                 care!
 
         Returns:
             A new ``PolynomialTensor`` instance with the resulting arrays.
         """
         common_keys = set.intersection(*(set(op) for op in operands))
-        new_data: dict[str, ARRAY_TYPE | Number] = {}
+        new_data: dict[str, Tensor] = {}
         for key in common_keys:
-            new_data[key] = function(*(op[key] for op in operands))
+            new_data[key] = cast(Tensor, function(*(op[key] for op in operands)))
         return cls(new_data, validate=validate)
 
     @classmethod
     def einsum(
         cls,
         einsum_map: dict[str, tuple[str, ...]],
         *operands: PolynomialTensor,
@@ -719,41 +677,46 @@
             transformed = PolynomialTensor.einsum(
                 einsum_map, hamiltonian, mo_coeff, mo_coeff, mo_coeff, mo_coeff
             )
             # results will be contained in transformed["+-"] and transformed["++--"], respectively
 
         .. note::
 
-           :class:`sparse.SparseArray` does not support ``numpy.einsum``. Thus, the resultant
+           :class:`sparse.SparseArray` supports ``opt_einsum.contract` if ``opt_einsum`` is installed.
+           It does not support ``numpy.einsum``. In this case, the resultant
            ``PolynomialTensor`` will contain all dense numpy arrays. If a user would like to work
-           with a sparse array instead, they should convert it explicitly using the
-           :meth:`to_sparse` method.
+           with a sparse array instead, they should install ``opt_einsum`` or
+           they should convert it explicitly using the :meth:`to_sparse` method.
 
         Args:
             einsum_map: a dictionary, mapping from :meth:`numpy.einsum` subscripts to a tuple of
                 strings. These strings correspond to the keys of matrices to be extracted from the
                 provided ``PolynomialTensor`` operands. The last string in this tuple indicates the
                 key under which to store the result in the returned ``PolynomialTensor``.
             operands: a sequence of ``PolynomialTensor`` instances on which to operate.
             validate: when set to False the `data` will not be validated. Disable this setting with
                 care!
 
         Returns:
             A new ``PolynomialTensor``.
         """
-        dense_operands = [op.to_dense() for op in operands]
-        new_data: dict[str, ARRAY_TYPE] = {}
+        einsum_func, uses_sparse = get_einsum()
+        operand_list = list(operands) if uses_sparse else [op.to_dense() for op in operands]
+        new_data: dict[str, Tensor] = {}
         for einsum, terms in einsum_map.items():
             *inputs, output = terms
             try:
-                result = np.einsum(
-                    einsum,
-                    *[dense_operands[idx]._data[term] for idx, term in enumerate(inputs)],
-                    optimize=settings.optimize_einsum,
-                )
+                # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+                ops = []
+                for idx, term in enumerate(inputs):
+                    op = operand_list[idx]._data[term]
+                    if not isinstance(op, Tensor):
+                        op = Tensor(op)
+                    ops.append(op)
+                result = einsum_func(einsum, *ops, optimize=settings.optimize_einsum)
             except KeyError:
                 continue
             if output in new_data:
                 new_data += result
             else:
                 new_data[output] = result
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/sparse_label_op.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/sparse_label_op.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -28,15 +28,15 @@
     LinearMixin,
     TolerancesMixin,
 )
 
 from .polynomial_tensor import PolynomialTensor
 
 
-_TCoeff = Union[complex, ParameterExpression]
+_TCoeff = Union[complex, ParameterExpression]  # pylint: disable=invalid-name
 
 
 def _to_number(a: _TCoeff) -> complex:
     if isinstance(a, ParameterExpression):
         sympified = a.sympify()
         return complex(sympified) if sympified.is_Number else np.nan
     return a
@@ -507,15 +507,17 @@
         Args:
             parameters: The mapping from parameters to new parameters or values.
 
         Returns:
             A new operator with the parameters assigned.
         """
         data = {
-            key: parameters[value] if value in parameters else value
+            key: value.bind(parameters, allow_unknown_parameters=True)
+            if isinstance(value, ParameterExpression)
+            else value
             for key, value in self._data.items()
         }
         return self._new_instance(data, other=self)
 
     def round(self, decimals: int = 0) -> SparseLabelOp:
         """Rounds the operator coefficients to a specified number of decimal places.
 
@@ -539,15 +541,15 @@
 
         Returns:
             If operator length is zero or all coefficients are zero.
         """
         if len(self) == 0:
             return True
         tol = tol if tol is not None else self.atol
-        return all(np.isclose(val, 0, atol=tol) for val in self._data.values())
+        return all(np.isclose(_to_number(val), 0, atol=tol) for val in self._data.values())
 
     def parameters(self) -> list[ParameterExpression]:
         """Returns a list of the parameters in the operator.
 
         Returns:
             A list of the parameters in the operator.
         """
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/spin_op.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/spin_op.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -26,18 +26,18 @@
 from typing import cast, Iterator
 from fractions import Fraction
 from functools import partial, reduce
 
 import numpy as np
 
 from qiskit_nature import QiskitNatureError
-import qiskit_nature.optionals as _optionals
 
 from .polynomial_tensor import PolynomialTensor
 from .sparse_label_op import _TCoeff, SparseLabelOp, _to_number
+from .tensor import Tensor
 
 
 class SpinOp(SparseLabelOp):
     """XYZ Spin operator.
 
     A ``SpinOp`` represents a weighted sum of spin operator terms with a certain spin
     value associated to them. This value can be an integer for bosonic particles or
@@ -57,26 +57,26 @@
     :code:`<power>`, implying a single application of the operator (:code:`power = 1`).
 
     **Initialization**
 
     A ``SpinOp`` is initialized with a dictionary, mapping terms to their respective
     coefficients. For example:
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         from qiskit_nature.second_q.operators import SpinOp
 
         x = SpinOp({"X_0": 1}, spin=3/2)
         y = SpinOp({"Y_0": 1}, spin=3/2)
         z = SpinOp({"Z_0": 1}, spin=3/2)
 
     are :math:`S^x, S^y, S^z` for spin 3/2 system.
     The two qutrit Heisenberg model with transverse magnetic field is
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         SpinOp({
                 "X_0 X_1": -1,
                 "Y_0 Y_1": -1,
                 "Z_0 Z_1": -1,
                 "Z_0": -0.3,
                 "Z_1": -0.3,
@@ -84,26 +84,26 @@
             spin=1
         )
 
     This means :math:`- S^x_0 S^x_1 - S^y_0 S^y_1 - S^z_0 S^z_1 - 0.3 S^z_0 - 0.3 S^z_1`.
 
     An example using labels with powers would be:
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         from qiskit_nature.second_q.operators import SpinOp
 
         op = SpinOp({"X_0^2 Y_1^3 Z_0": 1})
 
 
     By default, this way of initializing will create a full copy of the dictionary of coefficients.
     If you have very restricted memory resources available, or would like to avoid the additional
     copy, the dictionary will be stored by reference if you disable ``copy`` like so:
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         some_big_data = {
             "X_0 Y_0": 1.0,
             "X_1 Y_1": -1.0,
             # ...
         }
 
@@ -129,48 +129,48 @@
     subtraction, composition, and tensoring) are only supported for identical spins
     (``op_1.num_spins == op_2.num_spins``).
 
     For example,
 
     Addition
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         SpinOp({"X_1": 1}, num_spins=2) + SpinOp({"X_0": 1}, num_spins=2)
 
     Sum
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         sum(SpinOp({label: 1}, num_spins=3) for label in ["X_0", "Z_1", "X_2 Z_2"])
 
     Scalar multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         0.5 * SpinOp({"X_1": 1}, num_spins=2)
 
     Operator multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         op1 = SpinOp({"X_0 Z_1": 1}, num_spins=2)
         op2 = SpinOp({"Z_0 X_0 X_1": 1}, num_spins=2)
         print(op1 @ op2)
 
     Tensor multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         op = SpinOp({"X_0 Z_1": 1}, num_spins=2)
         print(op ^ op)
 
     Adjoint
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         SpinOp({"X_0 Z_1": 1j}, num_spins=2).adjoint()
 
 
     **Iteration**
 
     Instances of ``SpinOp`` are iterable. Iterating a SpinOp yields (term, coefficient)
@@ -300,31 +300,25 @@
 
         for key in tensor:
             if key == "":
                 # TODO: deal with complexity
                 data[""] = cast(float, tensor[key])
                 continue
 
-            label_template = " ".join(f"{op}_{{}}" for op in key)
+            mat = tensor[key]
 
-            # PERF: the following matrix unpacking is a performance bottleneck!
-            # We could consider using Rust in the future to improve upon this.
+            if not isinstance(mat, Tensor):
+                # TODO: this case is to be removed once qiskit_nature.settings.tensor_unwrapping is
+                # deprecated and the PolynomialTensor item is guaranteed to be of type Tensor
+                mat = Tensor(mat)
 
-            mat = tensor[key]
-            if isinstance(mat, np.ndarray):
-                for index in np.ndindex(*mat.shape):
-                    data[label_template.format(*index)] = mat[index]
-            else:
-                _optionals.HAS_SPARSE.require_now("SparseArray")
-                import sparse as sp  # pylint: disable=import-error
-
-                if isinstance(mat, sp.SparseArray):
-                    coo = sp.as_coo(mat)
-                    for value, *index in zip(coo.data, *coo.coords):
-                        data[label_template.format(*index)] = value
+            label_template = mat.label_template.format(*key)
+
+            for value, index in mat.coord_iter():
+                data[label_template.format(*index)] = value
 
         return cls(data, copy=False, num_spins=tensor.register_length).chop()
 
     @staticmethod
     def _split_label(label) -> Iterator[tuple[str, int, int]]:
         """Helper method to iterate over label splits.
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/tensor_ordering.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/tensor_ordering.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -27,20 +27,24 @@
    IndexType
 
 """
 
 from __future__ import annotations
 
 from enum import Enum
+from typing import TYPE_CHECKING
 
 import numpy as np
 
 from qiskit_nature import QiskitNatureError
 import qiskit_nature.optionals as _optionals
 
+if TYPE_CHECKING:
+    from .symmetric_two_body import SymmetricTwoBodyIntegrals
+
 if _optionals.HAS_SPARSE:
     # pylint: disable=import-error
     from sparse import SparseArray
 else:
 
     class SparseArray:  # type: ignore
         """Empty SparseArray class
@@ -234,15 +238,15 @@
     for permutation in _ChemIndexPermutations:
         if not _check_two_body_symmetry(two_body_tensor, permutation.value, rtol=rtol, atol=atol):
             return False
     return True
 
 
 def find_index_order(
-    two_body_tensor: np.ndarray | SparseArray,
+    two_body_tensor: np.ndarray | SparseArray | SymmetricTwoBodyIntegrals,
     *,
     rtol: float = 1e-5,
     atol: float = 1e-8,
 ) -> IndexType:
     """Return the index-order convention of the provided rank-four tensor.
 
     The index convention is determined by checking symmetries of the tensor.
@@ -263,14 +267,19 @@
         two_body_tensor: the rank-four tensor whose index order to determine.
         rtol: the relative tolerance used during the comparison.
         atol: the absolute tolerance used during the comparison.
 
     Returns:
         The index order of the provided rank-four tensor.
     """
+    from .symmetric_two_body import SymmetricTwoBodyIntegrals
+
+    if isinstance(two_body_tensor, SymmetricTwoBodyIntegrals):
+        return IndexType.CHEMIST
+
     if _check_two_body_symmetries(two_body_tensor, rtol=rtol, atol=atol):
         return IndexType.CHEMIST
     permuted_tensor = _phys_to_chem(two_body_tensor)
     if _check_two_body_symmetries(permuted_tensor, rtol=rtol, atol=atol):
         return IndexType.PHYSICIST
     permuted_tensor = _phys_to_chem(permuted_tensor)
     if _check_two_body_symmetries(permuted_tensor, rtol=rtol, atol=atol):
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/operators/vibrational_op.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/operators/vibrational_op.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -21,19 +21,19 @@
 import logging
 import operator
 import itertools
 
 import numpy as np
 
 from qiskit_nature.exceptions import QiskitNatureError
-import qiskit_nature.optionals as _optionals
 
 from ._bits_container import _BitsContainer
 from .polynomial_tensor import PolynomialTensor
 from .sparse_label_op import _TCoeff, SparseLabelOp, _to_number
+from .tensor import Tensor
 
 logger = logging.getLogger(__name__)
 
 
 class VibrationalOp(SparseLabelOp):
     r"""N-mode vibrational operator.
 
@@ -45,15 +45,15 @@
     operation is to be performed.
 
     **Initialization**
 
     A ``VibrationalOp`` is initialized with a dictionary, mapping terms to their respective
     coefficients:
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         from qiskit_nature.second_q.operators import VibrationalOp
 
         op = VibrationalOp(
             {
                 "+_0_0 -_0_0": 1.0,
                 "+_0_1 -_0_1": 1.0,
@@ -63,15 +63,15 @@
             num_modals=[2, 2]
         )
 
     By default, this way of initializing will create a full copy of the dictionary of coefficients.
     If you have very restricted memory resources available, or would like to avoid the additional
     copy, the dictionary will be stored by reference if you disable ``copy`` like so:
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         some_big_data = {
             "+_0_0 -_0_0": 1.0,
             "+_0_1 -_0_1": 1.0,
             # ...
         }
 
@@ -86,15 +86,15 @@
         It is the users' responsibility, that in the above scenario, :code:`some_big_data` is not
         changed after initialization of the ``VibrationalOp``, since the operator contents are not
         guaranteed to remain unaffected by such changes.
 
     If :code:`num_modals` is not provided then the maximum :code:`modal_index` per
     mode will determine the :code:`num_modals` for that mode.
 
-    .. jupyter-execute::
+    .. code-block:: python
 
         from qiskit_nature.second_q.operators import VibrationalOp
 
         op = VibrationalOp(
             {
                 "+_0_0 -_0_0": 1.0,
                 "+_0_1 -_0_1": 1.0,
@@ -108,61 +108,50 @@
 
     This class supports the following basic arithmetic operations: addition, subtraction, scalar
     multiplication, operator multiplication, and adjoint.
     For example,
 
     Addition
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       VibrationalOp({"+_1_0": 1}, num_modals=[2, 2]) + VibrationalOp({"+_0_0": 1}, num_modals=[2, 2])
 
     Sum
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       sum(VibrationalOp({label: 1}, num_modals=[1, 1, 1]) for label in ["+_0_0", "-_1_0", "+_2_0 -_2_0"])
 
     Scalar multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       0.5 * VibrationalOp({"+_1_0": 1}, num_modals=[1, 1])
 
     Operator multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       op1 = VibrationalOp({"+_0_0 -_1_0": 1}, num_modals=[1, 1])
       op2 = VibrationalOp({"-_0_0 +_0_0 +_1_0": 1}, num_modals=[1, 1])
       print(op1 @ op2)
 
     Tensor multiplication
 
-    .. jupyter-execute::
+    .. code-block:: python
 
       op = VibrationalOp({"+_0_0 -_1_0": 1}, num_modals=[1, 1])
       print(op ^ op)
 
     Adjoint
 
-    .. jupyter-execute::
-
-      VibrationalOp({"+_0_0 -_1_0": 1j}, num_modals=[1, 1]).adjoint()
-
-    In principle, you can also add :class:`VibrationalOp` and integers, but the only valid case is the
-    addition of `0 + VibrationalOp`. This makes the `sum` operation from the example above possible
-    and it is useful in the following scenario:
-
     .. code-block:: python
 
-        vibrational_op = 0
-        for i in some_iterable:
-            # some processing
-            vibrational_op += VibrationalOp(somedata)
+      VibrationalOp({"+_0_0 -_1_0": 1j}, num_modals=[1, 1]).adjoint()
 
     **Iteration**
 
     Instances of ``VibrationalOp`` are iterable. Iterating a ``VibrationalOp`` yields (term, coefficient)
     pairs describing the terms contained in the operator.
 
     .. note::
@@ -295,28 +284,25 @@
 
         for key in tensor:
             if key == "":
                 # TODO: deal with complexity
                 data[""] = cast(float, tensor[key])
                 continue
 
-            label_template = " ".join(f"{op}_{{}}_{{}}" for op in key.replace("_", ""))
-
             mat = tensor[key]
-            if isinstance(mat, np.ndarray):
-                for index in np.ndindex(*mat.shape):
-                    data[label_template.format(*_reshape_index(index))] = mat[index]
-            else:
-                _optionals.HAS_SPARSE.require_now("SparseArray")
-                import sparse as sp  # pylint: disable=import-error
-
-                if isinstance(mat, sp.SparseArray):
-                    coo = sp.as_coo(mat)
-                    for value, *index in zip(coo.data, *coo.coords):
-                        data[label_template.format(*_reshape_index(index))] = value
+
+            if not isinstance(mat, Tensor):
+                # TODO: this case is to be removed once qiskit_nature.settings.tensor_unwrapping is
+                # deprecated and the PolynomialTensor item is guaranteed to be of type Tensor
+                mat = Tensor(mat)
+
+            label_template = mat.label_template.format(*key.replace("_", ""))
+
+            for value, index in mat.coord_iter():
+                data[label_template.format(*_reshape_index(index))] = value
 
         return cls(data)
 
     def __repr__(self) -> str:
         data_str = f"{dict(self.items())}"
 
         return "VibrationalOp(" f"{data_str}, " f"num_modals={self.num_modals}, " ")"
@@ -456,14 +442,21 @@
                 left = terms[j - 1]
 
                 if right[0] == "+" and left[0] == "-":
                     # swap terms where an annihilation operator is left of a creation operator
                     terms[j - 1] = right
                     terms[j] = left
 
+                    if right[1] == left[1] and right[2] == left[2]:
+                        # if their indices are identical, we incur an additional term because of:
+                        # a_i a_i^\dagger = 1 + a_i^\dagger a_i
+                        new_terms = terms[: (j - 1)] + terms[(j + 1) :]
+                        # we can do so by recursion on this method
+                        ordered_op += self._normal_order(new_terms, coeff)
+
                 elif right[0] == left[0]:
                     # when we have identical neighboring operators, differentiate two cases:
 
                     # on identical index, this is an invalid operation which evaluates to
                     # zero: e.g. +_0_0 +_0_0 = 0
                     if right[1] == left[1] and right[2] == left[2]:
                         # thus, we bail on this recursion call
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/eigenstate_result.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/eigenstate_result.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -42,22 +42,25 @@
 
     Attributes:
         eigenvalues (np.ndarray | None): the computed eigenvalues.
         eigenstates (list[tuple[QuantumCircuit, Sequence[float] | None]] | None): the eigenstates
             belonging to each of the computed eigenvalues.
         aux_operators_evaluated (list[ListOrDict[complex]] | None): the evaluated aux operators.
         raw_result (AlgorithmResult | None): the raw result, wrapped by this ``EigenstateResult``.
+        formatting_precision (int): the number of decimal places to use when formatting the result
+            for printing.
     """
 
     def __init__(self) -> None:
         super().__init__()
         self.eigenvalues: np.ndarray | None = None
         self.eigenstates: list[tuple[QuantumCircuit, Sequence[float] | None]] | None = None
         self.aux_operators_evaluated: list[ListOrDict[complex]] | None = None
         self.raw_result: AlgorithmResult | None = None
+        self.formatting_precision: int = 12
 
     @property
     def groundenergy(self) -> float | None:
         """Returns the lowest eigenvalue."""
         energies = self.eigenvalues
         if isinstance(energies, np.ndarray) and energies.size:
             return energies[0].real
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/electronic_basis.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/electronic_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/electronic_properties_container.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/electronic_properties_container.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/electronic_structure_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/electronic_structure_problem.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """The Electronic Structure Problem class."""
 
 from __future__ import annotations
 
+import warnings
 from functools import partial
 from typing import cast, Callable, List, Optional, Union, TYPE_CHECKING
 
 import numpy as np
 
 from qiskit.algorithms.eigensolvers import EigensolverResult
 from qiskit.algorithms.minimum_eigensolvers import MinimumEigensolverResult
-from qiskit.opflow.primitive_ops import Z2Symmetries
+from qiskit.opflow.primitive_ops import Z2Symmetries as OpflowZ2Symmetries
+from qiskit.quantum_info.analysis.z2_symmetries import Z2Symmetries
 
+from qiskit_nature.deprecation import deprecate_function, warn_deprecated_type
 from qiskit_nature.exceptions import QiskitNatureError
 from qiskit_nature.second_q.circuit.library.initial_states.hartree_fock import (
     hartree_fock_bitstring_mapped,
 )
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
 from qiskit_nature.second_q.hamiltonians import ElectronicEnergy
 from qiskit_nature.second_q.properties import Interpretable
 
 from .electronic_structure_result import ElectronicStructureResult
 from .electronic_properties_container import ElectronicPropertiesContainer
 from .eigenstate_result import EigenstateResult
 
@@ -55,15 +58,16 @@
     eigenvalue. When passed to a :class:`qiskit_nature.second_q.algorithms.GroundStateSolver`, you
     will be solving for the ground-state energy, :math:`E_0`.
 
     This class has various attributes (see below) which allow you to add additional information
     about the problem which you are trying to solve, which can be used by various modules in the
     stack. For example, specifying the number of particles in the system :attr:`num_particles` is
     useful (and even required) for many components that interact with this problem instance to make
-    your life easier (for example the :class:`qiskit_nature.second_q.algorithms.VQEUCCFactory`).
+    your life easier (for example the
+    :class:`qiskit_nature.second_q.transformers.ActiveSpaceTransformer`).
 
     In the fermionic case the default filter ensures that the number of particles is being
     preserved.
 
     .. note::
 
         The default filter_criterion assumes a singlet spin configuration. This means, that the
@@ -71,29 +75,30 @@
         If the :class:`~qiskit_nature.second_q.properties.AngularMomentum`
         property is available, one can correctly filter a non-singlet spin configuration with a
         custom `filter_criterion` similar to the following:
 
     .. code-block:: python
 
         import numpy as np
-        from qiskit_nature.second_q.algorithms import NumPyEigensolverFactory
+        from qiskit.algorithms.minimum_eigensolvers import NumPyMinimumEigensolver
 
         expected_spin = 2
         expected_num_electrons = 6
 
         def filter_criterion_custom(eigenstate, eigenvalue, aux_values):
             num_particles_aux = aux_values["ParticleNumber"][0]
             total_angular_momentum_aux = aux_values["AngularMomentum"][0]
 
             return (
                 np.isclose(total_angular_momentum_aux, expected_spin) and
                 np.isclose(num_particles_aux, expected_num_electrons)
             )
 
-        solver = NumPyEigensolverFactory(filter_criterion=filter_criterion_custom)
+        solver = NumPyEigensolver()
+        solver.filter_criterion = filter_criterion_custom
 
     The following attributes can be read and updated once the ``ElectronicStructureProblem`` object
     has been constructed.
 
     Attributes:
         properties (ElectronicStructureProblem): a container for additional observable operator
             factories.
@@ -184,14 +189,15 @@
         num_orbs = self.num_spatial_orbitals
         if num_orbs is None:
             return None
 
         num_alpha = self.num_alpha
         if num_alpha is None:
             return None
+
         return np.asarray([1.0] * num_alpha + [0.0] * (num_orbs - num_alpha))
 
     @orbital_occupations.setter
     def orbital_occupations(self, occ: np.ndarray | None) -> None:
         self._orbital_occupations = occ
 
     @property
@@ -263,26 +269,36 @@
                 return num_particles_close
             angular_momentum_close = np.isclose(eval_angular_momentum[0], 0.0)
 
             return num_particles_close and angular_momentum_close
 
         return partial(filter_criterion, self)
 
+    # pylint: disable=bad-docstring-quotes
+    @deprecate_function(
+        "0.6.0",
+        additional_msg=(
+            ". This function is deprecated because it has been removed from the public API. It is "
+            "no longer necessary to be used when working directly with QubitMapper objects outside "
+            "a QubitConverter because a TaperedQubitMapper can now be obtained using the new "
+            "get_tapered_mapper function provided by the problem classes."
+        ),
+    )
     def symmetry_sector_locator(
         self,
-        z2_symmetries: Z2Symmetries,
-        converter: QubitConverter,
+        z2_symmetries: OpflowZ2Symmetries | Z2Symmetries,
+        converter: QubitConverter | QubitMapper,
     ) -> Optional[List[int]]:
         """Given the detected Z2Symmetries this determines the correct sector of the tapered
         operator that contains the ground state we need and returns that information.
 
         Args:
             z2_symmetries: the z2 symmetries object.
-            converter: the qubit converter instance used for the operator conversion that
-                symmetries are to be determined for.
+            converter: the ``QubitConverter`` or ``QubitMapper`` instance used for the operator
+                conversion that symmetries are to be determined for.
 
         Raises:
             QiskitNatureError: if the :attr:`num_particles` attribute is ``None``.
 
         Returns:
             The sector of the tapered operators with the problem solution.
         """
@@ -297,26 +313,78 @@
         num_particles = self.num_particles
         if not isinstance(num_particles, tuple):
             num_particles = (self.num_alpha, self.num_beta)
 
         # We need the HF bitstring mapped to the qubit space but without any tapering done
         # by the converter (just qubit mapping and any two qubit reduction) since we are
         # going to determine the tapering sector
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            hf_bitstr = hartree_fock_bitstring_mapped(
+                num_spatial_orbitals=self.num_spatial_orbitals,
+                num_particles=num_particles,
+                qubit_mapper=converter,
+                match_convert=False,
+            )
+        sector = ElectronicStructureProblem._pick_sector(z2_symmetries, hf_bitstr)
+
+        return sector
+
+    def _symmetry_sector_locator(
+        self,
+        z2_symmetries: OpflowZ2Symmetries | Z2Symmetries,
+        mapper: QubitConverter | QubitMapper,
+    ) -> Optional[List[int]]:
+        """Given the detected Z2Symmetries this determines the correct sector of the tapered
+        operator that contains the ground state we need and returns that information.
+
+        Args:
+            z2_symmetries: the z2 symmetries object.
+            mapper: the ``QubitMapper`` or ``QubitConverter`` instance (use of the latter is
+                deprecated) used for the operator conversion that symmetries are to be determined
+                for.
+
+        Raises:
+            QiskitNatureError: if the :attr:`num_particles` attribute is ``None``.
+
+        Returns:
+            The sector of the tapered operators with the problem solution.
+        """
+        if self.num_particles is None:
+            raise QiskitNatureError(
+                "Determining the correct symmetry sector for Z2 symmetry reduction requires the "
+                "number of particles to be set on the problem instance. Please set "
+                "ElectronicStructureProblem.num_particles or disable the use of Z2Symmetries to "
+                "fix this."
+            )
+        if isinstance(mapper, QubitConverter):
+            warn_deprecated_type(
+                "0.6.0",
+                argument_name="mapper",
+                old_type="QubitConverter",
+                new_type="QubitMapper",
+            )
+
+        num_particles = self.num_particles
+        if not isinstance(num_particles, tuple):
+            num_particles = (self.num_alpha, self.num_beta)
+
         hf_bitstr = hartree_fock_bitstring_mapped(
             num_spatial_orbitals=self.num_spatial_orbitals,
             num_particles=num_particles,
-            qubit_converter=converter,
-            match_convert=False,
+            qubit_mapper=mapper,
         )
         sector = ElectronicStructureProblem._pick_sector(z2_symmetries, hf_bitstr)
 
         return sector
 
     @staticmethod
-    def _pick_sector(z2_symmetries: Z2Symmetries, hf_str: List[bool]) -> List[int]:
+    def _pick_sector(
+        z2_symmetries: OpflowZ2Symmetries | Z2Symmetries, hf_str: List[bool]
+    ) -> List[int]:
         # Finding all the symmetries using the find_Z2_symmetries:
         taper_coeff: List[int] = []
         for sym in z2_symmetries.symmetries:
             coeff = -1 if np.logical_xor.reduce(np.logical_and(sym.z, hf_str)) else 1
             taper_coeff.append(coeff)
 
         return taper_coeff
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/electronic_structure_result.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/electronic_structure_result.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -158,14 +158,16 @@
                 tdm.append(np.sqrt(np.sum(np.power(list(dip), 2))))
         return tdm
 
     @property
     def total_dipole_moment_in_debye(self) -> Optional[List[float]]:
         """Returns total dipole of moment in Debye"""
         tdm = self.total_dipole_moment
+        if tdm is None:
+            return None
         return [dip / DEBYE if dip is not None else None for dip in tdm]
 
     @property
     def dipole_moment(self) -> Optional[List[DipoleTuple]]:
         """Returns dipole moment"""
         edm = self.electronic_dipole_moment
         if edm is None:
@@ -307,44 +309,50 @@
         """Formatted result as a list of strings"""
         lines = []
         lines.append("=== GROUND STATE ENERGY ===")
         lines.append(" ")
         if self.electronic_energies is not None:
             lines.append(
                 "* Electronic ground state energy (Hartree): "
-                f"{_complex_to_string(self.electronic_energies[0], 12)}"
+                f"{_complex_to_string(self.electronic_energies[0], self.formatting_precision)}"
             )
             lines.append(
-                f"  - computed part:      {_complex_to_string(self.computed_energies[0], 12)}"
+                "  - computed part:      "
+                f"{_complex_to_string(self.computed_energies[0], self.formatting_precision)}"
             )
             for name, value in self.extracted_transformer_energies.items():
-                lines.append(f"  - {name} extracted energy part: {_complex_to_string(value, 12)}")
+                lines.append(
+                    "  - {name} extracted energy part: "
+                    f"{_complex_to_string(value, self.formatting_precision)}"
+                )
         if self.nuclear_repulsion_energy is not None:
             lines.append(
                 "~ Nuclear repulsion energy (Hartree): "
-                f"{_complex_to_string(self.nuclear_repulsion_energy, 12)}"
+                f"{_complex_to_string(self.nuclear_repulsion_energy, self.formatting_precision)}"
             )
             lines.append(
                 "> Total ground state energy (Hartree): "
-                f"{_complex_to_string(self.total_energies[0], 12)}"
+                f"{_complex_to_string(self.total_energies[0], self.formatting_precision)}"
             )
 
         if self.computed_energies is not None and len(self.computed_energies) > 1:
             lines.append(" ")
             lines.append("=== EXCITED STATE ENERGIES ===")
             lines.append(" ")
             for idx, (elec_energy, total_energy) in enumerate(
                 zip(self.electronic_energies[1:], self.total_energies[1:])
             ):
                 lines.append(f"{(idx + 1): 3d}: ")
                 lines.append(
-                    f"* Electronic excited state energy (Hartree): {_complex_to_string(elec_energy, 12)}"
+                    "* Electronic excited state energy (Hartree): "
+                    f"{_complex_to_string(elec_energy, self.formatting_precision)}"
                 )
                 lines.append(
-                    f"> Total excited state energy (Hartree): {_complex_to_string(total_energy, 12)}"
+                    "> Total excited state energy (Hartree): "
+                    f"{_complex_to_string(total_energy, self.formatting_precision)}"
                 )
 
         if self.has_observables():
             lines.append(" ")
             lines.append("=== MEASURED OBSERVABLES ===")
             lines.append(" ")
             for idx, (num_particles, spin, total_angular_momentum, magnetization,) in enumerate(
@@ -368,41 +376,53 @@
 
         if self.has_dipole():
             lines.append(" ")
             lines.append("=== DIPOLE MOMENTS ===")
             lines.append(" ")
             if self.nuclear_dipole_moment is not None:
                 lines.append(
-                    f"~ Nuclear dipole moment (a.u.): {_dipole_to_string(self.nuclear_dipole_moment)}"
+                    "~ Nuclear dipole moment (a.u.): "
+                    f"{_dipole_to_string(self.nuclear_dipole_moment, self.formatting_precision)}"
                 )
                 lines.append(" ")
             for idx, (elec_dip, comp_dip, extr_dip, dip, tot_dip, dip_db, tot_dip_db,) in enumerate(
                 zip(
                     self.electronic_dipole_moment,
                     self.computed_dipole_moment,
                     self.extracted_transformer_dipoles,
                     self.dipole_moment,
                     self.total_dipole_moment,
                     self.dipole_moment_in_debye,
                     self.total_dipole_moment_in_debye,
                 )
             ):
                 lines.append(f"{idx: 3d}: ")
-                lines.append(f"  * Electronic dipole moment (a.u.): {_dipole_to_string(elec_dip)}")
-                lines.append(f"    - computed part:      {_dipole_to_string(comp_dip)}")
+                lines.append(
+                    "  * Electronic dipole moment (a.u.): "
+                    f"{_dipole_to_string(elec_dip, self.formatting_precision)}"
+                )
+                lines.append(
+                    "    - computed part:      "
+                    f"{_dipole_to_string(comp_dip, self.formatting_precision)}"
+                )
                 for name, ex_dip in extr_dip.items():
-                    lines.append(f"    - {name} extracted energy part: {_dipole_to_string(ex_dip)}")
+                    lines.append(
+                        f"    - {name} extracted energy part: "
+                        f"{_dipole_to_string(ex_dip, self.formatting_precision)}"
+                    )
                 if self.nuclear_dipole_moment is not None:
                     lines.append(
-                        f"  > Dipole moment (a.u.): { _dipole_to_string(dip)}  "
-                        f"Total: {_complex_to_string(tot_dip)}"
+                        "  > Dipole moment (a.u.): "
+                        f"{ _dipole_to_string(dip, self.formatting_precision)}  "
+                        f"Total: {_complex_to_string(tot_dip, self.formatting_precision)}"
                     )
                     lines.append(
-                        f"                 (debye): {_dipole_to_string(dip_db)}  "
-                        f"Total: {_complex_to_string(tot_dip_db)}"
+                        "                 (debye): "
+                        f"{_dipole_to_string(dip_db, self.formatting_precision)}  "
+                        f"Total: {_complex_to_string(tot_dip_db, self.formatting_precision)}"
                     )
                 lines.append(" ")
 
         return lines
 
 
 def _dipole_tuple_add(x: Optional[DipoleTuple], y: Optional[DipoleTuple]) -> Optional[DipoleTuple]:
@@ -413,18 +433,18 @@
 
 
 def _element_add(x: Optional[float], y: Optional[float]):
     """Add dipole elements where a value may be None then None is returned"""
     return x + y if x is not None and y is not None else None
 
 
-def _dipole_to_string(dipole: DipoleTuple):
+def _dipole_to_string(dipole: DipoleTuple, precision: int = 8):
     value = "["
     for i, dip in enumerate(dipole):
-        value += _complex_to_string(dip, 8) if dip is not None else "None"
+        value += _complex_to_string(dip, precision) if dip is not None else "None"
         value += "  " if i < len(dipole) - 1 else "]"
     return value
 
 
 def _complex_to_string(value: Optional[complex], precision: int = 8) -> str:
     if value is None:
         return "None"
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/harmonic_basis.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/harmonic_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/lattice_model_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/lattice_model_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/lattice_model_result.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/lattice_model_result.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -55,20 +55,22 @@
 
     def _formatted(self) -> List[str]:
         """Formatted result as a list of strings"""
         lines = []
         lines.append("=== GROUND STATE ===")
         lines.append(" ")
         lines.append(
-            "* Lattice ground state energy " f": {np.round(self.computed_lattice_energies[0], 12)}"
+            "* Lattice ground state energy "
+            f": {np.round(self.computed_lattice_energies[0], self.formatting_precision)}"
         )
 
         if self.computed_lattice_energies is not None and len(self.computed_lattice_energies) > 1:
             lines.append(" ")
             lines.append("=== EXCITED STATES ===")
             lines.append(" ")
 
             for idx, lattice_energy in enumerate(self.computed_lattice_energies[1:]):
                 lines.append(
-                    f"* {(idx + 1): 3d}: Lattice excited state energy: {np.round(lattice_energy, 12)}"
+                    f"* {(idx + 1): 3d}: Lattice excited state energy: "
+                    f"{np.round(lattice_energy, self.formatting_precision)}"
                 )
         return lines
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/lattice_properties_container.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/lattice_properties_container.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/properties_container.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/properties_container.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/vibrational_basis.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/vibrational_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/vibrational_properties_container.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/vibrational_properties_container.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/vibrational_structure_problem.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/vibrational_structure_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/problems/vibrational_structure_result.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/problems/vibrational_structure_result.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -69,34 +69,34 @@
     def formatted(self) -> List[str]:
         """Formatted result as a list of strings"""
         lines = []
         lines.append("=== GROUND STATE ===")
         lines.append(" ")
         lines.append(
             "* Vibrational ground state energy "
-            f"(cm^-1): {np.round(self.computed_vibrational_energies[0], 12)}"
+            f"(cm^-1): {np.round(self.computed_vibrational_energies[0], self.formatting_precision)}"
         )
         if len(self.num_occupied_modals_per_mode) > 0:
             lines.append("The number of occupied modals for each mode is: ")
             for i, m in enumerate(self.num_occupied_modals_per_mode[0]):
-                lines.append(f"- Mode {i}: {np.round(m, 12)}")
+                lines.append(f"- Mode {i}: {np.round(m, self.formatting_precision)}")
 
         if (
             self.computed_vibrational_energies is not None
             and len(self.computed_vibrational_energies) > 1
         ):
             lines.append(" ")
             lines.append("=== EXCITED STATES ===")
             lines.append(" ")
 
             for idx, vib_energy in enumerate(self.computed_vibrational_energies[1:]):
                 lines.append(
                     f"* {(idx + 1): 3d}: Vibrational excited state energy "
-                    f"(cm^-1): {np.round(vib_energy, 12)}"
+                    f"(cm^-1): {np.round(vib_energy, self.formatting_precision)}"
                 )
                 if idx < len(self.num_occupied_modals_per_mode):
                     lines.append("The number of occupied modals for each mode is")
                     for i, m in enumerate(self.num_occupied_modals_per_mode[idx]):
-                        lines.append(f"- Mode {i}: {np.round(m, 12)}")
+                        lines.append(f"- Mode {i}: {np.round(m, self.formatting_precision)}")
                 lines.append(" ")
 
         return lines
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/properties/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/properties/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/properties/angular_momentum.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/properties/angular_momentum.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/properties/dipole_moment.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/properties/dipole_moment.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/properties/magnetization.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/properties/magnetization.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/properties/occupied_modals.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/properties/occupied_modals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/properties/particle_number.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/properties/particle_number.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/properties/protocols.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/properties/protocols.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/active_space_transformer.py` & `qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/electronic/active_space_transformer.py`

 * *Files 18% similar despite different names*

```diff
@@ -8,119 +8,136 @@
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """The Active-Space Reduction interface."""
 
-from __future__ import annotations
-
 import logging
 
 from copy import deepcopy
-from typing import cast
+from typing import List, Optional, Tuple, Union, cast
 
 import numpy as np
 
 from qiskit_nature import QiskitNatureError
-from qiskit_nature.second_q.hamiltonians import ElectronicEnergy, Hamiltonian
-from qiskit_nature.second_q.operators import ElectronicIntegrals
-from qiskit_nature.second_q.problems import BaseProblem, ElectronicBasis, ElectronicStructureProblem
-from qiskit_nature.second_q.properties import (
-    AngularMomentum,
-    ElectronicDensity,
+from qiskit_nature.properties import GroupedProperty, Property
+from qiskit_nature.properties.second_quantization import (
+    SecondQuantizedProperty,
+    GroupedSecondQuantizedProperty,
+)
+from qiskit_nature.properties.second_quantization.driver_metadata import DriverMetadata
+from qiskit_nature.properties.second_quantization.electronic import (
+    ElectronicStructureDriverResult,
     ElectronicDipoleMoment,
-    Magnetization,
     ParticleNumber,
 )
+from qiskit_nature.properties.second_quantization.electronic.bases import (
+    ElectronicBasis,
+    ElectronicBasisTransform,
+)
+from qiskit_nature.properties.second_quantization.electronic.integrals import (
+    IntegralProperty,
+    OneBodyElectronicIntegrals,
+)
+from qiskit_nature.properties.second_quantization.electronic.types import GroupedElectronicProperty
 
-from .base_transformer import BaseTransformer
-from .basis_transformer import BasisTransformer
+from ..base_transformer import BaseTransformer
 
-LOGGER = logging.getLogger(__name__)
+logger = logging.getLogger(__name__)
 
 
 class ActiveSpaceTransformer(BaseTransformer):
     r"""The Active-Space reduction.
 
     The reduction is done by computing the inactive Fock operator which is defined as
     :math:`F^I_{pq} = h_{pq} + \sum_i 2 g_{iipq} - g_{iqpi}` and the inactive energy which is
     given by :math:`E^I = \sum_j h_{jj} + F ^I_{jj}`, where :math:`i` and :math:`j` iterate over
     the inactive orbitals.
-    By using the inactive Fock operator in place of the one-electron integrals the
+    By using the inactive Fock operator in place of the one-electron integrals, `h1`, the
     description of the active space contains an effective potential generated by the inactive
     electrons. Therefore, this method permits the exclusion of non-core electrons while
     retaining a high-quality description of the system.
 
     For more details on the computation of the inactive Fock operator refer to
     https://arxiv.org/abs/2009.01872.
 
     The active space can be configured in one of the following ways through the initializer:
+        - when only `num_electrons` and `num_molecular_orbitals` are specified, these integers
+          indicate the number of active electrons and orbitals, respectively. The active space will
+          then be chosen around the Fermi level resulting in a unique choice for any pair of
+          numbers.  Nonetheless, the following criteria must be met:
+
+            #. the remaining number of inactive electrons must be a positive, even number
+
+            #. the number of active orbitals must not exceed the total number of orbitals minus the
+               number of orbitals occupied by the inactive electrons
+
+        - when, in addition to the above, `num_alpha` is specified, this can be used to disambiguate
+          the active space in systems with non-zero spin. Thus, `num_alpha` determines the number of
+          active alpha electrons. The number of active beta electrons can then be determined based
+          via `num_beta = num_electrons - num_alpha`. The same requirements as listed in the
+          previous case must be met.
+        - finally, it is possible to select a custom set of active orbitals via their indices using
+          `active_orbitals`. This allows selecting an active space which is not placed around the
+          Fermi level as described in the first case, above. When using this keyword argument, the
+          following criteria must be met *in addition* to the ones listed above:
 
-    - when only ``num_electrons`` and ``num_spatial_orbitals`` are specified, these integers
-      indicate the number of active electrons and orbitals, respectively. The active space will
-      then be chosen around the Fermi level resulting in a unique choice for any pair of
-      numbers.  Nonetheless, the following criteria must be met:
-
-        #. the remaining number of inactive electrons must be a positive, even number
-
-        #. the number of active orbitals must not exceed the total number of orbitals minus the
-           number of orbitals occupied by the inactive electrons
-
-    - when, ``num_electrons`` is a tuple, this must indicate the number of alpha- and beta-spin
-      electrons, respectively. The same requirements as listed before must be met.
-    - finally, it is possible to select a custom set of active orbitals via their indices using
-      ``active_orbitals``. This allows selecting an active space which is not placed around the
-      Fermi level as described in the first case, above. When using this keyword argument, the
-      following criteria must be met *in addition* to the ones listed above:
+            #. the length of `active_orbitals` must be equal to `num_molecular_orbitals`.
 
-        #. the length of `active_orbitals` must be equal to ``num_spatial_orbitals``. Note, that
-           we do **not** infer the number of active orbitals from this list of indices!
-
-        #. the sum of electrons present in ``active_orbitals`` must be equal to ``num_electrons``.
+            #. the sum of electrons present in `active_orbitals` must be equal to `num_electrons`.
 
     References:
         - *M. Rossmannek, P. Barkoutsos, P. Ollitrault, and I. Tavernelli, arXiv:2009.01872
           (2020).*
     """
 
     def __init__(
         self,
-        num_electrons: int | tuple[int, int],
-        num_spatial_orbitals: int,
-        active_orbitals: list[int] | None = None,
+        num_electrons: Optional[Union[int, Tuple[int, int]]] = None,
+        num_molecular_orbitals: Optional[int] = None,
+        active_orbitals: Optional[List[int]] = None,
     ):
-        """
+        """Initializes a transformer which can reduce a `GroupedElectronicProperty` to a configured
+        active space.
+
+        This transformer requires a `ParticleNumber` property and an `ElectronicBasisTransform`
+        pseudo-property to be available as well as `ElectronicIntegrals` in the `ElectronicBasis.AO`
+        basis. An `ElectronicStructureDriverResult` produced by Qiskit's drivers in general
+        satisfies these conditions unless it was read from an FCIDump file. However, those integrals
+        are likely already reduced by the code which produced the file.
+
         Args:
             num_electrons: The number of active electrons. If this is a tuple, it represents the
-               number of alpha- and beta-spin electrons, respectively. If this is a number, it is
-               interpreted as the total number of active electrons, should be even, and implies that
-               the number of alpha and beta electrons equals half of this value, respectively.
-            num_spatial_orbitals: The number of active orbitals.
-            active_orbitals: A list of indices specifying the spatial orbitals of the active
-                space. This argument must match with the remaining arguments and should only be used
-                to enforce an active space that is not chosen purely around the Fermi level.
+                           number of alpha and beta electrons. If this is a number, it is
+                           interpreted as the total number of active electrons, should be even, and
+                           implies that the number of alpha and beta electrons equals half of this
+                           value, respectively.
+            num_molecular_orbitals: The number of active orbitals.
+            active_orbitals: A list of indices specifying the molecular orbitals of the active
+                             space. This argument must match with the remaining arguments and should
+                             only be used to enforce an active space that is not chosen purely
+                             around the Fermi level.
 
         Raises:
             QiskitNatureError: if an invalid configuration is provided.
         """
         self._num_electrons = num_electrons
-        self._num_spatial_orbitals = num_spatial_orbitals
+        self._num_molecular_orbitals = num_molecular_orbitals
         self._active_orbitals = active_orbitals
 
         try:
             self._check_configuration()
         except QiskitNatureError as exc:
             raise QiskitNatureError("Incorrect Active-Space configuration.") from exc
 
         self._mo_occ_total: np.ndarray = None
-        self._active_orbs_indices: list[int] = None
-        self._transform_active: BasisTransformer = None
-        self._density_active: ElectronicIntegrals = None
-        self._density_total: ElectronicIntegrals = None
+        self._active_orbs_indices: List[int] = None
+        self._transform_active: ElectronicBasisTransform = None
+        self._density_inactive: OneBodyElectronicIntegrals = None
 
     def _check_configuration(self):
         if isinstance(self._num_electrons, (int, np.integer)):
             if self._num_electrons % 2 != 0:
                 raise QiskitNatureError(
                     "The number of active electrons must be even! Otherwise you must specify them "
                     "as a tuple, not as:",
@@ -143,173 +160,152 @@
                 )
         else:
             raise QiskitNatureError(
                 "The number of active electrons must be an int, or a tuple thereof, not:",
                 str(self._num_electrons),
             )
 
-        if isinstance(self._num_spatial_orbitals, (int, np.integer)):
-            if self._num_spatial_orbitals < 0:
+        if isinstance(self._num_molecular_orbitals, (int, np.integer)):
+            if self._num_molecular_orbitals < 0:
                 raise QiskitNatureError(
                     "The number of active orbitals cannot be negative, not:",
-                    str(self._num_spatial_orbitals),
+                    str(self._num_molecular_orbitals),
                 )
         else:
             raise QiskitNatureError(
                 "The number of active orbitals must be an int, not:",
-                str(self._num_spatial_orbitals),
+                str(self._num_electrons),
             )
 
-    def transform(self, problem: BaseProblem) -> BaseProblem:
-        """Transforms one :class:`~qiskit_nature.second_q.problems.BaseProblem` into another.
+    def transform(
+        self, grouped_property: GroupedSecondQuantizedProperty
+    ) -> GroupedElectronicProperty:
+        """Reduces the given `GroupedElectronicProperty` to a given active space.
 
         Args:
-            problem: the problem to be transformed.
-
-        Raises:
-            NotImplementedError: when an unsupported problem type is provided.
-            NotImplementedError: when the ``ElectronicStructureProblem`` is not in the
-                :attr:`qiskit_nature.second_q.problems.ElectronicBasis.MO` basis.
-            QiskitNatureError: If the provided ``ElectronicStructureProblem`` does not specify the
-                number of particles (``num_particles``) and number of orbitals
-                (``num_spatial_orbitals``), or if the amount of selected active orbital indices does
-                not match the total number of active orbitals.
+            grouped_property: the `GroupedElectronicProperty` to be transformed.
 
         Returns:
-            A new `BaseProblem` instance.
+            A new `GroupedElectronicProperty` instance.
+
+        Raises:
+            QiskitNatureError: If the provided `GroupedElectronicProperty` does not contain a
+                               `ParticleNumber` or `ElectronicBasisTransform` instance, if more
+                               electrons or orbitals are requested than are available, or if the
+                               number of selected active orbital indices does not match
+                               `num_molecular_orbitals`.
         """
-        if isinstance(problem, ElectronicStructureProblem):
-            return self._transform_electronic_structure_problem(problem)
-        else:
-            raise NotImplementedError(
-                f"The problem of type, {type(problem)}, is not supported by this transformer."
+        if not isinstance(grouped_property, GroupedElectronicProperty):
+            raise QiskitNatureError(
+                "Only `GroupedElectronicProperty` objects can be transformed by this Transformer, "
+                f"not objects of type, {type(grouped_property)}."
             )
 
-    def _transform_electronic_structure_problem(
-        self, problem: ElectronicStructureProblem
-    ) -> ElectronicStructureProblem:
-
-        if problem.basis != ElectronicBasis.MO:
-            raise NotImplementedError(
-                f"Transformation of an ElectronicStructureProblem in the {problem.basis} basis is "
-                "not supported by this transformer. Please convert it to the ElectronicBasis.MO"
-                " basis first, for example by using a BasisTransformer."
+        particle_number = grouped_property.get_property(ParticleNumber)
+        if particle_number is None:
+            raise QiskitNatureError(
+                "The provided `GroupedElectronicProperty` does not contain a `ParticleNumber` "
+                "property, which is required by this transformer!"
             )
+        particle_number = cast(ParticleNumber, particle_number)
 
-        if problem.num_spatial_orbitals is None:
+        electronic_basis_transform = grouped_property.get_property(ElectronicBasisTransform)
+        if electronic_basis_transform is None:
             raise QiskitNatureError(
-                "Using the ActiveSpaceTransformer requires the number of orbitals to be set on the "
-                "problem instance. Please set ElectronicStructureProblem.num_spatial_orbitals to "
-                "use this transformer."
+                "The provided `GroupedElectronicProperty` does not contain an "
+                "`ElectronicBasisTransform` property, which is required by this transformer!"
             )
-        num_spatial_orbitals = problem.num_spatial_orbitals
+        electronic_basis_transform = cast(ElectronicBasisTransform, electronic_basis_transform)
 
-        # get spatial orbital occupation numbers
-        occupation_alpha = problem.orbital_occupations
-        occupation_beta = problem.orbital_occupations_b
-        if occupation_alpha is None or occupation_beta is None:
-            # simply disable the validation done against self._mo_occ_total
-            self._mo_occ_total = None
-        else:
-            self._mo_occ_total = occupation_alpha + occupation_beta
+        # get molecular orbital occupation numbers
+        occupation_alpha = particle_number.occupation_alpha
+        occupation_beta = particle_number.occupation_beta
+        self._mo_occ_total = occupation_alpha + occupation_beta
 
         # determine the active space
-        self._active_orbs_indices = self._determine_active_space(problem)
+        self._active_orbs_indices, inactive_orbs_idxs = self._determine_active_space(
+            grouped_property
+        )
+
+        # get molecular orbital coefficients
+        coeff_alpha = electronic_basis_transform.coeff_alpha
+        coeff_beta = electronic_basis_transform.coeff_beta
 
         # initialize size-reducing basis transformation
-        coeff_alpha = np.zeros((num_spatial_orbitals, self._num_spatial_orbitals))
-        coeff_alpha[self._active_orbs_indices, range(self._num_spatial_orbitals)] = 1.0
-        coeff_beta = np.zeros((num_spatial_orbitals, self._num_spatial_orbitals))
-        coeff_beta[self._active_orbs_indices, range(self._num_spatial_orbitals)] = 1.0
-        self._transform_active = BasisTransformer(
-            ElectronicBasis.MO,
+        self._transform_active = ElectronicBasisTransform(
+            ElectronicBasis.AO,
             ElectronicBasis.MO,
-            ElectronicIntegrals.from_raw_integrals(coeff_alpha, h1_b=coeff_beta, validate=False),
+            coeff_alpha[:, self._active_orbs_indices],
+            coeff_beta[:, self._active_orbs_indices],
         )
 
-        self._density_total = ElectronicIntegrals.from_raw_integrals(
-            np.diag(occupation_alpha), h1_b=np.diag(occupation_beta)
+        # compute inactive density matrix
+        def _inactive_density(mo_occ, mo_coeff):
+            return np.dot(
+                mo_coeff[:, inactive_orbs_idxs] * mo_occ[inactive_orbs_idxs],
+                np.transpose(mo_coeff[:, inactive_orbs_idxs]),
+            )
+
+        self._density_inactive = OneBodyElectronicIntegrals(
+            ElectronicBasis.AO,
+            (
+                _inactive_density(occupation_alpha, coeff_alpha),
+                _inactive_density(occupation_beta, coeff_beta),
+            ),
         )
 
-        self._density_active = self._transform_active.transform_electronic_integrals(
-            self._density_total
-        )
-        self._density_active.beta_alpha = None
-        self._density_active = self._transform_active.invert().transform_electronic_integrals(
-            self._density_active
+        # construct new GroupedElectronicProperty
+        grouped_property_transformed = ElectronicStructureDriverResult()
+        grouped_property_transformed = self._transform_property(grouped_property)  # type: ignore
+        grouped_property_transformed.molecule = (
+            grouped_property.molecule  # type: ignore[attr-defined]
         )
-        self._density_active.beta_alpha = None
-
-        electronic_energy = cast(ElectronicEnergy, self.transform_hamiltonian(problem.hamiltonian))
-
-        # construct new ElectronicStructureProblem
-        new_problem = ElectronicStructureProblem(electronic_energy)
-        new_problem.basis = ElectronicBasis.MO
-        new_problem.molecule = problem.molecule
-        new_problem.reference_energy = problem.reference_energy
-        new_problem.num_spatial_orbitals = len(self._active_orbs_indices)
-
-        active_occ_alpha = occupation_alpha[self._active_orbs_indices]
-        active_occ_beta = occupation_beta[self._active_orbs_indices]
-        new_problem.num_particles = (int(sum(active_occ_alpha)), int(sum(active_occ_beta)))
-        new_problem.orbital_occupations = active_occ_alpha
-        new_problem.orbital_occupations_b = active_occ_beta
-
-        if problem.orbital_energies is not None:
-            new_problem.orbital_energies = problem.orbital_energies[self._active_orbs_indices]
-        if problem.orbital_energies_b is not None:
-            new_problem.orbital_energies_b = problem.orbital_energies_b[self._active_orbs_indices]
 
-        for prop in problem.properties:
-            if isinstance(prop, ElectronicDipoleMoment):
-                new_problem.properties.electronic_dipole_moment = (
-                    self._transform_electronic_dipole_moment(prop)
-                )
-            elif isinstance(prop, ElectronicDensity):
-                transformed = self._transform_active.transform_electronic_integrals(prop)
-                new_problem.properties.electronic_density = ElectronicDensity(
-                    transformed.alpha, transformed.beta, transformed.beta_alpha
-                )
-            elif isinstance(prop, (AngularMomentum, Magnetization, ParticleNumber)):
-                new_problem.properties.add(prop.__class__(len(self._active_orbs_indices)))
-            else:
-                LOGGER.warning("Encountered an unsupported property of type '%s'.", type(prop))
-
-        return new_problem
-
-    def _determine_active_space(self, problem: ElectronicStructureProblem) -> list[int]:
+        return grouped_property_transformed
+
+    def _determine_active_space(
+        self, grouped_property: GroupedElectronicProperty
+    ) -> Tuple[List[int], List[int]]:
         """Determines the active and inactive orbital indices.
 
         Args:
-            problem: the ElectronicStructureProblem to be transformed.
+            grouped_property: the `GroupedElectronicProperty` to be transformed.
 
         Returns:
             The list of active and inactive orbital indices.
         """
+        particle_number = grouped_property.get_property(ParticleNumber)
         if isinstance(self._num_electrons, tuple):
             num_alpha, num_beta = self._num_electrons
         elif isinstance(self._num_electrons, (int, np.integer)):
             num_alpha = num_beta = self._num_electrons // 2
 
         # compute number of inactive electrons
-        nelec_total = problem.num_alpha + problem.num_beta
+        nelec_total = particle_number._num_alpha + particle_number._num_beta
         nelec_inactive = nelec_total - num_alpha - num_beta
 
         self._validate_num_electrons(nelec_inactive)
-        self._validate_num_orbitals(nelec_inactive, problem.num_spatial_orbitals)
+        self._validate_num_orbitals(nelec_inactive, particle_number)
 
         # determine active and inactive orbital indices
         if self._active_orbitals is None:
             norbs_inactive = nelec_inactive // 2
+            inactive_orbs_idxs = list(range(norbs_inactive))
             active_orbs_idxs = list(
-                range(norbs_inactive, norbs_inactive + self._num_spatial_orbitals)
+                range(norbs_inactive, norbs_inactive + self._num_molecular_orbitals)
             )
-            return active_orbs_idxs
+        else:
+            active_orbs_idxs = self._active_orbitals
+            inactive_orbs_idxs = [
+                o
+                for o in range(nelec_total // 2)
+                if o not in self._active_orbitals and self._mo_occ_total[o] > 0
+            ]
 
-        return self._active_orbitals
+        return (active_orbs_idxs, inactive_orbs_idxs)
 
     def _validate_num_electrons(self, nelec_inactive: int) -> None:
         """Validates the number of electrons.
 
         Args:
             nelec_inactive: the computed number of inactive electrons.
 
@@ -317,153 +313,131 @@
             QiskitNatureError: if the number of inactive electrons is either negative or odd.
         """
         if nelec_inactive < 0:
             raise QiskitNatureError("More electrons requested than available.")
         if nelec_inactive % 2 != 0:
             raise QiskitNatureError("The number of inactive electrons must be even.")
 
-    def _validate_num_orbitals(self, nelec_inactive: int, num_spatial_orbitals: int) -> None:
+    def _validate_num_orbitals(self, nelec_inactive: int, particle_number: ParticleNumber) -> None:
         """Validates the number of orbitals.
 
         Args:
             nelec_inactive: the computed number of inactive electrons.
-            num_spatial_orbitals: the total number of spatial orbitals available.
+            particle_number: the `ParticleNumber` containing system size information.
 
         Raises:
             QiskitNatureError: if more orbitals were requested than are available in total or if the
                                number of selected orbitals mismatches the specified number of active
                                orbitals.
         """
         if self._active_orbitals is None:
             norbs_inactive = nelec_inactive // 2
-            if norbs_inactive + self._num_spatial_orbitals > num_spatial_orbitals:
+            if (
+                norbs_inactive + self._num_molecular_orbitals
+                > particle_number._num_spin_orbitals // 2
+            ):
                 raise QiskitNatureError("More orbitals requested than available.")
         else:
-            if self._num_spatial_orbitals != len(self._active_orbitals):
+            if self._num_molecular_orbitals != len(self._active_orbitals):
                 raise QiskitNatureError(
                     "The number of selected active orbital indices does not "
                     "match the specified number of active orbitals."
                 )
-            if max(self._active_orbitals) >= num_spatial_orbitals:
+            if max(self._active_orbitals) >= particle_number._num_spin_orbitals // 2:
                 raise QiskitNatureError("More orbitals requested than available.")
             expected_num_electrons = (
                 self._num_electrons
                 if isinstance(self._num_electrons, (int, np.integer))
                 else sum(self._num_electrons)
             )
             if sum(self._mo_occ_total[self._active_orbitals]) != expected_num_electrons:
                 raise QiskitNatureError(
                     "The number of electrons in the selected active orbitals "
                     "does not match the specified number of active electrons."
                 )
 
-    def transform_hamiltonian(self, hamiltonian: Hamiltonian) -> Hamiltonian:
-        """Transforms one :class:`~qiskit_nature.second_q.hamiltonians.Hamiltonian` into another.
+    # TODO: can we efficiently extract this into the base class? At least the logic dealing with
+    # recursion is general and we should avoid having to duplicate it.
+    def _transform_property(self, prop: Property) -> Optional[Property]:
+        """Transforms a Property object.
 
-        Args:
-            hamiltonian: the hamiltonian to be transformed.
+        This is a recursive reduction, iterating GroupedProperty objects when encountering one.
 
-        Raises:
-            NotImplementedError: when an unsupported hamiltonian type is provided.
-            NotImplementedError: when called standalone.
+        Args:
+            property: the property object to transform.
 
         Returns:
-            A new `Hamiltonian` instance.
-        """
-        if isinstance(hamiltonian, ElectronicEnergy):
-            # TODO: implement the standalone usage of this method
-            # See also: https://github.com/Qiskit/qiskit-nature/issues/847
-            if self._transform_active is None:
-                raise NotImplementedError(
-                    "This transformer does not yet support the standalone use of the "
-                    "transform_hamiltonian method. See also "
-                    "https://github.com/Qiskit/qiskit-nature/issues/847"
-                )
-            return self._transform_electronic_energy(hamiltonian)
-        else:
-            raise NotImplementedError(
-                f"The hamiltonian of type, {type(hamiltonian)}, is not supported by this "
-                "transformer."
-            )
-
-    def _transform_electronic_energy(self, hamiltonian: ElectronicEnergy) -> ElectronicEnergy:
-        total_fock_operator = hamiltonian.fock(self._density_total)
-
-        active_fock_operator = (
-            hamiltonian.fock(self._density_active) - hamiltonian.electronic_integrals.one_body
-        )
-
-        inactive_fock_operator = total_fock_operator - active_fock_operator
+            The transformed property object.
 
-        e_inactive: ElectronicIntegrals = cast(
-            ElectronicIntegrals,
-            0.5
-            * ElectronicIntegrals.einsum(
-                {"ij,ji": ("+-", "+-", "")},
-                total_fock_operator + hamiltonian.electronic_integrals.one_body,
-                self._density_total,
-            ),
-        )
-        e_inactive -= ElectronicIntegrals.einsum(
-            {"ij,ji": ("+-", "+-", "")}, total_fock_operator, self._density_active
-        )
-        e_inactive += cast(
-            ElectronicIntegrals,
-            0.5
-            * ElectronicIntegrals.einsum(
-                {"ij,ji": ("+-", "+-", "")}, active_fock_operator, self._density_active
-            ),
-        )
-        e_inactive_sum = (
-            e_inactive.alpha.get("", 0.0)
-            + e_inactive.beta.get("", 0.0)
-            + e_inactive.beta_alpha.get("", 0.0)
-        )
-
-        new_hamil = ElectronicEnergy(
-            self._transform_active.transform_electronic_integrals(
-                inactive_fock_operator + hamiltonian.electronic_integrals.two_body
-            )
-        )
-        new_hamil.constants = deepcopy(hamiltonian.constants)
-        new_hamil.constants[self.__class__.__name__] = e_inactive_sum
-
-        return new_hamil
-
-    def _transform_electronic_dipole_moment(
-        self, dipole_moment: ElectronicDipoleMoment
-    ) -> ElectronicDipoleMoment:
-        dipoles: list[ElectronicIntegrals] = []
-        dip_inactive: list[float] = []
-        for dipole in [dipole_moment.x_dipole, dipole_moment.y_dipole, dipole_moment.z_dipole]:
-            # In the dipole case, there are no two-body terms. Thus, the inactive Fock operator
-            # is unaffected by the density and equals the one-body terms.
-            one_body = dipole.one_body
+        Raises:
+            TypeError: if an unexpected Property subtype is encountered.
+        """
+        transformed_property: Optional[Property] = None
+        if isinstance(prop, GroupedProperty):
+            transformed_property = prop.__class__()  # type: ignore[call-arg]
+            transformed_property.name = prop.name
+
+            for internal_property in iter(prop):
+                try:
+                    transformed_internal_property = self._transform_property(internal_property)
+                    if transformed_internal_property is not None:
+                        transformed_property.add_property(transformed_internal_property)
+                except TypeError:
+                    logger.warning(
+                        "The Property %s of type %s could not be transformed!",
+                        internal_property.name,
+                        type(internal_property),
+                    )
+                    continue
 
-            e_inactive = ElectronicIntegrals.einsum(
-                {"ij,ji": ("+-", "+-", "")}, one_body, self._density_total
-            )
-            e_inactive -= ElectronicIntegrals.einsum(
-                {"ij,ji": ("+-", "+-", "")}, one_body, self._density_active
-            )
-            dipoles.append(self._transform_active.transform_electronic_integrals(one_body))
-            dip_inactive.append(
-                e_inactive.alpha.get("", 0.0)
-                + e_inactive.beta.get("", 0.0)
-                + e_inactive.beta_alpha.get("", 0.0)
-            )
+            if isinstance(prop, ElectronicDipoleMoment):
+                transformed_property.reverse_dipole_sign = (  # type: ignore[attr-defined]
+                    prop.reverse_dipole_sign
+                )
+                transformed_property.nuclear_dipole_moment = (  # type: ignore[attr-defined]
+                    prop.nuclear_dipole_moment
+                )
 
-        new_dipole_moment = ElectronicDipoleMoment(
-            x_dipole=dipoles[0],
-            y_dipole=dipoles[1],
-            z_dipole=dipoles[2],
-        )
-        new_dipole_moment.constants = deepcopy(dipole_moment.constants)
-        new_dipole_moment.constants[self.__class__.__name__] = (
-            dip_inactive[0],
-            dip_inactive[1],
-            dip_inactive[2],
-        )
-        new_dipole_moment.reverse_dipole_sign = dipole_moment.reverse_dipole_sign
-        new_dipole_moment.nuclear_dipole_moment = dipole_moment.nuclear_dipole_moment
+            if len(list(transformed_property)) == 0:
+                # empty GroupedProperty instance
+                transformed_property = None
+
+        elif isinstance(prop, IntegralProperty):
+            # get matrix operator of IntegralProperty
+            fock_operator = prop.integral_operator(self._density_inactive)
+            # the total operator equals the AO-1-body-term + the inactive matrix operator
+            total_op = prop.get_electronic_integral(ElectronicBasis.AO, 1) + fock_operator
+            # compute the energy shift introduced by the ActiveSpaceTransformer
+            e_inactive = 0.5 * cast(complex, total_op.compose(self._density_inactive))
+
+            transformed_property = deepcopy(prop)
+            # insert the AO-basis inactive operator
+            transformed_property.add_electronic_integral(fock_operator)
+            # actually reduce the system size
+            transformed_property.transform_basis(self._transform_active)
+            # insert the energy shift
+            transformed_property._shift[self.__class__.__name__] = e_inactive
+
+        elif isinstance(prop, ParticleNumber):
+            p_n = prop
+            active_occ_alpha = p_n.occupation_alpha[self._active_orbs_indices]
+            active_occ_beta = p_n.occupation_beta[self._active_orbs_indices]
+            transformed_property = ParticleNumber(
+                len(self._active_orbs_indices) * 2,
+                (int(sum(active_occ_alpha)), int(sum(active_occ_beta))),
+                active_occ_alpha,
+                active_occ_beta,
+            )
+
+        elif isinstance(prop, SecondQuantizedProperty):
+            transformed_property = prop.__class__(len(self._active_orbs_indices) * 2)  # type: ignore
+
+        elif isinstance(prop, ElectronicBasisTransform):
+            # transformation done manually during `transform`
+            transformed_property = self._transform_active
+
+        elif isinstance(prop, DriverMetadata):
+            # for the time being we manually catch this to avoid unnecessary warnings
+            # TODO: support storing transformer information in the DriverMetadata container
+            transformed_property = prop
 
-        return new_dipole_moment
+        return transformed_property
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/base_transformer.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/base_transformer.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/second_q/transformers/basis_transformer.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/transformers/basis_transformer.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -17,15 +17,15 @@
 import logging
 from typing import cast
 
 import numpy as np
 
 from qiskit_nature.exceptions import QiskitNatureError
 from qiskit_nature.second_q.hamiltonians import ElectronicEnergy, Hamiltonian
-from qiskit_nature.second_q.operators import ElectronicIntegrals, PolynomialTensor
+from qiskit_nature.second_q.operators import ElectronicIntegrals, PolynomialTensor, Tensor
 from qiskit_nature.second_q.problems import BaseProblem, ElectronicBasis, ElectronicStructureProblem
 from qiskit_nature.second_q.properties import (
     AngularMomentum,
     ElectronicDensity,
     ElectronicDipoleMoment,
     Magnetization,
     ParticleNumber,
@@ -172,26 +172,38 @@
         """
         if not isinstance(self.coefficients, ElectronicIntegrals):
             raise QiskitNatureError(
                 "You cannot transform ElectronicIntegrals with a BasisTransformer containing "
                 f"coefficients of type, {type(self.coefficients)}, rather than ElectronicIntegrals."
             )
 
+        prsq = "prsq"
+        iklj = "iklj"
+
+        two_body_aa = integrals.alpha.get("++--", None)
+        if two_body_aa is not None:
+            # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+            if not isinstance(two_body_aa, Tensor):
+                two_body_aa = Tensor(two_body_aa)
+
+            prsq = "".join(two_body_aa._reverse_label_template(prsq))
+            iklj = "".join(two_body_aa._reverse_label_template(iklj))
+
         einsum_map = {
             "jk,ji,kl->il": ("+-",) * 4,
-            "prsq,pi,qj,rk,sl->iklj": ("++--", *("+-",) * 4, "++--"),
+            f"{prsq},pi,qj,rk,sl->{iklj}": ("++--", *("+-",) * 4, "++--"),
         }
 
         transformed_integrals = ElectronicIntegrals.einsum(
             einsum_map, integrals, *(self.coefficients,) * 4
         )
 
         if not self.coefficients.beta.is_empty() and transformed_integrals.beta_alpha.is_empty():
             transformed_integrals.beta_alpha = PolynomialTensor.einsum(
-                {"prsq,pi,qj,rk,sl->iklj": ("++--", *("+-",) * 4, "++--")},
+                {f"{prsq},pi,qj,rk,sl->{iklj}": ("++--", *("+-",) * 4, "++--")},
                 integrals.alpha if integrals.beta_alpha.is_empty() else integrals.beta_alpha,
                 *(self.coefficients.beta,) * 2,
                 *(self.coefficients.alpha,) * 2,
             )
 
         return transformed_integrals
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/transformers/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/transformers/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/base_transformer.py` & `qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/base_transformer.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/electronic/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/electronic/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/transformers/second_quantization/electronic/freeze_core_transformer.py` & `qiskit-nature-0.6.0/qiskit_nature/transformers/second_quantization/electronic/freeze_core_transformer.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/units.py` & `qiskit-nature-0.6.0/qiskit_nature/units.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature/utils/__init__.py` & `qiskit-nature-0.6.0/qiskit_nature/utils/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -24,12 +24,10 @@
    :nosignatures:
 
    apply_matrix_to_slices
    givens_matrix
 """
 
 from .linalg import apply_matrix_to_slices, givens_matrix
+from .opt_einsum import get_einsum
 
-__all__ = [
-    "apply_matrix_to_slices",
-    "givens_matrix",
-]
+__all__ = ["apply_matrix_to_slices", "givens_matrix", "get_einsum"]
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/utils/linalg.py` & `qiskit-nature-0.6.0/qiskit_nature/utils/linalg.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -125,17 +125,17 @@
     left = transformation_matrix[:, :n]
     right = transformation_matrix[:, n:]
     current_matrix = np.block([right.conj(), left.conj()]).astype(complex, copy=False)
 
     # compute left_unitary
     left_unitary = np.eye(n, dtype=complex)
     for j in range(n - 1):
-        # Zero out entries in column k
+        # Zero out entries in column j
         for i in range(n - 1 - j):
-            # Zero out entry in row l if needed
+            # Zero out entry in row i if needed
             if not np.isclose(current_matrix[i, j], 0.0):
                 givens_mat = givens_matrix(current_matrix[i + 1, j], current_matrix[i, j])
                 current_matrix = apply_matrix_to_slices(current_matrix, givens_mat, [i + 1, i])
                 left_unitary = apply_matrix_to_slices(left_unitary, givens_mat, [i + 1, i])
 
     # decompose matrix into Givens rotations and particle-hole transformations
     decomposition: List[Tuple[Gate, Tuple[Qubit, ...]]] = []
```

### Comparing `qiskit-nature-0.5.2/qiskit_nature/version.py` & `qiskit-nature-0.6.0/qiskit_nature/version.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/qiskit_nature.egg-info/SOURCES.txt` & `qiskit-nature-0.6.0/qiskit_nature.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -316,19 +316,22 @@
 qiskit_nature/second_q/drivers/gaussiand/gaussiandriver.py
 qiskit_nature/second_q/drivers/gaussiand/gauopen/LICENSE.txt
 qiskit_nature/second_q/drivers/gaussiand/gauopen/QCMatEl.py
 qiskit_nature/second_q/drivers/gaussiand/gauopen/QCOpMat.py
 qiskit_nature/second_q/drivers/gaussiand/gauopen/__init__.py
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.F
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp310-win_amd64.pyd
+qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp311-win_amd64.pyd
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp37-win_amd64.pyd
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp38-win_amd64.pyd
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cp39-win_amd64.pyd
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-darwin.so
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-310-x86_64-linux-gnu.so
+qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-311-darwin.so
+qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-311-x86_64-linux-gnu.so
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-darwin.so
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-37m-x86_64-linux-gnu.so
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-darwin.so
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-38-x86_64-linux-gnu.so
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-darwin.so
 qiskit_nature/second_q/drivers/gaussiand/gauopen/qcmatrixio.cpython-39-x86_64-linux-gnu.so
 qiskit_nature/second_q/drivers/psi4d/__init__.py
@@ -375,30 +378,34 @@
 qiskit_nature/second_q/hamiltonians/lattices/square_lattice.py
 qiskit_nature/second_q/hamiltonians/lattices/triangular_lattice.py
 qiskit_nature/second_q/mappers/__init__.py
 qiskit_nature/second_q/mappers/bksf.py
 qiskit_nature/second_q/mappers/bravyi_kitaev_mapper.py
 qiskit_nature/second_q/mappers/direct_mapper.py
 qiskit_nature/second_q/mappers/fermionic_mapper.py
+qiskit_nature/second_q/mappers/interleaved_qubit_mapper.py
 qiskit_nature/second_q/mappers/jordan_wigner_mapper.py
 qiskit_nature/second_q/mappers/linear_mapper.py
 qiskit_nature/second_q/mappers/logarithmic_mapper.py
 qiskit_nature/second_q/mappers/parity_mapper.py
 qiskit_nature/second_q/mappers/qubit_converter.py
 qiskit_nature/second_q/mappers/qubit_mapper.py
 qiskit_nature/second_q/mappers/spin_mapper.py
+qiskit_nature/second_q/mappers/tapered_qubit_mapper.py
 qiskit_nature/second_q/mappers/vibrational_mapper.py
 qiskit_nature/second_q/operators/__init__.py
 qiskit_nature/second_q/operators/_bits_container.py
 qiskit_nature/second_q/operators/commutators.py
 qiskit_nature/second_q/operators/electronic_integrals.py
 qiskit_nature/second_q/operators/fermionic_op.py
 qiskit_nature/second_q/operators/polynomial_tensor.py
 qiskit_nature/second_q/operators/sparse_label_op.py
 qiskit_nature/second_q/operators/spin_op.py
+qiskit_nature/second_q/operators/symmetric_two_body.py
+qiskit_nature/second_q/operators/tensor.py
 qiskit_nature/second_q/operators/tensor_ordering.py
 qiskit_nature/second_q/operators/vibrational_integrals.py
 qiskit_nature/second_q/operators/vibrational_op.py
 qiskit_nature/second_q/problems/__init__.py
 qiskit_nature/second_q/problems/base_problem.py
 qiskit_nature/second_q/problems/eigenstate_result.py
 qiskit_nature/second_q/problems/electronic_basis.py
@@ -423,24 +430,26 @@
 qiskit_nature/second_q/properties/particle_number.py
 qiskit_nature/second_q/properties/protocols.py
 qiskit_nature/second_q/transformers/__init__.py
 qiskit_nature/second_q/transformers/active_space_transformer.py
 qiskit_nature/second_q/transformers/base_transformer.py
 qiskit_nature/second_q/transformers/basis_transformer.py
 qiskit_nature/second_q/transformers/freeze_core_transformer.py
+qiskit_nature/testing/__init__.py
+qiskit_nature/testing/random.py
 qiskit_nature/transformers/__init__.py
 qiskit_nature/transformers/second_quantization/__init__.py
 qiskit_nature/transformers/second_quantization/base_transformer.py
 qiskit_nature/transformers/second_quantization/electronic/__init__.py
 qiskit_nature/transformers/second_quantization/electronic/active_space_transformer.py
 qiskit_nature/transformers/second_quantization/electronic/freeze_core_transformer.py
 qiskit_nature/utils/__init__.py
 qiskit_nature/utils/linalg.py
+qiskit_nature/utils/opt_einsum.py
 test/__init__.py
-test/nature_random.py
 test/nature_test_case.py
 test/test_deprecation.py
 test/test_end2end_with_vqe.py
 test/test_hdf5.py
 test/test_logging.py
 test/test_readme_sample.py
 test/algorithms/__init__.py
@@ -703,25 +712,31 @@
 test/results/utils/test_protein_shape_file_gen.py
 test/results/utils/resources/also_side_chains_test.xyz
 test/results/utils/resources/only_main_chain_test.xyz
 test/runtime/__init__.py
 test/runtime/fake_vqeruntime.py
 test/runtime/test_vqeprogram.py
 test/second_q/__init__.py
+test/second_q/utils.py
 test/second_q/algorithms/__init__.py
 test/second_q/algorithms/excited_state_solvers/__init__.py
 test/second_q/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py
 test/second_q/algorithms/excited_state_solvers/test_excited_states_solvers.py
+test/second_q/algorithms/excited_state_solvers/test_excited_states_solvers_auxiliaries.py
 test/second_q/algorithms/excited_state_solvers/test_qeom_electronic_ops.py
 test/second_q/algorithms/excited_state_solvers/test_qeom_vibrational_ops.py
 test/second_q/algorithms/excited_state_solvers/eigensolver_factories/__init__.py
 test/second_q/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py
+test/second_q/algorithms/excited_state_solvers/resources/__init__.py
+test/second_q/algorithms/excited_state_solvers/resources/expected_qeom_ops.py
+test/second_q/algorithms/excited_state_solvers/resources/expected_transition_amplitudes.py
 test/second_q/algorithms/ground_state_solvers/__init__.py
 test/second_q/algorithms/ground_state_solvers/test_advanced_ucc_variants.py
 test/second_q/algorithms/ground_state_solvers/test_groundstate_eigensolver.py
+test/second_q/algorithms/ground_state_solvers/test_groundstate_eigensolver_mapper.py
 test/second_q/algorithms/ground_state_solvers/test_swaprz.py
 test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/__init__.py
 test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py
 test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py
 test/second_q/algorithms/initial_points/__init__.py
 test/second_q/algorithms/initial_points/test_hf_initial_point.py
 test/second_q/algorithms/initial_points/test_initial_point.py
@@ -740,14 +755,15 @@
 test/second_q/circuit/library/ansatzes/utils/__init__.py
 test/second_q/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py
 test/second_q/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py
 test/second_q/circuit/library/ansatzes/utils/vibrational_op_label_creator.py
 test/second_q/circuit/library/initial_states/__init__.py
 test/second_q/circuit/library/initial_states/test_fermionic_gaussian_state.py
 test/second_q/circuit/library/initial_states/test_hartree_fock.py
+test/second_q/circuit/library/initial_states/test_hartree_fock_mapper.py
 test/second_q/circuit/library/initial_states/test_slater_determinant.py
 test/second_q/circuit/library/initial_states/test_vscf.py
 test/second_q/drivers/__init__.py
 test/second_q/drivers/test_driver.py
 test/second_q/drivers/test_driver_methods_gsc.py
 test/second_q/drivers/gaussiand/__init__.py
 test/second_q/drivers/gaussiand/test_driver_gaussian.py
@@ -803,29 +819,34 @@
 test/second_q/hamiltonians/lattices/test_square_lattice.py
 test/second_q/hamiltonians/lattices/test_triangular_lattice.py
 test/second_q/hamiltonians/resources/electronic_energy_op.json
 test/second_q/mappers/__init__.py
 test/second_q/mappers/test_bksf_mapper.py
 test/second_q/mappers/test_bravyi_kitaev_mapper.py
 test/second_q/mappers/test_direct_mapper.py
+test/second_q/mappers/test_interleaved_qubit_mapper.py
 test/second_q/mappers/test_jordan_wigner_mapper.py
 test/second_q/mappers/test_linear_mapper.py
 test/second_q/mappers/test_logarithmic_mapper.py
 test/second_q/mappers/test_parity_mapper.py
 test/second_q/mappers/test_qubit_converter.py
+test/second_q/mappers/test_tapered_qubit_mapper.py
 test/second_q/mappers/resources/__init__.py
 test/second_q/mappers/resources/bksf_lih.py
 test/second_q/mappers/resources/reference_direct_mapper.py
 test/second_q/operators/__init__.py
+test/second_q/operators/tensor_test_cases.py
 test/second_q/operators/test_commutators.py
 test/second_q/operators/test_electronic_integrals.py
 test/second_q/operators/test_fermionic_op.py
 test/second_q/operators/test_polynomial_tensor.py
 test/second_q/operators/test_sparse_label_op.py
 test/second_q/operators/test_spin_op.py
+test/second_q/operators/test_symmetric_two_body.py
+test/second_q/operators/test_tensor.py
 test/second_q/operators/test_tensor_ordering.py
 test/second_q/operators/test_vibrational_op.py
 test/second_q/problems/__init__.py
 test/second_q/problems/test_eigenstate_result.py
 test/second_q/problems/test_electronic_properties_container.py
 test/second_q/problems/test_electronic_structure_problem.py
 test/second_q/problems/test_electronic_structure_result.py
```

### Comparing `qiskit-nature-0.5.2/setup.py` & `qiskit-nature-0.6.0/setup.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -62,21 +62,23 @@
         "Operating System :: MacOS",
         "Operating System :: POSIX :: Linux",
         "Programming Language :: Python :: 3 :: Only",
         "Programming Language :: Python :: 3.7",
         "Programming Language :: Python :: 3.8",
         "Programming Language :: Python :: 3.9",
         "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
         "Topic :: Scientific/Engineering",
     ],
     keywords="qiskit sdk quantum nature chemistry physics",
     packages=setuptools.find_packages(include=["qiskit_nature", "qiskit_nature.*"]),
     install_requires=REQUIREMENTS,
     include_package_data=True,
     python_requires=">=3.7",
     extras_require={
         "pyscf": ["pyscf; sys_platform != 'win32'"],
         "mpl": ["matplotlib>=3.3"],
-        "sparse": ["sparse"],
+        "sparse": ["sparse; python_version < '3.11'"],
+        "opt_einsum": ["opt_einsum"],
     },
     zip_safe=False,
 )
```

### Comparing `qiskit-nature-0.5.2/test/__init__.py` & `qiskit-nature-0.6.0/test/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py` & `qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py` & `qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/excited_state_solvers/test_excited_states_solvers.py` & `qiskit-nature-0.6.0/test/algorithms/excited_state_solvers/test_excited_states_solvers.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py` & `qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py` & `qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/test_adapt_vqe.py` & `qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/test_adapt_vqe.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/test_advanced_ucc_variants.py` & `qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/test_advanced_ucc_variants.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/test_groundstate_eigensolver.py` & `qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/test_groundstate_eigensolver.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
```

### Comparing `qiskit-nature-0.5.2/test/algorithms/ground_state_solvers/test_swaprz.py` & `qiskit-nature-0.6.0/test/algorithms/ground_state_solvers/test_swaprz.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/initial_points/resources/test_mp2_initial_point.json` & `qiskit-nature-0.6.0/test/algorithms/initial_points/resources/test_mp2_initial_point.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/initial_points/test_hf_initial_point.py` & `qiskit-nature-0.6.0/test/algorithms/initial_points/test_hf_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/initial_points/test_initial_point.py` & `qiskit-nature-0.6.0/test/algorithms/initial_points/test_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/initial_points/test_mp2_initial_point.py` & `qiskit-nature-0.6.0/test/algorithms/initial_points/test_mp2_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/initial_points/test_vscf_initial_point.py` & `qiskit-nature-0.6.0/test/algorithms/initial_points/test_vscf_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/pes_samplers/potentials/test_potential.py` & `qiskit-nature-0.6.0/test/algorithms/pes_samplers/potentials/test_potential.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/pes_samplers/test_bopes_sampler.py` & `qiskit-nature-0.6.0/test/algorithms/pes_samplers/test_bopes_sampler.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/algorithms/pes_samplers/test_extrapolators.py` & `qiskit-nature-0.6.0/test/algorithms/pes_samplers/test_extrapolators.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_chc.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_chc.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_puccd.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_puccd.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_succd.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_succd.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_ucc.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_ucc.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_uccsd.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_uccsd.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/test_uvcc.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/test_uvcc.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/ansatzes/utils/vibrational_op_label_creator.py` & `qiskit-nature-0.6.0/test/circuit/library/ansatzes/utils/vibrational_op_label_creator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/initial_states/test_fermionic_gaussian_state.py` & `qiskit-nature-0.6.0/test/circuit/library/initial_states/test_fermionic_gaussian_state.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,22 +9,24 @@
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test fermionic Gaussian state preparation circuits."""
 
 from test import QiskitNatureDeprecatedTestCase
-from test.nature_random import random_legacy_quadratic_hamiltonian as random_quadratic_hamiltonian
 
 import numpy as np
 from qiskit.quantum_info import Statevector
 
 from qiskit_nature.circuit.library import FermionicGaussianState
 from qiskit_nature.converters.second_quantization import QubitConverter
 from qiskit_nature.mappers.second_quantization import BravyiKitaevMapper, JordanWignerMapper
+from qiskit_nature.testing.random import (
+    random_legacy_quadratic_hamiltonian as random_quadratic_hamiltonian,
+)
 
 
 class TestFermionicGaussianState(QiskitNatureDeprecatedTestCase):
     """Tests for preparing fermionic Gaussian states determinants."""
 
     def test_fermionic_gaussian_state(self):
         """Test preparing fermionic Gaussian states."""
```

### Comparing `qiskit-nature-0.5.2/test/circuit/library/initial_states/test_hartree_fock.py` & `qiskit-nature-0.6.0/test/circuit/library/initial_states/test_hartree_fock.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/initial_states/test_slater_determinant.py` & `qiskit-nature-0.6.0/test/circuit/library/initial_states/test_slater_determinant.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,22 +9,24 @@
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test Slater determinant state preparation circuits."""
 
 from test import QiskitNatureDeprecatedTestCase
-from test.nature_random import random_legacy_quadratic_hamiltonian as random_quadratic_hamiltonian
 
 import numpy as np
 from qiskit.quantum_info import Statevector
 
 from qiskit_nature.circuit.library import SlaterDeterminant
 from qiskit_nature.converters.second_quantization import QubitConverter
 from qiskit_nature.mappers.second_quantization import BravyiKitaevMapper, JordanWignerMapper
+from qiskit_nature.testing.random import (
+    random_legacy_quadratic_hamiltonian as random_quadratic_hamiltonian,
+)
 
 
 class TestSlaterDeterminant(QiskitNatureDeprecatedTestCase):
     """Tests for preparing Slater determinants."""
 
     def test_slater_determinant(self):
         """Test preparing Slater determinants."""
```

### Comparing `qiskit-nature-0.5.2/test/circuit/library/initial_states/test_vscf.py` & `qiskit-nature-0.6.0/test/circuit/library/initial_states/test_vscf.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/circuit/library/test_bogoliubov_transform.py` & `qiskit-nature-0.6.0/test/circuit/library/test_bogoliubov_transform.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,25 +9,27 @@
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test Bogoliubov transform circuits."""
 
 from test import QiskitNatureDeprecatedTestCase
-from test.nature_random import random_legacy_quadratic_hamiltonian as random_quadratic_hamiltonian
 
 import numpy as np
 from ddt import data, ddt, unpack
 from qiskit import QuantumCircuit, QuantumRegister
 from qiskit.quantum_info import Operator, Statevector, random_hermitian, random_unitary
 
 from qiskit_nature.circuit.library import BogoliubovTransform
 from qiskit_nature.converters.second_quantization import QubitConverter
 from qiskit_nature.mappers.second_quantization import BravyiKitaevMapper, JordanWignerMapper
 from qiskit_nature.operators.second_quantization.quadratic_hamiltonian import QuadraticHamiltonian
+from qiskit_nature.testing.random import (
+    random_legacy_quadratic_hamiltonian as random_quadratic_hamiltonian,
+)
 
 
 def _expand_transformation_matrix(mat: np.ndarray) -> np.ndarray:
     n, _ = mat.shape
     left = mat[:, :n]
     right = mat[:, n:]
     return np.block([[left, right], [right.conj(), left.conj()]])
```

### Comparing `qiskit-nature-0.5.2/test/converters/second_quantization/test_qubit_converter.py` & `qiskit-nature-0.6.0/test/converters/second_quantization/test_qubit_converter.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """ Test Driver FCIDump """
 
 from typing import cast
-
+import builtins
 import unittest
 from abc import ABC, abstractmethod
 from test import QiskitNatureDeprecatedTestCase
 import numpy as np
 from qiskit_nature.drivers.second_quantization import FCIDumpDriver
 from qiskit_nature.properties.second_quantization.electronic import ElectronicEnergy, ParticleNumber
 from qiskit_nature.properties.second_quantization.electronic.bases import ElectronicBasis
@@ -43,30 +43,30 @@
         self.mo_eri_ba = None
         self.mo_eri_bb = None
 
     @abstractmethod
     def subTest(self, msg, **kwargs):
         # pylint: disable=invalid-name
         """subtest"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None):
         """assert Almost Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertEqual(self, first, second, msg=None):
         """assert equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
         """assert Sequence Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     def test_driver_result_electronic_energy(self):
         """Test the ElectronicEnergy property."""
         electronic_energy = cast(
             ElectronicEnergy, self.driver_result.get_property(ElectronicEnergy)
         )
```

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_dumper.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_dumper.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """ Test Driver FCIDump Dumping """
 
 import tempfile
+import builtins
 import unittest
 from abc import ABC, abstractmethod
 from test import QiskitNatureDeprecatedTestCase
 import numpy as np
 from qiskit_nature import QiskitNatureError
 from qiskit_nature.drivers import UnitsType
 from qiskit_nature.drivers.second_quantization import FCIDumpDriver, PySCFDriver
@@ -38,30 +39,30 @@
         self.mo_onee = None
         self.mo_eri = None
 
     @abstractmethod
     def subTest(self, msg, **kwargs):
         # pylint: disable=invalid-name
         """subtest"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None):
         """assert Almost Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertEqual(self, first, second, msg=None):
         """assert equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
         """assert Sequence Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     def test_dumped_inactive_energy(self):
         """dumped inactive energy test"""
         self.log.debug("Dumped inactive energy is %g", self.dumped["ECORE"])
         self.assertAlmostEqual(self.dumped["ECORE"], self.core_energy, places=3)
 
     def test_dumped_num_molecular_orbitals(self):
```

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_lih.fcidump` & `qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_lih.fcidump`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_lih.npz` & `qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_lih.npz`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_oh.fcidump` & `qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_oh.fcidump`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_oh.npz` & `qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_fcidump_oh.npz`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/fcidumpd/test_driver_methods_fcidump.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/fcidumpd/test_driver_methods_fcidump.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_extra.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_extra.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_forces.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_forces.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_from_mat.mat` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_from_mat.mat`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_from_mat.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_from_mat.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_A03.txt` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_A03.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_C01.txt` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_C01.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_vibrational_energy.hdf5` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_gaussian_log_vibrational_energy.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/gaussiand/test_driver_methods_gaussian.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/gaussiand/test_driver_methods_gaussian.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/hdf5d/test_driver_hdf5.hdf5` & `qiskit-nature-0.6.0/test/drivers/second_quantization/hdf5d/test_driver_hdf5.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/hdf5d/test_driver_hdf5.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/hdf5d/test_driver_hdf5.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/hdf5d/test_driver_hdf5_legacy.hdf5` & `qiskit-nature-0.6.0/test/drivers/second_quantization/hdf5d/test_driver_hdf5_legacy.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/psi4d/test_driver_methods_psi4.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/psi4d/test_driver_methods_psi4.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/psi4d/test_driver_psi4.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/psi4d/test_driver_psi4.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/psi4d/test_driver_psi4_extra.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/psi4d/test_driver_psi4_extra.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/pyquanted/test_driver_methods_pyquante.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/pyquanted/test_driver_methods_pyquante.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/pyquanted/test_driver_pyquante.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/pyquanted/test_driver_pyquante.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/pyscfd/test_driver_methods_pyscf.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/pyscfd/test_driver_methods_pyscf.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/pyscfd/test_driver_pyscf.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/pyscfd/test_driver_pyscf.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/test_driver.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/test_driver.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,26 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """ Test Driver """
 
+from __future__ import annotations
+import builtins
 from abc import ABC, abstractmethod
 from typing import cast
+from logging import Logger
 
 import numpy as np
 
 from qiskit_nature.drivers import Molecule
 from qiskit_nature.properties.second_quantization.electronic import (
     ParticleNumber,
     ElectronicEnergy,
@@ -35,38 +38,38 @@
 
     MOLECULE = Molecule(
         geometry=[("H", [0.0, 0.0, 0.0]), ("H", [0.0, 0.0, 0.735])],
         multiplicity=1,
         charge=0,
     )
 
-    def __init__(self):
-        self.log = None
-        self.driver_result: ElectronicStructureDriverResult = None
+    def __init__(self) -> None:
+        self.log: Logger | None = None
+        self.driver_result: ElectronicStructureDriverResult | None = None
 
     @abstractmethod
     def subTest(self, msg, **kwargs):
         # pylint: disable=invalid-name
         """subtest"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None):
         """assert Almost Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertEqual(self, first, second, msg=None):
         """assert equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
         """assert Sequence Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     def test_driver_result_electronic_energy(self):
         """Test the ElectronicEnergy property."""
         electronic_energy = cast(
             ElectronicEnergy, self.driver_result.get_property(ElectronicEnergy)
         )
```

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/test_driver_methods_gsc.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/test_driver_methods_gsc.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/test_driver_molecule.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/test_driver_molecule.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/drivers/second_quantization/test_molecule_driver.py` & `qiskit-nature-0.6.0/test/drivers/second_quantization/test_molecule_driver.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/resources/bksf_lih.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/resources/bksf_lih.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/resources/reference_direct_mapper.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/resources/reference_direct_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/test_bksf_mapper.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/test_bksf_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/test_bravyi_kitaev_mapper.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/test_bravyi_kitaev_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/test_direct_mapper.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/test_direct_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/test_jordan_wigner_mapper.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/test_jordan_wigner_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/test_linear_mapper.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/test_linear_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/test_logarithmic_mapper.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/test_logarithmic_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/mappers/second_quantization/test_parity_mapper.py` & `qiskit-nature-0.6.0/test/mappers/second_quantization/test_parity_mapper.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/nature_random.py` & `qiskit-nature-0.6.0/qiskit_nature/testing/random.py`

 * *Files 18% similar despite different names*

```diff
@@ -12,73 +12,54 @@
 
 """Methods to sample random objects."""
 
 from typing import Any
 
 import numpy as np
 from qiskit.quantum_info import random_hermitian
-from qiskit.utils import algorithm_globals
+
 from qiskit_nature.operators.second_quantization import (
     QuadraticHamiltonian as LegacyQuadraticHamiltonian,
 )
 from qiskit_nature.second_q.hamiltonians import QuadraticHamiltonian
 
 
-# TODO see if type of seed can be specified instead of using Any
-def parse_random_seed(seed: Any) -> np.random.Generator:
-    """Parse a random number generator seed and return a Generator.
-
-    Args:
-        seed: The pseudorandom number generator or seed. Should be an
-            instance of `np.random.Generator` or else a valid input to
-            `np.random.default_rng`
-
-    Returns:
-        The np.random.Generator instance
-    """
-    if seed is None:
-        return algorithm_globals.random
-    if isinstance(seed, np.random.Generator):
-        return seed
-    return np.random.default_rng(seed)
-
-
 def random_antisymmetric_matrix(dim: int, seed: Any = None) -> np.ndarray:
     """Return a random antisymmetric matrix.
 
     Args:
         dim: The width and height of the matrix.
         seed: The pseudorandom number generator or seed. Should be an
             instance of `np.random.Generator` or else a valid input to
-            `np.random.default_rng`
+            `np.random.default_rng`.
 
     Returns:
         The sampled antisymmetric matrix.
     """
-    rng = parse_random_seed(seed)
+    rng = np.random.default_rng(seed)
     mat = rng.standard_normal((dim, dim)) + 1j * rng.standard_normal((dim, dim))
     return mat - mat.T
 
 
 def random_quadratic_hamiltonian(
     n_orbitals: int, num_conserving: bool = False, seed: Any = None
 ) -> QuadraticHamiltonian:
     """Generate a random instance of QuadraticHamiltonian.
 
     Args:
-        n_orbitals: the number of orbitals
-        num_conserving: whether the Hamiltonian should conserve particle number
+        n_orbitals: The number of orbitals.
+        num_conserving: Whether the Hamiltonian should conserve particle number.
         seed: The pseudorandom number generator or seed. Should be an
             instance of `np.random.Generator` or else a valid input to
-            `np.random.default_rng`
+            `np.random.default_rng`.
 
     Returns:
-        The sampled QuadraticHamiltonian
+        The sampled QuadraticHamiltonian.
     """
-    rng = parse_random_seed(seed)
+    rng = np.random.default_rng(seed)
     hermitian_part = np.array(random_hermitian(n_orbitals, seed=rng))
     antisymmetric_part = (
         None if num_conserving else random_antisymmetric_matrix(n_orbitals, seed=rng)
     )
     constant = rng.standard_normal()
     return QuadraticHamiltonian(
         hermitian_part=hermitian_part, antisymmetric_part=antisymmetric_part, constant=constant
@@ -88,24 +69,24 @@
 # pylint: disable=invalid-name
 def random_legacy_quadratic_hamiltonian(
     n_orbitals: int, num_conserving: bool = False, seed: Any = None
 ) -> LegacyQuadraticHamiltonian:
     """Generate a random instance of QuadraticHamiltonian.
 
     Args:
-        n_orbitals: the number of orbitals
-        num_conserving: whether the Hamiltonian should conserve particle number
+        n_orbitals: The number of orbitals.
+        num_conserving: Whether the Hamiltonian should conserve particle number.
         seed: The pseudorandom number generator or seed. Should be an
             instance of `np.random.Generator` or else a valid input to
-            `np.random.default_rng`
+            `np.random.default_rng`.
 
     Returns:
-        The sampled QuadraticHamiltonian
+        The sampled QuadraticHamiltonian.
     """
-    rng = parse_random_seed(seed)
+    rng = np.random.default_rng(seed)
     hermitian_part = np.array(random_hermitian(n_orbitals, seed=rng))
     antisymmetric_part = (
         None if num_conserving else random_antisymmetric_matrix(n_orbitals, seed=rng)
     )
     constant = rng.standard_normal()
     return LegacyQuadraticHamiltonian(
         hermitian_part=hermitian_part, antisymmetric_part=antisymmetric_part, constant=constant
```

### Comparing `qiskit-nature-0.5.2/test/nature_test_case.py` & `qiskit-nature-0.6.0/test/nature_test_case.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -16,20 +16,23 @@
 from abc import ABC
 import warnings
 import inspect
 import logging
 import os
 import unittest
 import time
+import math
+from qiskit.quantum_info import SparsePauliOp
 from qiskit_nature import settings
 from qiskit_nature.deprecation import NatureDeprecationWarning
 
 # disable unit tests NatureDeprecationWarning warnings on imports
 warnings.filterwarnings("ignore", category=NatureDeprecationWarning)
 
+
 # disable deprecation warnings that can cause log output overflow
 # pylint: disable=unused-argument
 
 
 def _noop(*args, **kargs):
     pass
 
@@ -103,14 +106,61 @@
         Returns:
             str: the absolute path to the resource.
         """
         root = os.path.dirname(self._class_location)
         path = root if path is None else os.path.join(root, path)
         return os.path.normpath(os.path.join(path, filename))
 
+    def assertEqualSparsePauliOp(
+        self, expected: SparsePauliOp, observed: SparsePauliOp, message: str = ""
+    ) -> None:
+        """Assert that 'expected' is equal to 'observed'.
+        Args:
+            expected: expected SparsePauliOp value.
+            observed: observed SparsePauliOp value.
+            message: additional message
+        Raises:
+            AssertionError: arguments are different
+        """
+
+        def _key_func(list_item):
+            return list_item[0]
+
+        for (lbl1, coeff1), (lbl2, coeff2) in zip(
+            sorted(expected.to_list(), key=_key_func), sorted(observed.to_list(), key=_key_func)
+        ):
+            if lbl1 != lbl2 or not math.isclose(coeff1.real, coeff2.real, rel_tol=1e-05):
+                msg = f"labels: {lbl1}, {lbl2} != coefficients: {coeff1.real}. {coeff2.real}"
+                if len(message) > 0:
+                    msg = f"{msg} : {message}"
+
+                raise AssertionError(msg)
+
+    def assertNotEqualSparsePauliOp(
+        self, expected: SparsePauliOp, observed: SparsePauliOp, message: str = ""
+    ) -> None:
+        """Assert that 'expected' is not equal to 'observed'.
+        Args:
+            expected: expected SparsePauliOp value.
+            observed: observed SparsePauliOp value.
+            message: additional message
+        Raises:
+            AssertionError: arguments are different
+        """
+
+        try:
+            self.assertEqualSparsePauliOp(expected, observed, message)
+        except AssertionError:
+            return
+
+        msg = f"{expected} == {observed}"
+        if len(message) > 0:
+            msg = f"{msg} : {message}"
+        raise AssertionError(msg)
+
 
 class QiskitNatureDeprecatedTestCase(QiskitNatureTestCase):
     """Nature Deprecated Test Case.
     Used for tests that need to suppress deprecation messages.
     """
 
     def setUp(self) -> None:
```

### Comparing `qiskit-nature-0.5.2/test/operators/second_quantization/test_fermionic_op.py` & `qiskit-nature-0.6.0/test/operators/second_quantization/test_fermionic_op.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/operators/second_quantization/test_quadratic_hamiltonian.py` & `qiskit-nature-0.6.0/test/operators/second_quantization/test_quadratic_hamiltonian.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,24 +9,24 @@
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Tests for QuadraticHamiltonian"""
 
 from test import QiskitNatureDeprecatedTestCase
-from test.nature_random import random_antisymmetric_matrix
 
 import numpy as np
 from ddt import data, ddt
 from qiskit.quantum_info import random_hermitian
 
 from qiskit_nature.converters.second_quantization import QubitConverter
 from qiskit_nature.mappers.second_quantization import JordanWignerMapper
 from qiskit_nature.operators.second_quantization import QuadraticHamiltonian
 from qiskit_nature.operators.second_quantization.fermionic_op import FermionicOp
+from qiskit_nature.testing import random_antisymmetric_matrix
 
 
 @ddt
 class TestQuadraticHamiltonian(QiskitNatureDeprecatedTestCase):
     """QuadraticHamiltonian tests."""
 
     def test_init(self):
```

### Comparing `qiskit-nature-0.5.2/test/operators/second_quantization/test_spin_op.py` & `qiskit-nature-0.6.0/test/operators/second_quantization/test_spin_op.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/operators/second_quantization/test_vibrational_op.py` & `qiskit-nature-0.6.0/test/operators/second_quantization/test_vibrational_op.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/operators/second_quantization/utils.py` & `qiskit-nature-0.6.0/test/operators/second_quantization/utils.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_contacts/test_contact_map_builder.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_contacts/test_contact_map_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_distances/test_distance_map.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_distances/test_distance_map.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/bead_distances/test_distance_map_builder.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/bead_distances/test_distance_map_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/data_loaders/test_energy_matrix_loader.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/data_loaders/test_energy_matrix_loader.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/interactions/test_mixed_interaction.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/interactions/test_mixed_interaction.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/interactions/test_miyazawa_jernigan_interaction.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/interactions/test_miyazawa_jernigan_interaction.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/interactions/test_random_interaction.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/interactions/test_random_interaction.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/beads/test_bead_main.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/beads/test_bead_main.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/beads/test_bead_side.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/beads/test_bead_side.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/chains/test_chain_main.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/chains/test_chain_main.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/chains/test_chain_side.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/chains/test_chain_side.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/peptide/test_peptide.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/peptide/test_peptide.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/qubit_utils/test_qubit_fixing.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/qubit_utils/test_qubit_fixing.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/qubit_utils/test_qubit_number_reducer.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/qubit_utils/test_qubit_number_reducer.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/file_parser.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/file_parser.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_distance_map/test_first_neighbor_side` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_distance_map/test_first_neighbor_side`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem_2_second_bead_side_chain` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_protein_folding_problem/test_protein_folding_problem_2_second_bead_side_chain`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_build_qubit_op_2_expected` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_build_qubit_op_2_expected`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_build_qubit_op_expected` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_build_qubit_op_expected`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbbb_expected` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbbb_expected`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_2_expected` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_2_expected`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_expected_h_bbsc` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_expected_h_bbsc`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_expected_h_scbb` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_bbsc_and_h_scbb_expected_h_scbb`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_chiral_expected` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/resources/test_qubit_op_builder/test_create_h_chiral_expected`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/test_protein_folding_problem.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/test_protein_folding_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/sampling/protein_folding/test_qubit_op_builder.py` & `qiskit-nature-0.6.0/test/problems/sampling/protein_folding/test_qubit_op_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/electronic/builders/test_hopping_ops_builder.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/electronic/builders/test_hopping_ops_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_active_space` & `qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_active_space`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_two_ints` & `qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/H2_631g_ferm_op_two_ints`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/electronic/resources/resource_reader.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/electronic/resources/resource_reader.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/electronic/test_electronic_structure_problem.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/electronic/test_electronic_structure_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_hyper_cubic_lattice.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_hyper_cubic_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_lattice.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_line_lattice.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_line_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_square_lattice.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_square_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/lattice/lattices/test_triangular_lattice.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/lattice/lattices/test_triangular_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/lattice/models/test_fermi_hubbard_model.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/lattice/models/test_fermi_hubbard_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/lattice/models/test_ising_model.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/lattice/models/test_ising_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/lattice/test_lattice_model_problem.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/lattice/test_lattice_model_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/builders/test_hopping_ops_builder.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/builders/test_hopping_ops_builder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/resources/expected_ops.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/resources/expected_ops.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/problems/second_quantization/vibrational/test_vibrational_structure_problem.py` & `qiskit-nature-0.6.0/test/problems/second_quantization/vibrational/test_vibrational_structure_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/property_test.py` & `qiskit-nature-0.6.0/test/properties/property_test.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/integral_property_op.json` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/integral_property_op.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_second_q_op_alpha_and_beta_expected.json` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_second_q_op_alpha_and_beta_expected.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_second_q_op_only_alpha_expected.json` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_second_q_op_only_alpha_expected.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_spin_alpha_and_beta_expected.numpy.bin` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_spin_alpha_and_beta_expected.numpy.bin`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_spin_only_alpha_expected.numpy.bin` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/resources/two_body_test_to_spin_only_alpha_expected.numpy.bin`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/test_integral_property.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/test_integral_property.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/test_one_body_electronic_integrals.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/test_one_body_electronic_integrals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/integrals/test_two_body_electronic_integrals.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/integrals/test_two_body_electronic_integrals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/resources/angular_momentum_op.json` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/resources/angular_momentum_op.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/resources/electronic_energy_op.json` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/resources/electronic_energy_op.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/resources/electronic_structure_driver_result.hdf5` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/resources/electronic_structure_driver_result.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_angular_momentum.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_angular_momentum.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_dipole_moment.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_dipole_moment.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_electronic_energy.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_electronic_energy.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_electronic_structure_driver_result.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_electronic_structure_driver_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_magnetization.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_magnetization.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/electronic/test_particle_number.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/electronic/test_particle_number.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/test_second_quantized_property.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/test_second_quantized_property.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_basis_2.json` & `qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_basis_2.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_second_q_op_2.json` & `qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/resources/test_harmonic_basis_to_second_q_op_2.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/bases/test_harmonic_basis.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/bases/test_harmonic_basis.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/resources/vibrational_energy_op.json` & `qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/resources/vibrational_energy_op.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/resources/vibrational_structure_driver_result.hdf5` & `qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/resources/vibrational_structure_driver_result.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/test_occupied_modals.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/test_occupied_modals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/test_vibrational_energy.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/test_vibrational_energy.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/second_quantization/vibrational/test_vibrational_structure_driver_result.py` & `qiskit-nature-0.6.0/test/properties/second_quantization/vibrational/test_vibrational_structure_driver_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/properties/test_grouped_property.py` & `qiskit-nature-0.6.0/test/properties/test_grouped_property.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/resources/test_hdf5_error_import_failure.hdf5` & `qiskit-nature-0.6.0/test/resources/test_hdf5_error_import_failure.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/resources/test_hdf5_error_missing_class.hdf5` & `qiskit-nature-0.6.0/test/resources/test_hdf5_error_missing_class.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/resources/test_hdf5_error_multiple_groups.hdf5` & `qiskit-nature-0.6.0/test/resources/test_hdf5_error_multiple_groups.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/resources/test_hdf5_error_non_native.hdf5` & `qiskit-nature-0.6.0/test/resources/test_hdf5_error_non_native.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/resources/test_hdf5_error_non_protocol.hdf5` & `qiskit-nature-0.6.0/test/resources/test_hdf5_error_non_protocol.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/results/test_eigenstate_result.py` & `qiskit-nature-0.6.0/test/results/test_eigenstate_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/results/test_electronic_structure_result.py` & `qiskit-nature-0.6.0/test/results/test_electronic_structure_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/results/test_protein_folding_result.py` & `qiskit-nature-0.6.0/test/results/test_protein_folding_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/results/utils/test_protein_decoder.py` & `qiskit-nature-0.6.0/test/results/utils/test_protein_decoder.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/results/utils/test_protein_shape_file_gen.py` & `qiskit-nature-0.6.0/test/results/utils/test_protein_shape_file_gen.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/runtime/__init__.py` & `qiskit-nature-0.6.0/test/runtime/__init__.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/runtime/fake_vqeruntime.py` & `qiskit-nature-0.6.0/test/runtime/fake_vqeruntime.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/runtime/test_vqeprogram.py` & `qiskit-nature-0.6.0/test/runtime/test_vqeprogram.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,17 +12,19 @@
 
 """Test the VQE program."""
 
 from test import QiskitNatureDeprecatedTestCase
 from test.runtime.fake_vqeruntime import FakeRuntimeProvider
 
 import unittest
+import warnings
 from ddt import ddt, data
 import numpy as np
 from qiskit.providers.basicaer import QasmSimulatorPy
+from qiskit.providers.fake_provider import FakeArmonk, FakeArmonkV2
 from qiskit.algorithms import VQEResult
 from qiskit.algorithms.optimizers import SPSA
 from qiskit.circuit.library import RealAmplitudes
 from qiskit.opflow import I, Z
 
 from qiskit_nature.algorithms.ground_state_solvers import GroundStateEigensolver
 from qiskit_nature.converters.second_quantization import QubitConverter
@@ -40,30 +42,35 @@
         operator = Z ^ I ^ Z
         initial_point = np.random.random(circuit.num_parameters)
         backend = QasmSimulatorPy()
 
         provider = FakeRuntimeProvider()
         vqe_cls = VQEClient
 
-        vqe = vqe_cls(
-            ansatz=circuit,
-            optimizer=SPSA(),
-            initial_point=initial_point,
-            backend=backend,
-            provider=provider,
-        )
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            vqe = vqe_cls(
+                ansatz=circuit,
+                optimizer=SPSA(),
+                initial_point=initial_point,
+                backend=backend,
+                provider=provider,
+            )
 
         return vqe, operator
 
     @data({"name": "SPSA", "maxiter": 100}, SPSA(maxiter=100))
     def test_standard_case(self, optimizer):
         """Test a standard use case."""
         vqe, operator = self.get_standard_program()
         vqe.optimizer = optimizer
-        result = vqe.compute_minimum_eigenvalue(operator)
+
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            result = vqe.compute_minimum_eigenvalue(operator)
 
         self.assertIsInstance(result, VQEResult)
         self.assertIsInstance(result, VQERuntimeResult)
 
     def test_supports_aux_ops(self):
         """Test the VQEClient says it supports aux operators."""
         vqe, _ = self.get_standard_program()
@@ -72,10 +79,31 @@
     def test_return_groundstate(self):
         """Test the VQEClient yields a ground state solver that returns the ground state."""
         vqe, _ = self.get_standard_program()
         qubit_converter = QubitConverter(JordanWignerMapper())
         gss = GroundStateEigensolver(qubit_converter, vqe)
         self.assertTrue(gss.returns_groundstate)
 
+    @data(FakeArmonk, FakeArmonkV2)
+    def test_v1_and_v2_compatibility(self, backend_cls):
+        """Test the VQE client is compatible both with V1 and V2 backends.
+
+        Regression test of github.com/Qiskit/qiskit-nature/issues/1100.
+        """
+        provider = FakeRuntimeProvider()
+        backend = backend_cls()
+
+        circuit = RealAmplitudes(1, reps=0)
+        operator = Z
+        initial_point = np.array([0])
+        optimizer = SPSA(maxiter=1, perturbation=0.1, learning_rate=0.1)
+
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            vqe = VQEClient(circuit, optimizer, initial_point, provider, backend)
+            result = vqe.compute_minimum_eigenvalue(operator)
+
+        self.assertIsInstance(result, VQERuntimeResult)
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/eigensolver_factories/test_numpy_eigensolver_factory.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 """ Test NumPyMinimumEigensolver Factory """
 import unittest
+import warnings
 from test import QiskitNatureTestCase
 import numpy as np
 
 from qiskit.algorithms.eigensolvers import NumPyEigensolver
 from qiskit_nature.units import DistanceUnit
 from qiskit_nature.second_q.algorithms import NumPyEigensolverFactory
 from qiskit_nature.second_q.drivers import PySCFDriver
@@ -42,17 +43,19 @@
         self.electronic_structure_problem = self.driver.run()
 
         # pylint: disable=unused-argument
         def filter_criterion(eigenstate, eigenvalue, aux_values):
             return np.isclose(aux_values["ParticleNumber"][0], 2.0)
 
         self.k = 99
-        self._numpy_eigensolver_factory = NumPyEigensolverFactory(
-            filter_criterion=filter_criterion, k=self.k
-        )
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            self._numpy_eigensolver_factory = NumPyEigensolverFactory(
+                filter_criterion=filter_criterion, k=self.k
+            )
 
     def test_setters_getters(self):
         """Test Getter/Setter"""
 
         # filter_criterion
         self.assertIsNotNone(self._numpy_eigensolver_factory.filter_criterion)
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/excited_state_solvers/test_bosonic_esc_calculation.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """ Test Numerical qEOM excited states calculation """
 
 import contextlib
 import io
 import unittest
+import warnings
 
 from test import QiskitNatureTestCase
 
 import numpy as np
 
 from qiskit.algorithms.optimizers import COBYLA
 from qiskit.primitives import Estimator
@@ -103,45 +104,53 @@
         for i in range(1, len(computed)):
             with self.subTest(f"{i}. excited state"):
                 self.assertAlmostEqual(computed[i], references[i], places=places)
 
     def test_numpy_mes(self):
         """Test with NumPyMinimumEigensolver"""
         estimator = Estimator()
-        solver = NumPyMinimumEigensolverFactory(use_default_filter_criterion=True)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = NumPyMinimumEigensolverFactory(use_default_filter_criterion=True)
         gsc = GroundStateEigensolver(self.qubit_converter, solver)
         esc = QEOM(gsc, estimator, "sd")
         results = esc.solve(self.vibrational_problem)
         self._assert_energies(results.computed_vibrational_energies, self.reference_energies)
 
     def test_numpy_factory(self):
         """Test with NumPyEigensolver"""
-        solver = NumPyEigensolverFactory(use_default_filter_criterion=True)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = NumPyEigensolverFactory(use_default_filter_criterion=True)
         esc = ExcitedStatesEigensolver(self.qubit_converter, solver)
         results = esc.solve(self.vibrational_problem)
         self._assert_energies(results.computed_vibrational_energies, self.reference_energies)
 
     def test_vqe_uvccsd_factory(self):
         """Test with VQE plus UVCCSD"""
         optimizer = COBYLA(maxiter=5000)
         estimator = Estimator()
-        solver = VQEUVCCFactory(estimator, UVCCSD(), optimizer)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUVCCFactory(estimator, UVCCSD(), optimizer)
         gsc = GroundStateEigensolver(self.qubit_converter, solver)
         esc = QEOM(gsc, estimator, "sd")
         results = esc.solve(self.vibrational_problem)
         self._assert_energies(
             results.computed_vibrational_energies, self.reference_energies, places=0
         )
 
     def test_vqe_uvcc_factory_with_user_initial_point(self):
         """Test VQEUVCCFactory when using it with a user defined initial point."""
         initial_point = np.asarray([-7.35250290e-05, -9.73079292e-02, -5.43346282e-05])
         estimator = Estimator()
         optimizer = COBYLA(maxiter=1)
-        solver = VQEUVCCFactory(estimator, UVCCSD(), optimizer, initial_point=initial_point)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUVCCFactory(estimator, UVCCSD(), optimizer, initial_point=initial_point)
         gsc = GroundStateEigensolver(self.qubit_converter, solver)
         esc = QEOM(gsc, estimator, "sd")
         results = esc.solve(self.vibrational_problem)
         np.testing.assert_array_almost_equal(
             results.raw_result.ground_state_raw_result.optimal_point, initial_point
         )
 
@@ -150,15 +159,17 @@
 
         def cb_callback(nfev, parameters, energy, stddev):
             print(f"iterations {nfev}: energy: {energy}")
 
         estimator = Estimator()
         optimizer = COBYLA(maxiter=5000)
 
-        solver = VQEUVCCFactory(estimator, UVCCSD(), optimizer, callback=cb_callback)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUVCCFactory(estimator, UVCCSD(), optimizer, callback=cb_callback)
         gsc = GroundStateEigensolver(self.qubit_converter, solver)
         esc = QEOM(gsc, estimator, "sd")
         with contextlib.redirect_stdout(io.StringIO()) as out:
             results = esc.solve(self.vibrational_problem)
         self._assert_energies(
             results.computed_vibrational_energies, self.reference_energies, places=0
         )
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/excited_state_solvers/test_excited_states_solvers.py` & `qiskit-nature-0.6.0/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_eigensolver.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,215 +1,174 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
-""" Test Numerical qEOM excited states calculation """
+"""Ground state computation using a minimum eigensolver."""
 
-import unittest
+from __future__ import annotations
 
-from test import QiskitNatureTestCase
-import numpy as np
-
-from qiskit.algorithms.eigensolvers import NumPyEigensolver
-from qiskit.algorithms.minimum_eigensolvers import NumPyMinimumEigensolver
-from qiskit.algorithms.optimizers import SLSQP
-from qiskit.primitives import Estimator
-from qiskit.utils import algorithm_globals
-
-from qiskit_nature.units import DistanceUnit
-from qiskit_nature.second_q.circuit.library import UCCSD
-from qiskit_nature.second_q.transformers import ActiveSpaceTransformer
-from qiskit_nature.second_q.drivers import PySCFDriver
-from qiskit_nature.second_q.mappers import (
-    BravyiKitaevMapper,
-    JordanWignerMapper,
-    ParityMapper,
-)
-from qiskit_nature.second_q.mappers import QubitConverter
-from qiskit_nature.second_q.algorithms import (
-    GroundStateEigensolver,
-    VQEUCCFactory,
-    NumPyEigensolverFactory,
-    ExcitedStatesEigensolver,
-    QEOM,
-)
-import qiskit_nature.optionals as _optionals
-
-
-class TestNumericalQEOMESCCalculation(QiskitNatureTestCase):
-    """Test Numerical qEOM excited states calculation"""
-
-    @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
-    def setUp(self):
-        super().setUp()
-        algorithm_globals.random_seed = 8
-        self.driver = PySCFDriver(
-            atom="H .0 .0 .0; H .0 .0 0.75",
-            unit=DistanceUnit.ANGSTROM,
-            charge=0,
-            spin=0,
-            basis="sto3g",
-        )
-
-        self.reference_energies = [
-            -1.8427016,
-            -1.8427016 + 0.5943372,
-            -1.8427016 + 0.95788352,
-            -1.8427016 + 1.5969296,
-        ]
-        self.qubit_converter = QubitConverter(JordanWignerMapper())
-        self.electronic_structure_problem = self.driver.run()
-
-        solver = NumPyEigensolver()
-        self.ref = solver
-
-    def _assert_energies(self, computed, references, *, places=4):
-        with self.subTest("same number of energies"):
-            self.assertEqual(len(computed), len(references))
-
-        with self.subTest("ground state"):
-            self.assertAlmostEqual(computed[0], references[0], places=places)
-
-        for i in range(1, len(computed)):
-            with self.subTest(f"{i}. excited state"):
-                self.assertAlmostEqual(computed[i], references[i], places=places)
-
-    def test_numpy_mes(self):
-        """Test NumPyMinimumEigenSolver with QEOM"""
-        solver = NumPyMinimumEigensolver()
-        gsc = GroundStateEigensolver(self.qubit_converter, solver)
-        esc = QEOM(gsc, Estimator(), "sd")
-        results = esc.solve(self.electronic_structure_problem)
-        self._assert_energies(results.computed_energies, self.reference_energies)
-
-    def test_vqe_mes_jw(self):
-        """Test VQEUCCSDFactory with QEOM + Jordan Wigner mapping"""
-        converter = QubitConverter(JordanWignerMapper())
-        self._solve_with_vqe_mes(converter)
-
-    def test_vqe_mes_jw_auto(self):
-        """Test VQEUCCSDFactory with QEOM + Jordan Wigner mapping + auto symmetry"""
-        converter = QubitConverter(JordanWignerMapper(), z2symmetry_reduction="auto")
-        self._solve_with_vqe_mes(converter)
-
-    def test_vqe_mes_parity(self):
-        """Test VQEUCCSDFactory with QEOM + Parity mapping"""
-        converter = QubitConverter(ParityMapper())
-        self._solve_with_vqe_mes(converter)
-
-    def test_vqe_mes_parity_2q(self):
-        """Test VQEUCCSDFactory with QEOM + Parity mapping + reduction"""
-        converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)
-        self._solve_with_vqe_mes(converter)
-
-    def test_vqe_mes_parity_auto(self):
-        """Test VQEUCCSDFactory with QEOM + Parity mapping + auto symmetry"""
-        converter = QubitConverter(ParityMapper(), z2symmetry_reduction="auto")
-        self._solve_with_vqe_mes(converter)
-
-    def test_vqe_mes_parity_2q_auto(self):
-        """Test VQEUCCSDFactory with QEOM + Parity mapping + reduction + auto symmetry"""
-        converter = QubitConverter(
-            ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction="auto"
-        )
-        self._solve_with_vqe_mes(converter)
-
-    def test_vqe_mes_bk(self):
-        """Test VQEUCCSDFactory with QEOM + Bravyi-Kitaev mapping"""
-        converter = QubitConverter(BravyiKitaevMapper())
-        self._solve_with_vqe_mes(converter)
-
-    def test_vqe_mes_bk_auto(self):
-        """Test VQEUCCSDFactory with QEOM + Bravyi-Kitaev mapping + auto symmetry"""
-        converter = QubitConverter(BravyiKitaevMapper(), z2symmetry_reduction="auto")
-        self._solve_with_vqe_mes(converter)
-
-    def _solve_with_vqe_mes(self, converter: QubitConverter):
-        estimator = Estimator()
-        solver = VQEUCCFactory(estimator, UCCSD(), SLSQP())
-        gsc = GroundStateEigensolver(converter, solver)
-        esc = QEOM(gsc, estimator, "sd")
-        results = esc.solve(self.electronic_structure_problem)
-        self._assert_energies(results.computed_energies, self.reference_energies)
-
-    def test_numpy_factory(self):
-        """Test NumPyEigenSolverFactory with ExcitedStatesEigensolver"""
+import logging
 
+from qiskit.algorithms.minimum_eigensolvers import MinimumEigensolver
+from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
+
+from qiskit_nature.second_q.operators import SparseLabelOp
+from qiskit_nature.second_q.mappers import QubitConverter, QubitMapper
+from qiskit_nature.second_q.problems import BaseProblem
+from qiskit_nature.second_q.problems import EigenstateResult
+from qiskit_nature.deprecation import deprecate_arguments, warn_deprecated_type
+
+from .ground_state_solver import GroundStateSolver
+from .minimum_eigensolver_factories import MinimumEigensolverFactory
+
+LOGGER = logging.getLogger(__name__)
+
+
+class GroundStateEigensolver(GroundStateSolver):
+    """Ground state computation using a minimum eigensolver."""
+
+    @deprecate_arguments(
+        "0.6.0",
+        {"qubit_converter": "qubit_mapper"},
+        additional_msg=(
+            ". Additionally, the QubitConverter type in the qubit_mapper argument is deprecated "
+            "and support for it will be removed together with the qubit_converter argument."
+        ),
+    )
+    def __init__(
+        self,
+        qubit_mapper: QubitConverter | QubitMapper,
+        solver: MinimumEigensolver | MinimumEigensolverFactory,
+        *,
+        qubit_converter: QubitConverter | QubitMapper | None = None,
+    ) -> None:
         # pylint: disable=unused-argument
-        def filter_criterion(eigenstate, eigenvalue, aux_values):
-            return np.isclose(aux_values["ParticleNumber"][0], 2.0)
+        """
+        Args:
+            qubit_mapper: The :class:`~qiskit_nature.second_q.mappers.QubitMapper`
+                or :class:`~qiskit_nature.second_q.mappers.QubitConverter` (use of the latter is
+                deprecated) instance that converts a second quantized operator to qubit operators.
+            qubit_converter: DEPRECATED The :class:`~qiskit_nature.second_q.mappers.QubitConverter`
+                or :class:`~qiskit_nature.second_q.mappers.QubitMapper` instance that converts a
+                second quantized operator to qubit operators and applies subsequent qubit reduction.
+            solver: Minimum Eigensolver or MESFactory object, e.g. the VQEUCCSDFactory.
+        """
+        super().__init__(qubit_mapper)
+        if isinstance(solver, MinimumEigensolverFactory):
+            warn_deprecated_type(
+                "0.6.0",
+                "solver",
+                "MinimumEigensolverFactory",
+            )
+        self._solver = solver
 
-        solver = NumPyEigensolverFactory(filter_criterion=filter_criterion)
-        esc = ExcitedStatesEigensolver(self.qubit_converter, solver)
-        results = esc.solve(self.electronic_structure_problem)
-
-        # filter duplicates from list
-        computed_energies = [results.computed_energies[0]]
-        for comp_energy in results.computed_energies[1:]:
-            if not np.isclose(comp_energy, computed_energies[-1]):
-                computed_energies.append(comp_energy)
-
-        self._assert_energies(computed_energies, self.reference_energies)
-
-    def test_custom_filter_criterion(self):
-        """Test NumPyEigenSolverFactory with ExcitedStatesEigensolver + Custom filter criterion
-        for doublet states"""
-
-        driver = PySCFDriver(
-            atom="Be .0 .0 .0; H .0 .0 0.75",
-            unit=DistanceUnit.ANGSTROM,
-            charge=0,
-            spin=1,
-            basis="sto3g",
+    @property
+    def solver(self) -> MinimumEigensolver | MinimumEigensolverFactory:
+        return self._solver
+
+    def supports_aux_operators(self):
+        return self.solver.supports_aux_operators()
+
+    def solve(
+        self,
+        problem: BaseProblem,
+        aux_operators: dict[str, SparseLabelOp | SparsePauliOp | PauliSumOp] | None = None,
+    ) -> EigenstateResult:
+        """Compute Ground State properties.
+
+        Args:
+            problem: A class encoding a problem to be solved.
+            aux_operators: Additional auxiliary operators to evaluate.
+
+        Returns:
+            An interpreted :class:`~.EigenstateResult`. For more information see also
+            :meth:`~.BaseProblem.interpret`.
+        """
+        main_operator, aux_ops = self.get_qubit_operators(problem, aux_operators)
+        raw_mes_result = self.solver.compute_minimum_eigenvalue(  # type: ignore
+            main_operator, aux_ops
         )
 
-        transformer = ActiveSpaceTransformer((1, 2), 4)
-        # We define an ActiveSpaceTransformer to reduce the duration of this test example.
-
-        converter = QubitConverter(JordanWignerMapper(), z2symmetry_reduction="auto")
-
-        esp = transformer.transform(driver.run())
-
-        expected_spin = 0.75  # Doublet states
-        expected_num_electrons = 3  # 1 alpha electron + 2 beta electrons
-
-        # pylint: disable=unused-argument
-        def custom_filter_criterion(eigenstate, eigenvalue, aux_values):
-            num_particles_aux = aux_values["ParticleNumber"][0]
-            total_angular_momentum_aux = aux_values["AngularMomentum"][0]
-
-            return np.isclose(total_angular_momentum_aux, expected_spin) and np.isclose(
-                num_particles_aux, expected_num_electrons
+        eigenstate_result = EigenstateResult.from_result(raw_mes_result)
+        result = problem.interpret(eigenstate_result)
+        return result
+
+    def get_qubit_operators(
+        self,
+        problem: BaseProblem,
+        aux_operators: dict[str, SparseLabelOp | SparsePauliOp | PauliSumOp] | None = None,
+    ) -> tuple[SparsePauliOp | PauliSumOp, dict[str, SparsePauliOp | PauliSumOp] | None]:
+        # Note that ``aux_ops`` contains not only the transformed ``aux_operators`` passed by the
+        # user but also additional ones from the transformation
+        main_second_q_op, aux_second_q_ops = problem.second_q_ops()
+
+        num_particles = getattr(problem, "num_particles", None)
+
+        if isinstance(self._qubit_mapper, QubitConverter):
+            main_operator = self._qubit_mapper.convert(
+                main_second_q_op,
+                num_particles=num_particles,
+                sector_locator=problem.symmetry_sector_locator,
             )
-
-        solver = NumPyEigensolverFactory(filter_criterion=custom_filter_criterion)
-        esc = ExcitedStatesEigensolver(converter, solver)
-        results = esc.solve(esp)
-
-        # filter duplicates from list
-        computed_energies = [results.computed_energies[0]]
-        for comp_energy in results.computed_energies[1:]:
-            if not np.isclose(comp_energy, computed_energies[-1]):
-                computed_energies.append(comp_energy)
-
-        ref_energies = [
-            -2.6362023196223254,
-            -2.2971398524128923,
-            -2.2020252702733165,
-            -2.1044859216523752,
-            -1.696132447109807,
-            -1.6416831059956618,
-        ]
-
-        self._assert_energies(computed_energies, ref_energies, places=3)
-
-
-if __name__ == "__main__":
-    unittest.main()
+            aux_ops = self._qubit_mapper.convert_match(aux_second_q_ops)
+        else:
+            main_operator = self._qubit_mapper.map(main_second_q_op)
+            aux_ops = self._qubit_mapper.map(aux_second_q_ops)
+
+        if aux_operators is not None:
+            for name_aux, aux_op in aux_operators.items():
+                if isinstance(aux_op, PauliSumOp):
+                    warn_deprecated_type(
+                        "0.6.0",
+                        argument_name="aux_operators",
+                        old_type="PauliSumOp",
+                        new_type="SparsePauliOp",
+                    )
+                if isinstance(aux_op, SparseLabelOp):
+                    if isinstance(self._qubit_mapper, QubitConverter):
+                        converted_aux_op = self._qubit_mapper.convert_match(aux_op)
+                    else:
+                        converted_aux_op = self._qubit_mapper.map(aux_op)
+                else:
+                    converted_aux_op = aux_op
+
+                if name_aux in aux_ops.keys():
+                    LOGGER.warning(
+                        "The key '%s' was already taken by an internally constructed auxiliary "
+                        "operator! The internal operator was overridden by the one provided manually. "
+                        "If this was not the intended behavior, please consider renaming "
+                        "this operator.",
+                        name_aux,
+                    )
+                if converted_aux_op is not None:
+                    # The custom op overrides the default op if the key is already taken.
+                    aux_ops[name_aux] = converted_aux_op
+                else:
+                    LOGGER.warning(
+                        "The manually provided operator '%s' got reduced to `None` in the mapping "
+                        "process. This can occur for example when it does not commute with the "
+                        "hamiltonian after applying the determined symmetry reductions. Thus, this "
+                        "operator will not be used!",
+                        name_aux,
+                    )
+
+        if isinstance(self.solver, MinimumEigensolverFactory):
+            warn_deprecated_type(
+                "0.6.0",
+                "solver",
+                "MinimumEigensolverFactory",
+            )
+            # this must be called after transformation.transform
+            self._solver = self.solver.get_solver(problem, self._qubit_mapper)
+        # if the eigensolver does not support auxiliary operators, reset them
+        if not self.solver.supports_aux_operators():
+            aux_ops = None
+        return main_operator, aux_ops
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_ucc_factory.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """ Test VQE UCC MinimumEigensolver Factory """
 
 import unittest
+import warnings
 
 from test import QiskitNatureTestCase
 
 from qiskit.algorithms.optimizers import SLSQP
 from qiskit.primitives import Estimator
 
 from qiskit_nature.second_q.circuit.library import HartreeFock, UCC, UCCSD
@@ -31,16 +32,18 @@
     """Test VQE UCC MinimumEigensolver Factory"""
 
     # NOTE: The actual usage of this class is mostly tested in combination with the ground-state
     # eigensolvers (one module above).
 
     def setUp(self):
         super().setUp()
-        self.converter = QubitConverter(JordanWignerMapper())
-        self._vqe_ucc_factory = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
+        self.mapper = QubitConverter(JordanWignerMapper())
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            self._vqe_ucc_factory = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
 
     def auxiliary_tester(self, title: str, prop: str, cases: tuple):
         """
         Tests the setter and getter of a given property.
 
         Args:
             title: A string that will be the name of the subTest
@@ -106,14 +109,14 @@
             self.assertTrue(isinstance(self._vqe_ucc_factory.ansatz, UCCSD))
             self._vqe_ucc_factory.ansatz = UCC()
             self.assertTrue(isinstance(self._vqe_ucc_factory.ansatz, UCC))
             self.assertFalse(isinstance(self._vqe_ucc_factory.ansatz, UCCSD))
 
         with self.subTest("Initial State"):
             self.assertEqual(self._vqe_ucc_factory.initial_state, None)
-            initial_state = HartreeFock(4, (1, 1), self.converter)
+            initial_state = HartreeFock(4, (1, 1), self.mapper)
             self._vqe_ucc_factory.initial_state = initial_state
             self.assertEqual(self._vqe_ucc_factory.initial_state, initial_state)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/minimum_eigensolver_factories/test_vqe_uvcc_factory.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 """ Test VQE UVCC MinimumEigensolver Factory """
 
 import unittest
+import warnings
 
 from test import QiskitNatureTestCase
 
 from qiskit.algorithms.optimizers import SLSQP
 from qiskit.primitives import Estimator
 
 from qiskit_nature.second_q.circuit.library import HartreeFock, UVCC, UVCCSD
@@ -29,16 +30,18 @@
     """Test VQE UVCC MinimumEigensolver Factory"""
 
     # NOTE: The actual usage of this class is mostly tested in combination with the ground-state
     # eigensolvers (one module above).
 
     def setUp(self):
         super().setUp()
-        self.converter = QubitConverter(JordanWignerMapper())
-        self._vqe_uvcc_factory = VQEUVCCFactory(Estimator(), UVCCSD(), SLSQP())
+        self.mapper = QubitConverter(JordanWignerMapper())
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            self._vqe_uvcc_factory = VQEUVCCFactory(Estimator(), UVCCSD(), SLSQP())
 
     def auxiliary_tester(self, title: str, prop: str, cases: tuple):
         """
         Tests the setter and getter of a given property.
 
         Args:
             title: A string that will be the name of the subTest
@@ -103,14 +106,14 @@
             self.assertTrue(isinstance(self._vqe_uvcc_factory.ansatz, UVCCSD))
             self._vqe_uvcc_factory.ansatz = UVCC()
             self.assertTrue(isinstance(self._vqe_uvcc_factory.ansatz, UVCC))
             self.assertFalse(isinstance(self._vqe_uvcc_factory.ansatz, UVCCSD))
 
         with self.subTest("Initial State"):
             self.assertEqual(self._vqe_uvcc_factory.initial_state, None)
-            initial_state = HartreeFock(4, (1, 1), self.converter)
+            initial_state = HartreeFock(4, (1, 1), self.mapper)
             self._vqe_uvcc_factory.initial_state = initial_state
             self.assertEqual(self._vqe_uvcc_factory.initial_state, initial_state)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/test_advanced_ucc_variants.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/test_advanced_ucc_variants.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2019, 2022.
+# (C) Copyright IBM 2019, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -38,25 +38,25 @@
 
     @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
     def setUp(self):
         super().setUp()
         algorithm_globals.random_seed = 42
         self.driver = PySCFDriver(atom="H 0 0 0.735; H 0 0 0", basis="631g")
 
-        self.qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)
+        self.mapper = QubitConverter(ParityMapper(), two_qubit_reduction=True)
 
         self.electronic_structure_problem = FreezeCoreTransformer().transform(self.driver.run())
 
         self.num_spatial_orbitals = 4
         self.num_particles = (1, 1)
 
         # because we create the initial state and ansatzes early, we need to ensure the qubit
-        # converter already ran such that convert_match works as expected
+        # mapper already ran such that convert_match works as expected
         main_op, _ = self.electronic_structure_problem.second_q_ops()
-        _ = self.qubit_converter.convert(
+        _ = self.mapper.convert(
             main_op,
             self.num_particles,
         )
 
         self.reference_energy_pUCCD = -1.1434447924298028
         self.reference_energy_UCCD0 = -1.1476045878481704
         self.reference_energy_UCCD0full = -1.1515491334334347
@@ -84,92 +84,86 @@
         ]
 
     @slow_test
     def test_uccsd_hf_qpUCCD(self):
         """paired uccd test"""
         optimizer = SLSQP(maxiter=100)
 
-        initial_state = HartreeFock(
-            self.num_spatial_orbitals, self.num_particles, self.qubit_converter
-        )
+        initial_state = HartreeFock(self.num_spatial_orbitals, self.num_particles, self.mapper)
 
         ansatz = PUCCD(
             self.num_spatial_orbitals,
             self.num_particles,
-            self.qubit_converter,
+            self.mapper,
             initial_state=initial_state,
         )
 
         solver = VQE(
             ansatz=ansatz,
             optimizer=optimizer,
             estimator=Estimator(),
             initial_point=[0.0] * ansatz.num_parameters,
         )
 
-        gsc = GroundStateEigensolver(self.qubit_converter, solver)
+        gsc = GroundStateEigensolver(self.mapper, solver)
 
         result = gsc.solve(self.electronic_structure_problem)
 
         self.assertAlmostEqual(result.total_energies[0], self.reference_energy_pUCCD, places=6)
 
     @slow_test
     def test_uccsd_hf_qUCCD0(self):
         """singlet uccd test"""
         optimizer = SLSQP(maxiter=100)
 
-        initial_state = HartreeFock(
-            self.num_spatial_orbitals, self.num_particles, self.qubit_converter
-        )
+        initial_state = HartreeFock(self.num_spatial_orbitals, self.num_particles, self.mapper)
 
         ansatz = SUCCD(
             self.num_spatial_orbitals,
             self.num_particles,
-            self.qubit_converter,
+            self.mapper,
             initial_state=initial_state,
         )
 
         solver = VQE(
             ansatz=ansatz,
             optimizer=optimizer,
             estimator=Estimator(),
             initial_point=[0.0] * ansatz.num_parameters,
         )
 
-        gsc = GroundStateEigensolver(self.qubit_converter, solver)
+        gsc = GroundStateEigensolver(self.mapper, solver)
 
         result = gsc.solve(self.electronic_structure_problem)
 
         self.assertAlmostEqual(result.total_energies[0], self.reference_energy_UCCD0, places=6)
 
     @slow_test
     def test_uccsd_hf_qUCCD0full(self):
         """singlet full uccd test"""
         optimizer = SLSQP(maxiter=100)
 
-        initial_state = HartreeFock(
-            self.num_spatial_orbitals, self.num_particles, self.qubit_converter
-        )
+        initial_state = HartreeFock(self.num_spatial_orbitals, self.num_particles, self.mapper)
 
         ansatz = SUCCD(
             self.num_spatial_orbitals,
             self.num_particles,
-            self.qubit_converter,
+            self.mapper,
             initial_state=initial_state,
             mirror=True,
         )
 
         solver = VQE(
             ansatz=ansatz,
             optimizer=optimizer,
             estimator=Estimator(),
             initial_point=[0.0] * ansatz.num_parameters,
         )
 
-        gsc = GroundStateEigensolver(self.qubit_converter, solver)
+        gsc = GroundStateEigensolver(self.mapper, solver)
 
         result = gsc.solve(self.electronic_structure_problem)
 
         self.assertAlmostEqual(result.total_energies[0], self.reference_energy_UCCD0full, places=6)
 
 
 if __name__ == "__main__":
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/test_groundstate_eigensolver.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/test_groundstate_eigensolver.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,14 +12,15 @@
 
 """ Test GroundStateEigensolver """
 
 import contextlib
 import copy
 import io
 import unittest
+import warnings
 
 from test import QiskitNatureTestCase
 
 import numpy as np
 
 from qiskit.algorithms.minimum_eigensolvers import VQE
 from qiskit.algorithms.optimizers import SLSQP, SPSA
@@ -50,69 +51,91 @@
         super().setUp()
         self.driver = PySCFDriver()
         self.seed = 56
         algorithm_globals.random_seed = self.seed
 
         self.reference_energy = -1.1373060356951838
 
-        self.qubit_converter = QubitConverter(JordanWignerMapper())
+        self.mapper = JordanWignerMapper()
+        self.qubit_converter = QubitConverter(self.mapper)
         self.electronic_structure_problem = self.driver.run()
 
         self.num_spatial_orbitals = 2
         self.num_particles = (1, 1)
         self.mp2_initial_point = [0.0, 0.0, -0.07197145]
 
     def test_npme(self):
         """Test NumPyMinimumEigensolver"""
-        solver = NumPyMinimumEigensolverFactory()
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = NumPyMinimumEigensolverFactory()
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
 
     def test_npme_with_default_filter(self):
         """Test NumPyMinimumEigensolver with default filter"""
-        solver = NumPyMinimumEigensolverFactory(use_default_filter_criterion=True)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = NumPyMinimumEigensolverFactory(use_default_filter_criterion=True)
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
 
     def test_vqe_uccsd(self):
         """Test VQE UCCSD case"""
-        solver = VQEUCCFactory(Estimator(), UCC(excitations="d"), SLSQP())
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUCCFactory(Estimator(), UCC(excitations="d"), SLSQP())
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
 
+    def test_vqe_uccsd_mapper(self):
+        """Test VQE UCCSD case with QubitMapper"""
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUCCFactory(Estimator(), UCC(excitations="d"), SLSQP())
+        calc = GroundStateEigensolver(self.mapper, solver)
+        res = calc.solve(self.electronic_structure_problem)
+        self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
+
     def test_vqe_uccsd_with_callback(self):
         """Test VQE UCCSD with callback."""
 
         def callback(nfev, parameters, energy, stddev):
             # pylint: disable=unused-argument
             print(f"iterations {nfev}: energy: {energy}")
 
-        solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP(), callback=callback)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP(), callback=callback)
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         with contextlib.redirect_stdout(io.StringIO()) as out:
             res = calc.solve(self.electronic_structure_problem)
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
         for idx, line in enumerate(out.getvalue().split("\n")):
             if line.strip():
                 self.assertTrue(line.startswith(f"iterations {idx+1}: energy: "))
 
     def test_vqe_ucc_custom(self):
         """Test custom ansatz in Factory use case"""
-        solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
 
     def test_aux_ops_reusability(self):
         """Test that the auxiliary operators can be reused"""
         # Regression test against #1475
-        solver = NumPyMinimumEigensolverFactory()
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = NumPyMinimumEigensolverFactory()
         calc = GroundStateEigensolver(self.qubit_converter, solver)
 
         modes = 4
         h_1 = np.eye(modes, dtype=complex)
         h_2 = np.zeros((modes, modes, modes, modes))
         aux_ops = [ElectronicEnergy.from_raw_integrals(h_1, h_2).second_q_op()]
         aux_ops_copy = copy.deepcopy(aux_ops)
@@ -121,15 +144,17 @@
 
         assert all(
             frozenset(a.items()) == frozenset(b.items()) for a, b in zip(aux_ops, aux_ops_copy)
         )
 
     def _setup_evaluation_operators(self):
         # first we run a ground state calculation
-        solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
 
         # now we decide that we want to evaluate another operator
         # for testing simplicity, we just use some pre-constructed auxiliary operators
         _, second_q_ops = self.electronic_structure_problem.second_q_ops()
         aux_ops_dict = self.qubit_converter.convert_match(second_q_ops)
@@ -195,132 +220,153 @@
         problem = FreezeCoreTransformer().transform(driver.run())
         qubit_converter = QubitConverter(
             ParityMapper(),
             two_qubit_reduction=True,
             z2symmetry_reduction="auto",
         )
 
-        solver = NumPyMinimumEigensolverFactory()
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = NumPyMinimumEigensolverFactory()
         gsc = GroundStateEigensolver(qubit_converter, solver)
 
         result = gsc.solve(problem)
         self.assertAlmostEqual(result.total_energies[0], -7.882, places=2)
 
     def test_total_dipole(self):
         """Regression test against #198.
 
         An issue with calculating the dipole moment that had division None/float.
         """
-        solver = NumPyMinimumEigensolverFactory()
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = NumPyMinimumEigensolverFactory()
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
         self.assertAlmostEqual(res.total_dipole_moment_in_debye[0], 0.0, places=1)
 
     def test_print_result(self):
         """Regression test against #198 and general issues with printing results."""
-        solver = NumPyMinimumEigensolverFactory()
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = NumPyMinimumEigensolverFactory()
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
+        res.formatting_precision = 6
         with contextlib.redirect_stdout(io.StringIO()) as out:
             print(res)
         # do NOT change the below! Lines have been truncated as to not force exact numerical matches
         expected = """\
             === GROUND STATE ENERGY ===
 
-            * Electronic ground state energy (Hartree): -1.857
-              - computed part:      -1.857
-            ~ Nuclear repulsion energy (Hartree): 0.719
-            > Total ground state energy (Hartree): -1.137
+            * Electronic ground state energy (Hartree): -1.857275
+              - computed part:      -1.857275
+            ~ Nuclear repulsion energy (Hartree): 0.719969
+            > Total ground state energy (Hartree): -1.137306
 
             === MEASURED OBSERVABLES ===
 
               0:  # Particles: 2.000 S: 0.000 S^2: 0.000 M: 0.000
 
             === DIPOLE MOMENTS ===
 
-            ~ Nuclear dipole moment (a.u.): [0.0  0.0  1.38
+            ~ Nuclear dipole moment (a.u.): [0.0  0.0  1.388949]
 
               0:
-              * Electronic dipole moment (a.u.): [0.0  0.0  1.38
-                - computed part:      [0.0  0.0  1.38
-              > Dipole moment (a.u.): [0.0  0.0  0.0]  Total: 0.
-                             (debye): [0.0  0.0  0.0]  Total: 0.
+              * Electronic dipole moment (a.u.): [0.0  0.0  1.388949]
+                - computed part:      [0.0  0.0  1.388949]
+              > Dipole moment (a.u.): [0.0  0.0  0.0]  Total: 0.0
+                             (debye): [0.0  0.0  0.0]  Total: 0.0
         """
         for truth, expected in zip(out.getvalue().split("\n"), expected.split("\n")):
             assert truth.strip().startswith(expected.strip())
 
     def test_default_initial_point(self):
         """Test when using the default initial point."""
 
-        solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
-
+        # pylint: disable=no-member
         np.testing.assert_array_equal(solver.initial_point.to_numpy_array(), [0.0, 0.0, 0.0])
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
 
     def test_vqe_ucc_factory_with_user_initial_point(self):
         """Test VQEUCCFactory when using it with a user defined initial point."""
 
         initial_point = np.asarray([1.28074029e-19, 5.92226076e-08, 1.11762559e-01])
-        solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP(maxiter=1), initial_point=initial_point)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUCCFactory(
+                Estimator(), UCCSD(), SLSQP(maxiter=1), initial_point=initial_point
+            )
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
         np.testing.assert_array_almost_equal(res.raw_result.optimal_point, initial_point)
 
     def test_vqe_ucc_factory_with_mp2(self):
         """Test when using MP2InitialPoint to generate the initial point."""
 
         initial_point = MP2InitialPoint()
 
-        solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP(), initial_point=initial_point)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP(), initial_point=initial_point)
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
-
+        # pylint: disable=no-member
         np.testing.assert_array_almost_equal(
             solver.initial_point.to_numpy_array(), self.mp2_initial_point
         )
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
 
     def test_vqe_ucc_factory_with_reps(self):
         """Test when using the default initial point with repeated evolved operators."""
-        ansatz = UCCSD(
-            qubit_converter=self.qubit_converter,
-            num_particles=self.num_particles,
-            num_spatial_orbitals=self.num_spatial_orbitals,
-            reps=2,
-        )
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            ansatz = UCCSD(
+                qubit_converter=self.qubit_converter,
+                num_particles=self.num_particles,
+                num_spatial_orbitals=self.num_spatial_orbitals,
+                reps=2,
+            )
+
+            solver = VQEUCCFactory(Estimator(), ansatz, SLSQP())
 
-        solver = VQEUCCFactory(Estimator(), ansatz, SLSQP())
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
-
+        # pylint: disable=no-member
         np.testing.assert_array_almost_equal(
             solver.initial_point.to_numpy_array(), np.zeros(6, dtype=float)
         )
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
 
     def test_vqe_ucc_factory_with_mp2_with_reps(self):
         """Test when using MP2InitialPoint to generate the initial point with repeated evolved
         operators.
         """
 
         initial_point = MP2InitialPoint()
 
-        ansatz = UCCSD(
-            qubit_converter=self.qubit_converter,
-            num_particles=self.num_particles,
-            num_spatial_orbitals=self.num_spatial_orbitals,
-            reps=2,
-        )
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            ansatz = UCCSD(
+                qubit_converter=self.qubit_converter,
+                num_particles=self.num_particles,
+                num_spatial_orbitals=self.num_spatial_orbitals,
+                reps=2,
+            )
+
+            solver = VQEUCCFactory(Estimator(), ansatz, SLSQP(), initial_point=initial_point)
 
-        solver = VQEUCCFactory(Estimator(), ansatz, SLSQP(), initial_point=initial_point)
         calc = GroundStateEigensolver(self.qubit_converter, solver)
         res = calc.solve(self.electronic_structure_problem)
-
+        # pylint: disable=no-member
         np.testing.assert_array_almost_equal(
             solver.initial_point.to_numpy_array(), np.tile(self.mp2_initial_point, 2)
         )
         self.assertAlmostEqual(res.total_energies[0], self.reference_energy, places=6)
 
 
 if __name__ == "__main__":
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/ground_state_solvers/test_swaprz.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/ground_state_solvers/test_swaprz.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2019, 2022.
+# (C) Copyright IBM 2019, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -46,38 +46,38 @@
     @slow_test
     @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
     def test_excitation_preserving(self):
         """Test the excitation preserving wavefunction on a chemistry example."""
 
         driver = PySCFDriver()
 
-        converter = QubitConverter(ParityMapper())
+        mapper = QubitConverter(ParityMapper())
 
         problem = driver.run()
 
         _ = problem.second_q_ops()
 
         num_particles = problem.num_particles
         num_spatial_orbitals = problem.num_spatial_orbitals
 
         optimizer = SLSQP(maxiter=100)
 
-        initial_state = HartreeFock(num_spatial_orbitals, num_particles, converter)
+        initial_state = HartreeFock(num_spatial_orbitals, num_particles, mapper)
 
         num_qubits = 2 * num_spatial_orbitals
         wavefunction = ExcitationPreserving(int(num_qubits))
         wavefunction.compose(initial_state, front=True, inplace=True)
 
         solver = VQE(
             ansatz=wavefunction,
             optimizer=optimizer,
             estimator=Estimator(),
         )
 
-        gsc = GroundStateEigensolver(converter, solver)
+        gsc = GroundStateEigensolver(mapper, solver)
 
         result = gsc.solve(problem)
         self.assertAlmostEqual(result.total_energies[0], self.reference_energy, places=4)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/test_hf_initial_point.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/test_hf_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/test_initial_point.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/test_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/test_mp2_initial_point.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/test_mp2_initial_point.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -68,48 +68,51 @@
 
         problem = driver.run()
         problem.second_q_ops()
 
         num_particles = (problem.num_alpha, problem.num_beta)
         num_spatial_orbitals = problem.num_spatial_orbitals
 
-        qubit_converter = QubitConverter(mapper=JordanWignerMapper())
+        mapper = QubitConverter(mapper=JordanWignerMapper())
 
         initial_state = HartreeFock(
             num_spatial_orbitals=num_spatial_orbitals,
             num_particles=num_particles,
-            qubit_converter=qubit_converter,
+            qubit_mapper=mapper,
         )
         ansatz = UCC(
             num_spatial_orbitals=num_spatial_orbitals,
             num_particles=num_particles,
             excitations="sd",
-            qubit_converter=qubit_converter,
+            qubit_mapper=mapper,
             initial_state=initial_state,
         )
 
         mp2_initial_point = MP2InitialPoint()
         mp2_initial_point.problem = problem
         mp2_initial_point.ansatz = ansatz
 
         with self.subTest("Test the MP2 energy correction."):
-            np.testing.assert_almost_equal(
-                mp2_initial_point.energy_correction, pyscf_mp.e_corr, decimal=4
-            )
+            energy_correction = mp2_initial_point.energy_correction
+            if hasattr(energy_correction, "todense"):
+                energy_correction = energy_correction.todense()
+            np.testing.assert_almost_equal(energy_correction, pyscf_mp.e_corr, decimal=4)
 
         with self.subTest("Test the total MP2 energy."):
-            np.testing.assert_almost_equal(
-                mp2_initial_point.total_energy, pyscf_mp.e_tot, decimal=4
-            )
+            total_energy = mp2_initial_point.total_energy
+            if hasattr(total_energy, "todense"):
+                total_energy = total_energy.todense()
+            np.testing.assert_almost_equal(total_energy, pyscf_mp.e_tot, decimal=4)
 
         with self.subTest("Test the T2 amplitudes."):
             mp2_initial_point.compute()
-            np.testing.assert_array_almost_equal(
-                mp2_initial_point.t2_amplitudes, pyscf_mp.t2, decimal=4
-            )
+            t2_amplitudes = mp2_initial_point.t2_amplitudes
+            if hasattr(t2_amplitudes, "todense"):
+                t2_amplitudes = t2_amplitudes.todense()
+            np.testing.assert_array_almost_equal(t2_amplitudes, pyscf_mp.t2, decimal=4)
 
     def test_no_threshold(self):
         """Test when no threshold is provided."""
 
         mp2_initial_point = MP2InitialPoint(threshold=None)
         self.assertEqual(mp2_initial_point.threshold, 0.0)
```

### Comparing `qiskit-nature-0.5.2/test/second_q/algorithms/initial_points/test_vscf_initial_point.py` & `qiskit-nature-0.6.0/test/second_q/algorithms/initial_points/test_vscf_initial_point.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_chc.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_chc.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2019, 2022.
+# (C) Copyright IBM 2019, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -69,32 +69,38 @@
         ]
         num_modals = [2, 2]
 
         vibrational_op_labels = _create_labels(co2_2modes_2modals_2body)
 
         vibr_op = VibrationalOp(vibrational_op_labels, num_modals)
 
-        converter = QubitConverter(DirectMapper())
-
-        qubit_op = converter.convert_match(vibr_op)
-
         init_state = VSCF(num_modals)
 
         num_qubits = sum(num_modals)
         excitations = []
         excitations += generate_vibration_excitations(num_excitations=1, num_modals=num_modals)
         excitations += generate_vibration_excitations(num_excitations=2, num_modals=num_modals)
         chc_ansatz = CHC(
             num_qubits, ladder=False, excitations=excitations, initial_state=init_state
         )
 
         optimizer = COBYLA(maxiter=1000)
-
         algo = VQE(Estimator(), chc_ansatz, optimizer)
-        vqe_result = algo.compute_minimum_eigenvalue(qubit_op)
-        energy = vqe_result.optimal_value
 
-        self.assertAlmostEqual(energy, self.reference_energy, places=4)
+        mapper = DirectMapper()
+        converter = QubitConverter(mapper)
+
+        with self.subTest("Qubit Converter object"):
+            qubit_op = converter.convert_match(vibr_op)
+            vqe_result = algo.compute_minimum_eigenvalue(qubit_op)
+            energy = vqe_result.optimal_value
+            self.assertAlmostEqual(energy, self.reference_energy, places=4)
+
+        with self.subTest("Qubit Mapper object"):
+            qubit_op = mapper.map(vibr_op)
+            vqe_result = algo.compute_minimum_eigenvalue(qubit_op)
+            energy = vqe_result.optimal_value
+            self.assertAlmostEqual(energy, self.reference_energy, places=4)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_puccd.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_puccd.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -46,18 +46,18 @@
                 FermionicOp({"+_1 +_5 -_2 -_6": 1j, "+_6 +_2 -_5 -_1": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_1 +_5 -_3 -_7": 1j, "+_7 +_3 -_5 -_1": -1j}, num_spin_orbitals=8),
             ],
         ),
     )
     def test_puccd_ansatz(self, num_spatial_orbitals, num_particles, expect):
         """Tests the PUCCD Ansatz."""
-        converter = QubitConverter(JordanWignerMapper())
+        mapper = QubitConverter(JordanWignerMapper())
 
         ansatz = PUCCD(
-            qubit_converter=converter,
+            qubit_mapper=mapper,
             num_particles=num_particles,
             num_spatial_orbitals=num_spatial_orbitals,
         )
 
         assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
 
     @unpack
@@ -91,18 +91,18 @@
             ],
         ),
     )
     def test_puccd_ansatz_with_singles(
         self, num_spatial_orbitals, num_particles, include_singles, expect
     ):
         """Tests the PUCCD Ansatz with included single excitations."""
-        converter = QubitConverter(JordanWignerMapper())
+        mapper = QubitConverter(JordanWignerMapper())
 
         ansatz = PUCCD(
-            qubit_converter=converter,
+            qubit_mapper=mapper,
             num_particles=num_particles,
             num_spatial_orbitals=num_spatial_orbitals,
             include_singles=include_singles,
         )
 
         assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
 
@@ -130,21 +130,31 @@
                 FermionicOp({"+_0 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_1 +_4 -_2 -_5": 1j, "+_5 +_2 -_4 -_1": -1j}, num_spin_orbitals=6),
             ],
         ),
     )
     def test_puccd_ansatz_generalized(self, num_spatial_orbitals, num_particles, expect):
         """Tests the generalized PUCCD Ansatz."""
-        converter = QubitConverter(JordanWignerMapper())
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
 
-        ansatz = PUCCD(
-            qubit_converter=converter,
-            num_particles=num_particles,
-            num_spatial_orbitals=num_spatial_orbitals,
-            generalized=True,
-        )
-
-        assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
+        with self.subTest("Qubit Converter object"):
+            ansatz = PUCCD(
+                qubit_mapper=converter,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+                generalized=True,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
+
+        with self.subTest("Qubit Mapper object"):
+            ansatz = PUCCD(
+                qubit_mapper=mapper,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+                generalized=True,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_succd.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_uccsd.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,329 +1,229 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
-"""Test the SUCCD Ansatz."""
+"""Test the UCCSD Ansatz."""
 
 from test import QiskitNatureTestCase
 from test.second_q.circuit.library.ansatzes.test_ucc import assert_ucc_like_ansatz
 
 import unittest
 
 from ddt import ddt, data, unpack
 
-from qiskit_nature import QiskitNatureError
-from qiskit_nature.second_q.circuit.library import SUCCD
+from qiskit_nature.second_q.circuit.library import UCCSD
 from qiskit_nature.second_q.mappers import JordanWignerMapper
 from qiskit_nature.second_q.operators import FermionicOp
 from qiskit_nature.second_q.mappers import QubitConverter
 
 
 @ddt
-class TestSUCCD(QiskitNatureTestCase):
-    """Tests for the SUCCD Ansatz."""
+class TestUCCSD(QiskitNatureTestCase):
+    """Tests for the UCCSD Ansatz."""
 
     @unpack
     @data(
         (
             2,
             (1, 1),
-            [FermionicOp({"+_0 +_2 -_1 -_3": 1j, "+_3 +_1 -_2 -_0": -1j}, num_spin_orbitals=4)],
+            [
+                FermionicOp({"+_0 -_1": 1j, "+_1 -_0": -1j}, num_spin_orbitals=4),
+                FermionicOp({"+_2 -_3": 1j, "+_3 -_2": -1j}, num_spin_orbitals=4),
+                FermionicOp({"+_0 +_2 -_1 -_3": 1j, "+_3 +_1 -_2 -_0": -1j}, num_spin_orbitals=4),
+            ],
         ),
         (
             4,
             (2, 2),
             [
+                FermionicOp({"+_0 -_2": 1j, "+_2 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 -_3": 1j, "+_3 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 -_2": 1j, "+_2 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 -_3": 1j, "+_3 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_4 -_6": 1j, "+_6 -_4": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_4 -_7": 1j, "+_7 -_4": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_5 -_6": 1j, "+_6 -_5": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_5 -_7": 1j, "+_7 -_5": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_1 -_2 -_3": 1j, "+_3 +_2 -_1 -_0": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_0 +_4 -_2 -_6": 1j, "+_6 +_2 -_4 -_0": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_0 +_4 -_2 -_7": 1j, "+_7 +_2 -_4 -_0": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_0 +_5 -_2 -_6": 1j, "+_6 +_2 -_5 -_0": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_0 +_5 -_2 -_7": 1j, "+_7 +_2 -_5 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_4 -_3 -_6": 1j, "+_6 +_3 -_4 -_0": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_0 +_4 -_3 -_7": 1j, "+_7 +_3 -_4 -_0": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_0 +_5 -_3 -_6": 1j, "+_6 +_3 -_5 -_0": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_0 +_5 -_3 -_7": 1j, "+_7 +_3 -_5 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_2 -_6": 1j, "+_6 +_2 -_4 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_2 -_7": 1j, "+_7 +_2 -_4 -_1": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_1 +_5 -_2 -_6": 1j, "+_6 +_2 -_5 -_1": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_1 +_5 -_2 -_7": 1j, "+_7 +_2 -_5 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_3 -_6": 1j, "+_6 +_3 -_4 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_3 -_7": 1j, "+_7 +_3 -_4 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_5 -_3 -_6": 1j, "+_6 +_3 -_5 -_1": -1j}, num_spin_orbitals=8),
                 FermionicOp({"+_1 +_5 -_3 -_7": 1j, "+_7 +_3 -_5 -_1": -1j}, num_spin_orbitals=8),
-            ],
-        ),
-    )
-    def test_succd_ansatz(self, num_spatial_orbitals, num_particles, expect):
-        """Tests the SUCCD Ansatz."""
-        converter = QubitConverter(JordanWignerMapper())
-
-        ansatz = SUCCD(
-            qubit_converter=converter,
-            num_particles=num_particles,
-            num_spatial_orbitals=num_spatial_orbitals,
-        )
-
-        assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
-
-    @unpack
-    @data(
-        (
-            2,
-            (1, 1),
-            (True, True),
-            [
-                FermionicOp({"+_0 -_1": 1j, "+_1 -_0": -1j}, num_spin_orbitals=4),
-                FermionicOp({"+_2 -_3": 1j, "+_3 -_2": -1j}, num_spin_orbitals=4),
-                FermionicOp({"+_0 +_2 -_1 -_3": 1j, "+_3 +_1 -_2 -_0": -1j}, num_spin_orbitals=4),
-            ],
-        ),
-        (
-            2,
-            (1, 1),
-            (True, False),
-            [
-                FermionicOp({"+_0 -_1": 1j, "+_1 -_0": -1j}, num_spin_orbitals=4),
-                FermionicOp({"+_0 +_2 -_1 -_3": 1j, "+_3 +_1 -_2 -_0": -1j}, num_spin_orbitals=4),
+                FermionicOp({"+_4 +_5 -_6 -_7": 1j, "+_7 +_6 -_5 -_4": -1j}, num_spin_orbitals=8),
             ],
         ),
         (
-            2,
-            (1, 1),
-            (False, True),
+            4,
+            (2, 1),
             [
-                FermionicOp({"+_2 -_3": 1j, "+_3 -_2": -1j}, num_spin_orbitals=4),
-                FermionicOp({"+_0 +_2 -_1 -_3": 1j, "+_3 +_1 -_2 -_0": -1j}, num_spin_orbitals=4),
+                FermionicOp({"+_0 -_2": 1j, "+_2 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 -_3": 1j, "+_3 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 -_2": 1j, "+_2 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 -_3": 1j, "+_3 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_4 -_5": 1j, "+_5 -_4": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_4 -_6": 1j, "+_6 -_4": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_4 -_7": 1j, "+_7 -_4": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_1 -_2 -_3": 1j, "+_3 +_2 -_1 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_4 -_2 -_5": 1j, "+_5 +_2 -_4 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_4 -_2 -_6": 1j, "+_6 +_2 -_4 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_4 -_2 -_7": 1j, "+_7 +_2 -_4 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_4 -_3 -_5": 1j, "+_5 +_3 -_4 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_4 -_3 -_6": 1j, "+_6 +_3 -_4 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_0 +_4 -_3 -_7": 1j, "+_7 +_3 -_4 -_0": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_2 -_5": 1j, "+_5 +_2 -_4 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_2 -_6": 1j, "+_6 +_2 -_4 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_2 -_7": 1j, "+_7 +_2 -_4 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_3 -_5": 1j, "+_5 +_3 -_4 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_3 -_6": 1j, "+_6 +_3 -_4 -_1": -1j}, num_spin_orbitals=8),
+                FermionicOp({"+_1 +_4 -_3 -_7": 1j, "+_7 +_3 -_4 -_1": -1j}, num_spin_orbitals=8),
             ],
         ),
     )
-    def test_succd_ansatz_with_singles(
-        self, num_spatial_orbitals, num_particles, include_singles, expect
-    ):
-        """Tests the SUCCD Ansatz with included single excitations."""
-        converter = QubitConverter(JordanWignerMapper())
-
-        ansatz = SUCCD(
-            qubit_converter=converter,
-            num_particles=num_particles,
-            num_spatial_orbitals=num_spatial_orbitals,
-            include_singles=include_singles,
-        )
-
-        assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
-
-    def test_raise_non_singlet(self):
-        """Test an error is raised when the number of alpha and beta electrons differ."""
-        with self.assertRaises(QiskitNatureError):
-            SUCCD(num_particles=(2, 1))
+    def test_uccsd_ansatz(self, num_spatial_orbitals, num_particles, expect):
+        """Tests the UCCSD Ansatz."""
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
+
+        with self.subTest("Qubit Converter object"):
+            ansatz = UCCSD(
+                qubit_mapper=converter,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
+
+        with self.subTest("Qubit Mapper object"):
+            ansatz = UCCSD(
+                qubit_mapper=mapper,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
 
     @unpack
     @data(
         (
             3,
             (1, 1),
             [
+                FermionicOp({"+_0 -_1": 1j, "+_1 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_0 -_2": 1j, "+_2 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_1 -_2": 1j, "+_2 -_1": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_3 -_4": 1j, "+_4 -_3": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_3 -_5": 1j, "+_5 -_3": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_4 -_5": 1j, "+_5 -_4": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_0 +_3 -_1 -_4": 1j, "+_4 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_0 +_3 -_1 -_5": 1j, "+_5 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_0 +_4 -_1 -_5": 1j, "+_5 +_1 -_4 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_0 +_3 -_2 -_4": 1j, "+_4 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_0 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_0 +_4 -_2 -_5": 1j, "+_5 +_2 -_4 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_1 +_4 -_2 -_5": 1j, "+_5 +_2 -_4 -_1": -1j}, num_spin_orbitals=6),
-            ],
-        ),
-        (
-            3,
-            (2, 2),
-            [
-                FermionicOp({"+_0 +_3 -_1 -_4": 1j, "+_4 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_0 +_3 -_1 -_5": 1j, "+_5 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_0 +_4 -_1 -_5": 1j, "+_5 +_1 -_4 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_0 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_0 +_4 -_2 -_5": 1j, "+_5 +_2 -_4 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_1 +_3 -_2 -_4": 1j, "+_4 +_2 -_3 -_1": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_1 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_1": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_1 +_4 -_2 -_5": 1j, "+_5 +_2 -_4 -_1": -1j}, num_spin_orbitals=6),
             ],
         ),
     )
-    def test_succd_ansatz_generalized(self, num_spatial_orbitals, num_particles, expect):
-        """Tests the generalized SUCCD Ansatz."""
-        converter = QubitConverter(JordanWignerMapper())
-
-        ansatz = SUCCD(
-            qubit_converter=converter,
-            num_particles=num_particles,
-            num_spatial_orbitals=num_spatial_orbitals,
-            generalized=True,
-        )
-
-        assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
+    def test_uccsd_ansatz_generalized(self, num_spatial_orbitals, num_particles, expect):
+        """Tests the generalized UCCSD Ansatz."""
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
+
+        with self.subTest("Qubit Converter object"):
+            ansatz = UCCSD(
+                qubit_mapper=converter,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+                generalized=True,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
+
+        with self.subTest("Qubit Mapper object"):
+            ansatz = UCCSD(
+                qubit_mapper=mapper,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+                generalized=True,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
 
     @unpack
     @data(
         (
-            3,
-            (1, 1),
-            [
-                FermionicOp({"+_0 +_3 -_1 -_4": 1j, "+_4 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp(
-                    {
-                        "+_0 +_3 -_1 -_5": 1j,
-                        "+_5 +_1 -_3 -_0": -1j,
-                        "+_0 +_3 -_2 -_4": 1j,
-                        "+_4 +_2 -_3 -_0": -1j,
-                    },
-                    num_spin_orbitals=6,
-                ),
-                FermionicOp({"+_0 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
-            ],
-        ),
-    )
-    def test_succ_mirror(self, num_spatial_orbitals, num_particles, expect):
-        """Tests the `mirror` option of the SUCCD Ansatz."""
-        converter = QubitConverter(JordanWignerMapper())
-
-        ansatz = SUCCD(
-            qubit_converter=converter,
-            num_particles=num_particles,
-            num_spatial_orbitals=num_spatial_orbitals,
-            mirror=True,
-        )
-
-        assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
-
-    @unpack
-    @data(
-        (
-            3,
+            2,
             (1, 1),
-            (True, True),
             [
-                FermionicOp({"+_0 -_1": 1j, "+_1 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_0 -_2": 1j, "+_2 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_3 -_4": 1j, "+_4 -_3": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_3 -_5": 1j, "+_5 -_3": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_0 +_3 -_1 -_4": 1j, "+_4 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp(
-                    {
-                        "+_0 +_3 -_1 -_5": 1j,
-                        "+_5 +_1 -_3 -_0": -1j,
-                        "+_0 +_3 -_2 -_4": 1j,
-                        "+_4 +_2 -_3 -_0": -1j,
-                    },
-                    num_spin_orbitals=6,
-                ),
-                FermionicOp({"+_0 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_0 -_1": 1j, "+_1 -_0": -1j}, num_spin_orbitals=4),
+                FermionicOp({"+_0 -_3": 1j, "+_3 -_0": -1j}, num_spin_orbitals=4),
+                FermionicOp({"+_2 -_1": 1j, "+_1 -_2": -1j}, num_spin_orbitals=4),
+                FermionicOp({"+_2 -_3": 1j, "+_3 -_2": -1j}, num_spin_orbitals=4),
+                FermionicOp({"+_0 +_2 -_1 -_3": 1j, "+_3 +_1 -_2 -_0": -1j}, num_spin_orbitals=4),
             ],
         ),
         (
             3,
             (1, 1),
-            (True, False),
             [
                 FermionicOp({"+_0 -_1": 1j, "+_1 -_0": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_0 -_2": 1j, "+_2 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp({"+_0 +_3 -_1 -_4": 1j, "+_4 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp(
-                    {
-                        "+_0 +_3 -_1 -_5": 1j,
-                        "+_5 +_1 -_3 -_0": -1j,
-                        "+_0 +_3 -_2 -_4": 1j,
-                        "+_4 +_2 -_3 -_0": -1j,
-                    },
-                    num_spin_orbitals=6,
-                ),
-                FermionicOp({"+_0 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
-            ],
-        ),
-        (
-            3,
-            (1, 1),
-            (False, True),
-            [
+                FermionicOp({"+_0 -_4": 1j, "+_4 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_0 -_5": 1j, "+_5 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_3 -_1": 1j, "+_1 -_3": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_3 -_2": 1j, "+_2 -_3": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_3 -_4": 1j, "+_4 -_3": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_3 -_5": 1j, "+_5 -_3": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_0 +_3 -_1 -_2": 1j, "+_2 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_0 +_3 -_1 -_4": 1j, "+_4 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp(
-                    {
-                        "+_0 +_3 -_1 -_5": 1j,
-                        "+_5 +_1 -_3 -_0": -1j,
-                        "+_0 +_3 -_2 -_4": 1j,
-                        "+_4 +_2 -_3 -_0": -1j,
-                    },
-                    num_spin_orbitals=6,
-                ),
+                FermionicOp({"+_0 +_3 -_1 -_5": 1j, "+_5 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_0 +_3 -_2 -_4": 1j, "+_4 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
                 FermionicOp({"+_0 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
+                FermionicOp({"+_0 +_3 -_4 -_5": 1j, "+_5 +_4 -_3 -_0": -1j}, num_spin_orbitals=6),
             ],
         ),
     )
-    def test_succ_mirror_with_singles(
-        self, num_spatial_orbitals, num_particles, include_singles, expect
-    ):
-        """Tests the succ_mirror Ansatz with included single excitations."""
-        converter = QubitConverter(JordanWignerMapper())
-
-        ansatz = SUCCD(
-            qubit_converter=converter,
-            num_particles=num_particles,
-            num_spatial_orbitals=num_spatial_orbitals,
-            include_singles=include_singles,
-            mirror=True,
-        )
-
-        assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
-
-    @unpack
-    @data(
-        (
-            3,
-            (1, 1),
-            [
-                FermionicOp({"+_0 +_3 -_1 -_4": 1j, "+_4 +_1 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp(
-                    {
-                        "+_0 +_3 -_1 -_5": 1j,
-                        "+_5 +_1 -_3 -_0": -1j,
-                        "+_0 +_3 -_2 -_4": 1j,
-                        "+_4 +_2 -_3 -_0": -1j,
-                    },
-                    num_spin_orbitals=6,
-                ),
-                FermionicOp(
-                    {
-                        "+_0 +_4 -_1 -_5": 1j,
-                        "+_5 +_1 -_4 -_0": -1j,
-                        "+_1 +_3 -_2 -_4": 1j,
-                        "+_4 +_2 -_3 -_1": -1j,
-                    },
-                    num_spin_orbitals=6,
-                ),
-                FermionicOp({"+_0 +_3 -_2 -_5": 1j, "+_5 +_2 -_3 -_0": -1j}, num_spin_orbitals=6),
-                FermionicOp(
-                    {
-                        "+_0 +_4 -_2 -_5": 1j,
-                        "+_5 +_2 -_4 -_0": -1j,
-                        "+_1 +_3 -_2 -_5": 1j,
-                        "+_5 +_2 -_3 -_1": -1j,
-                    },
-                    num_spin_orbitals=6,
-                ),
-                FermionicOp({"+_1 +_4 -_2 -_5": 1j, "+_5 +_2 -_4 -_1": -1j}, num_spin_orbitals=6),
-            ],
-        )
-    )
-    def test_succ_mirror_ansatz_generalized(self, num_spatial_orbitals, num_particles, expect):
-        """Tests the generalized succ_mirror Ansatz."""
-        converter = QubitConverter(JordanWignerMapper())
-
-        ansatz = SUCCD(
-            qubit_converter=converter,
-            num_particles=num_particles,
-            num_spatial_orbitals=num_spatial_orbitals,
-            generalized=True,
-            mirror=True,
-        )
-
-        assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
+    def test_uccsd_ansatz_preserve_spin(self, num_spatial_orbitals, num_particles, expect):
+        """Tests UCCSD Ansatz with spin flips."""
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
+
+        with self.subTest("Qubit Converter object"):
+            ansatz = UCCSD(
+                qubit_mapper=converter,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+                preserve_spin=False,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
+
+        with self.subTest("Qubit Mapper object"):
+            ansatz = UCCSD(
+                qubit_mapper=mapper,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+                preserve_spin=False,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_ucc.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_ucc.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test the UCC Ansatz."""
 
 from test import QiskitNatureTestCase
 
 import unittest
+import warnings
 
 from ddt import data, ddt, unpack
 
 from qiskit import transpile
 from qiskit_nature import QiskitNatureError
 from qiskit_nature.second_q.circuit.library import UCC
 from qiskit_nature.second_q.mappers import QubitConverter
@@ -116,24 +117,34 @@
                 )
             ],
         ),
         # TODO: add more edge cases?
     )
     def test_ucc_ansatz(self, excitations, num_spatial_orbitals, num_particles, expect):
         """Tests the UCC Ansatz."""
-        converter = QubitConverter(JordanWignerMapper())
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
 
-        ansatz = UCC(
-            qubit_converter=converter,
-            num_particles=num_particles,
-            num_spatial_orbitals=num_spatial_orbitals,
-            excitations=excitations,
-        )
+        with self.subTest("Qubit Converter object"):
+            ansatz = UCC(
+                qubit_mapper=converter,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+                excitations=excitations,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
 
-        assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
+        with self.subTest("Qubit Mapper object"):
+            ansatz = UCC(
+                qubit_mapper=mapper,
+                num_particles=num_particles,
+                num_spatial_orbitals=num_spatial_orbitals,
+                excitations=excitations,
+            )
+            assert_ucc_like_ansatz(self, ansatz, num_spatial_orbitals, expect)
 
     @unpack
     @data(
         # Excitations not a list of pairs
         (
             4,
             (2, 2),
@@ -155,55 +166,74 @@
             4,
             (2, 2),
             [((0, 1, 1), (2, 3, 6))],
         ),
     )
     def test_custom_excitations(self, num_spatial_orbitals, num_particles, excitations):
         """Tests if an error is raised when the excitations have a wrong format"""
-        converter = QubitConverter(JordanWignerMapper())
+        mapper = QubitConverter(JordanWignerMapper())
 
         # pylint: disable=unused-argument
         def custom_excitations(num_spatial_orbitals, num_particles):
             return excitations
 
         with self.assertRaises(QiskitNatureError):
             ansatz = UCC(
-                qubit_converter=converter,
+                qubit_mapper=mapper,
                 num_particles=num_particles,
                 num_spatial_orbitals=num_spatial_orbitals,
                 excitations=custom_excitations,
             )
             ansatz.excitation_ops()
 
     def test_transpile_no_parameters(self):
         """Test transpilation without parameters"""
 
         num_spatial_orbitals = 4
         num_particles = (2, 2)
-        qubit_converter = QubitConverter(mapper=JordanWignerMapper())
 
-        ansatz = UCC(
-            num_spatial_orbitals=num_spatial_orbitals,
-            num_particles=num_particles,
-            qubit_converter=qubit_converter,
-            excitations="s",
-        )
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
+
+        with self.subTest("Qubit Converter object"):
+            ansatz = UCC(
+                num_spatial_orbitals=num_spatial_orbitals,
+                num_particles=num_particles,
+                qubit_mapper=converter,
+                excitations="s",
+            )
+
+            ansatz = transpile(ansatz, optimization_level=3)
+            self.assertEqual(ansatz.num_qubits, 8)
 
-        ansatz = transpile(ansatz, optimization_level=3)
-        self.assertEqual(ansatz.num_qubits, 8)
+        with self.subTest("Qubit Mapper object"):
+            ansatz = UCC(
+                num_spatial_orbitals=num_spatial_orbitals,
+                num_particles=num_particles,
+                qubit_mapper=mapper,
+                excitations="s",
+            )
+
+            ansatz = transpile(ansatz, optimization_level=3)
+            self.assertEqual(ansatz.num_qubits, 8)
 
     def test_build_ucc(self):
         """Test building UCC"""
         ucc = UCC()
 
         with self.subTest("Check defaulted construction"):
             self.assertIsNone(ucc.num_particles)
             self.assertIsNone(ucc.num_spatial_orbitals)
             self.assertIsNone(ucc.excitations)
-            self.assertIsNone(ucc.qubit_converter)
+            self.assertIsNone(ucc.qubit_mapper)
+
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore", category=DeprecationWarning)
+                self.assertIsNone(ucc.qubit_converter)
+
             self.assertIsNone(ucc.operators)
             self.assertIsNone(ucc.excitation_list)
             self.assertEqual(ucc.num_qubits, 0)
             with self.assertRaises(ValueError):
                 _ = ucc.data
 
         with self.subTest("Set num particles"):
@@ -224,17 +254,28 @@
             ucc.excitations = "sd"
             self.assertEqual(ucc.excitations, "sd")
             self.assertIsNone(ucc.operators)
             with self.assertRaises(ValueError):
                 _ = ucc.data
 
         with self.subTest("Set qubit converter to complete build"):
-            converter = QubitConverter(JordanWignerMapper())
-            ucc.qubit_converter = converter
-            self.assertEqual(ucc.qubit_converter, converter)
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore", category=DeprecationWarning)
+                converter = QubitConverter(JordanWignerMapper())
+                ucc.qubit_converter = converter
+                self.assertEqual(ucc.qubit_converter, converter)
+            self.assertIsNotNone(ucc.operators)
+            self.assertEqual(len(ucc.operators), 3)
+            self.assertEqual(ucc.num_qubits, 4)
+            self.assertIsNotNone(ucc.data)
+
+        with self.subTest("Set qubit mapper to complete build"):
+            mapper = JordanWignerMapper()
+            ucc.qubit_mapper = mapper
+            self.assertEqual(ucc.qubit_mapper, mapper)
             self.assertIsNotNone(ucc.operators)
             self.assertEqual(len(ucc.operators), 3)
             self.assertEqual(ucc.num_qubits, 4)
             self.assertIsNotNone(ucc.data)
 
         with self.subTest("Set custom operators"):
             self.assertEqual(len(ucc.operators), 3)
@@ -266,16 +307,24 @@
 
         with self.subTest("Change excitations"):
             ucc.excitations = "s"
             self.assertIsNotNone(ucc.operators)
             self.assertEqual(len(ucc.operators), 4)
 
         with self.subTest("Change qubit converter"):
-            ucc.qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)
+            ucc.qubit_mapper = QubitConverter(ParityMapper(), two_qubit_reduction=True)
             # Has not been used to convert so we need to force it to do two qubit reduction
-            ucc.qubit_converter.force_match(num_particles=ucc.num_particles)
+            ucc.qubit_mapper.force_match(num_particles=ucc.num_particles)
             self.assertIsNotNone(ucc.operators)
             self.assertEqual(ucc.num_qubits, 4)
 
+        with self.subTest("Change qubit converter to qubit mapper"):
+            mapper = ParityMapper()
+            ucc.qubit_mapper = mapper
+            self.assertIsNotNone(ucc.operators)
+            self.assertEqual(ucc.qubit_mapper, mapper)
+            self.assertEqual(ucc.num_qubits, 6)
+            # TODO: PR #1018 Add test with parity mapper and two qubit reduction
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/test_uvcc.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/test_uvcc.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -56,28 +56,40 @@
                 VibrationalOp({"+_0_0 -_0_1": 1j, "+_0_1 -_0_0": -1j}, [2, 2]),
                 VibrationalOp({"+_1_0 -_1_1": 1j, "+_1_1 -_1_0": -1j}, [2, 2]),
             ],
         ),
     )
     def test_ucc_ansatz(self, excitations, num_modals, expect):
         """Tests the UVCC Ansatz."""
-        converter = QubitConverter(DirectMapper())
+        mapper = DirectMapper()
+        converter = QubitConverter(mapper)
 
-        ansatz = UVCC(qubit_converter=converter, num_modals=num_modals, excitations=excitations)
-
-        assert_ucc_like_ansatz(self, ansatz, num_modals, expect)
+        with self.subTest("Qubit Converter object"):
+            ansatz = UVCC(qubit_mapper=converter, num_modals=num_modals, excitations=excitations)
+            assert_ucc_like_ansatz(self, ansatz, num_modals, expect)
+
+        with self.subTest("Qubit Mapper object"):
+            ansatz = UVCC(qubit_mapper=mapper, num_modals=num_modals, excitations=excitations)
+            assert_ucc_like_ansatz(self, ansatz, num_modals, expect)
 
     def test_transpile_no_parameters(self):
         """Test transpilation without parameters"""
 
-        qubit_converter = QubitConverter(mapper=DirectMapper())
+        mapper = DirectMapper()
+        converter = QubitConverter(mapper)
 
-        ansatz = UVCC(qubit_converter=qubit_converter, num_modals=[2], excitations="s")
-        ansatz = transpile(ansatz, optimization_level=3)
-        self.assertEqual(ansatz.num_qubits, 2)
+        with self.subTest("Qubit Converter object"):
+            ansatz = UVCC(qubit_mapper=converter, num_modals=[2], excitations="s")
+            ansatz = transpile(ansatz, optimization_level=3)
+            self.assertEqual(ansatz.num_qubits, 2)
+
+        with self.subTest("Qubit Mapper object"):
+            ansatz = UVCC(qubit_mapper=mapper, num_modals=[2], excitations="s")
+            ansatz = transpile(ansatz, optimization_level=3)
+            self.assertEqual(ansatz.num_qubits, 2)
 
 
 class TestUVCCVSCF(QiskitNatureTestCase):
     """Test for these extensions."""
 
     def setUp(self):
         super().setUp()
@@ -113,40 +125,44 @@
                 [[[0, 1, 1], [1, 1, 1]], -179.0536532281924],
             ],
         ]
         num_modals = [2, 2]
 
         vibrational_op_labels = _create_labels(co2_2modes_2modals_2body)
         vibr_op = VibrationalOp(vibrational_op_labels, num_modals)
-
-        converter = QubitConverter(DirectMapper())
-
-        qubit_op = converter.convert_match(vibr_op)
-
         init_state = VSCF(num_modals)
+        mapper = DirectMapper()
+        converter = QubitConverter(mapper)
 
-        uvcc_ansatz = UVCC(num_modals, "sd", converter, initial_state=init_state)
-
-        optimizer = COBYLA(maxiter=1000)
-
-        algo = VQE(Estimator(), uvcc_ansatz, optimizer)
-        vqe_result = algo.compute_minimum_eigenvalue(qubit_op)
-
-        energy = vqe_result.optimal_value
-
-        self.assertAlmostEqual(energy, self.reference_energy, places=4)
+        with self.subTest("Qubit Converter object"):
+            qubit_op = converter.convert_match(vibr_op)
+            uvcc_ansatz = UVCC(num_modals, "sd", converter, initial_state=init_state)
+            optimizer = COBYLA(maxiter=1000)
+            algo = VQE(Estimator(), uvcc_ansatz, optimizer)
+            vqe_result = algo.compute_minimum_eigenvalue(qubit_op)
+            energy = vqe_result.optimal_value
+            self.assertAlmostEqual(energy, self.reference_energy, places=4)
+
+        with self.subTest("Qubit Mapper object"):
+            qubit_op = mapper.map(vibr_op)
+            uvcc_ansatz = UVCC(num_modals, "sd", mapper, initial_state=init_state)
+            optimizer = COBYLA(maxiter=1000)
+            algo = VQE(Estimator(), uvcc_ansatz, optimizer)
+            vqe_result = algo.compute_minimum_eigenvalue(qubit_op)
+            energy = vqe_result.optimal_value
+            self.assertAlmostEqual(energy, self.reference_energy, places=4)
 
     def test_build_uvcc(self):
         """Test building UVCC"""
         uvcc = UVCC()
 
         with self.subTest("Check defaulted construction"):
             self.assertIsNone(uvcc.num_modals)
             self.assertIsNone(uvcc.excitations)
-            self.assertIsNone(uvcc.qubit_converter)
+            self.assertIsNone(uvcc.qubit_mapper)
             self.assertIsNone(uvcc.operators)
             self.assertIsNone(uvcc.excitation_list)
             self.assertEqual(uvcc.num_qubits, 0)
             with self.assertRaises(ValueError):
                 _ = uvcc.data
 
         with self.subTest("Set num modals"):
@@ -161,16 +177,16 @@
             self.assertEqual(uvcc.excitations, "sd")
             self.assertIsNone(uvcc.operators)
             with self.assertRaises(ValueError):
                 _ = uvcc.data
 
         with self.subTest("Set qubit converter to complete build"):
             converter = QubitConverter(DirectMapper())
-            uvcc.qubit_converter = converter
-            self.assertEqual(uvcc.qubit_converter, converter)
+            uvcc.qubit_mapper = converter
+            self.assertEqual(uvcc.qubit_mapper, converter)
             self.assertIsNotNone(uvcc.operators)
             self.assertEqual(len(uvcc.operators), 3)
             self.assertEqual(uvcc.num_qubits, 4)
             self.assertIsNotNone(uvcc.data)
 
         with self.subTest("Set custom operators"):
             self.assertEqual(len(uvcc.operators), 3)
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/utils/test_fermionic_excitation_generator.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -25,32 +25,50 @@
 class TestFermionicExcitationGenerator(QiskitNatureTestCase):
     """Tests for the default fermionic excitation generator method."""
 
     @unpack
     @data(
         (1, 2, [1, 1], [((0,), (1,)), ((2,), (3,))]),
         (1, 2, [2, 2], []),
+        (1, 2, [1, 0], [((0,), (1,))]),
+        (1, 2, [2, 0], []),
+        (1, 2, [2, 1], [((2,), (3,))]),
+        (1, 2, [0, 1], [((2,), (3,))]),
+        (1, 2, [0, 2], []),
+        (1, 2, [1, 2], [((0,), (1,))]),
         (1, 3, [1, 1], [((0,), (1,)), ((0,), (2,)), ((3,), (4,)), ((3,), (5,))]),
         (1, 3, [2, 2], [((0,), (2,)), ((1,), (2,)), ((3,), (5,)), ((4,), (5,))]),
         (1, 3, [3, 3], []),
+        (1, 3, [2, 0], [((0,), (2,)), ((1,), (2,))]),
+        (1, 3, [2, 1], [((0,), (2,)), ((1,), (2,)), ((3,), (4,)), ((3,), (5,))]),
+        (1, 3, [0, 2], [((3,), (5,)), ((4,), (5,))]),
+        (1, 3, [1, 2], [((0,), (1,)), ((0,), (2,)), ((3,), (5,)), ((4,), (5,))]),
         (2, 2, [1, 1], [((0, 2), (1, 3))]),
         (2, 2, [2, 2], []),
+        (2, 2, [1, 0], []),
+        (2, 2, [2, 0], []),
+        (2, 2, [2, 1], []),
+        (2, 2, [0, 1], []),
+        (2, 2, [0, 2], []),
+        (2, 2, [1, 2], []),
         (
             2,
             3,
             [1, 1],
             [((0, 3), (1, 4)), ((0, 3), (1, 5)), ((0, 3), (2, 4)), ((0, 3), (2, 5))],
         ),
         (
             2,
             3,
             [2, 2],
             [((0, 3), (2, 5)), ((0, 4), (2, 5)), ((1, 3), (2, 5)), ((1, 4), (2, 5))],
         ),
         (2, 3, [3, 3], []),
+        (2, 3, [2, 1], [((0, 3), (2, 4)), ((0, 3), (2, 5)), ((1, 3), (2, 4)), ((1, 3), (2, 5))]),
+        (2, 3, [1, 2], [((0, 3), (1, 5)), ((0, 4), (1, 5)), ((0, 3), (2, 5)), ((0, 4), (2, 5))]),
         (
             2,
             4,
             [2, 2],
             [
                 ((0, 1), (2, 3)),
                 ((0, 4), (2, 6)),
@@ -96,14 +114,16 @@
         (
             2,
             3,
             [1, 1],
             1,
             [((0, 3), (1, 4)), ((0, 3), (1, 5)), ((0, 3), (2, 4)), ((0, 3), (2, 5))],
         ),
+        (2, 3, [2, 1], 1, [((0, 3), (2, 4)), ((0, 3), (2, 5)), ((1, 3), (2, 4)), ((1, 3), (2, 5))]),
+        (2, 3, [1, 2], 1, [((0, 3), (1, 5)), ((0, 4), (1, 5)), ((0, 3), (2, 5)), ((0, 4), (2, 5))]),
         (
             2,
             4,
             [2, 2],
             1,
             [
                 ((0, 4), (2, 6)),
@@ -138,14 +158,16 @@
         self.assertEqual(excitations, expect)
 
     @unpack
     @data(
         (1, 2, [1, 1], [((0,), (1,))]),
         (1, 3, [1, 1], [((0,), (1,)), ((0,), (2,))]),
         (2, 4, [2, 2], [((0, 1), (2, 3))]),
+        (2, 4, [2, 1], [((0, 1), (2, 3))]),
+        (2, 4, [1, 2], []),
     )
     def test_pure_alpha_excitation(
         self, num_excitations, num_spatial_orbitals, num_particles, expect
     ):
         """Test disabling beta-spin excitations."""
         excitations = generate_fermionic_excitations(
             num_excitations, num_spatial_orbitals, num_particles, beta_spin=False
@@ -153,14 +175,16 @@
         self.assertEqual(excitations, expect)
 
     @unpack
     @data(
         (1, 2, [1, 1], [((2,), (3,))]),
         (1, 3, [1, 1], [((3,), (4,)), ((3,), (5,))]),
         (2, 4, [2, 2], [((4, 5), (6, 7))]),
+        (2, 4, [2, 1], []),
+        (2, 4, [1, 2], [((4, 5), (6, 7))]),
     )
     def test_pure_beta_excitation(
         self, num_excitations, num_spatial_orbitals, num_particles, expect
     ):
         """Test disabling alpha-spin excitations."""
         excitations = generate_fermionic_excitations(
             num_excitations, num_spatial_orbitals, num_particles, alpha_spin=False
@@ -168,42 +192,79 @@
         self.assertEqual(excitations, expect)
 
     @unpack
     @data(
         (1, 2, [0, 0], [((0,), (1,)), ((2,), (3,))]),
         (1, 2, [1, 0], [((0,), (1,)), ((2,), (3,))]),
         (1, 2, [1, 1], [((0,), (1,)), ((2,), (3,))]),
+        (1, 2, [2, 2], [((0,), (1,)), ((2,), (3,))]),
         (2, 2, [0, 0], [((0, 2), (1, 3))]),
+        (2, 2, [2, 1], [((0, 2), (1, 3))]),
+        (2, 2, [1, 2], [((0, 2), (1, 3))]),
     )
     def test_generalized_excitations(
         self, num_excitations, num_spatial_orbitals, num_particles, expect
     ):
         """Test generalized excitations."""
         excitations = generate_fermionic_excitations(
             num_excitations, num_spatial_orbitals, num_particles, generalized=True
         )
         self.assertEqual(excitations, expect)
 
     @unpack
     @data(
         (1, 2, [1, 1], [((0,), (1,)), ((0,), (3,)), ((2,), (1,)), ((2,), (3,))]),
+        (1, 2, [2, 1], [((0,), (3,)), ((1,), (3,)), ((2,), (3,))]),
+        (1, 2, [1, 2], [((0,), (1,)), ((2,), (1,)), ((3,), (1,))]),
         (2, 2, [1, 1], [((0, 2), (1, 3))]),
         (
             2,
             3,
             [1, 1],
             [
                 ((0, 3), (1, 2)),
                 ((0, 3), (1, 4)),
                 ((0, 3), (1, 5)),
                 ((0, 3), (2, 4)),
                 ((0, 3), (2, 5)),
                 ((0, 3), (4, 5)),
             ],
         ),
+        (
+            2,
+            3,
+            [2, 1],
+            [
+                ((0, 1), (2, 4)),
+                ((0, 1), (2, 5)),
+                ((0, 3), (2, 4)),
+                ((0, 3), (2, 5)),
+                ((0, 1), (4, 5)),
+                ((0, 3), (4, 5)),
+                ((1, 3), (2, 4)),
+                ((1, 3), (2, 5)),
+                ((1, 3), (4, 5)),
+            ],
+        ),
+        (
+            2,
+            3,
+            [1, 2],
+            [
+                ((0, 3), (1, 2)),
+                ((0, 3), (1, 5)),
+                ((0, 4), (1, 2)),
+                ((0, 4), (1, 5)),
+                ((0, 3), (2, 5)),
+                ((0, 4), (2, 5)),
+                ((3, 4), (1, 2)),
+                ((3, 4), (1, 5)),
+                ((3, 4), (2, 5)),
+            ],
+        ),
     )
     def test_preserve_spin_excitations(
         self, num_excitations, num_spatial_orbitals, num_particles, expect
     ):
         """Test allowing spin-flipped excitations."""
         excitations = generate_fermionic_excitations(
             num_excitations, num_spatial_orbitals, num_particles, preserve_spin=False
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/utils/test_vibration_excitation_generator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/ansatzes/utils/vibrational_op_label_creator.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/ansatzes/utils/vibrational_op_label_creator.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/test_fermionic_gaussian_state.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_fermionic_gaussian_state.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,67 +1,78 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test fermionic Gaussian state preparation circuits."""
 
 from test import QiskitNatureTestCase
-from test.nature_random import random_quadratic_hamiltonian
 
 import numpy as np
 from qiskit.quantum_info import Statevector
 
 from qiskit_nature.second_q.circuit.library import FermionicGaussianState
-from qiskit_nature.second_q.mappers import QubitConverter
-from qiskit_nature.second_q.mappers import (
-    BravyiKitaevMapper,
-    JordanWignerMapper,
-)
+from qiskit_nature.second_q.mappers import BravyiKitaevMapper, JordanWignerMapper, QubitConverter
+from qiskit_nature.testing import random_quadratic_hamiltonian
 
 
 class TestFermionicGaussianState(QiskitNatureTestCase):
     """Tests for preparing fermionic Gaussian states determinants."""
 
     def test_fermionic_gaussian_state(self):
         """Test preparing fermionic Gaussian states."""
         n_orbitals = 5
-        converter = QubitConverter(JordanWignerMapper())
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
+
         quad_ham = random_quadratic_hamiltonian(n_orbitals, seed=5957)
         (
             transformation_matrix,
             orbital_energies,
             transformed_constant,
         ) = quad_ham.diagonalizing_bogoliubov_transform()
         fermionic_op = quad_ham.second_q_op()
-        qubit_op = converter.convert(fermionic_op)
-        matrix = qubit_op.to_matrix()
         occupied_orbitals_lists = [
             [],
             [0],
             [3],
             [0, 1],
             [2, 4],
             [1, 3, 4],
             range(n_orbitals),
         ]
-        for occupied_orbitals in occupied_orbitals_lists:
-            circuit = FermionicGaussianState(
-                transformation_matrix, occupied_orbitals, qubit_converter=converter
-            )
-            final_state = np.array(Statevector(circuit))
-            eig = np.sum(orbital_energies[occupied_orbitals]) + transformed_constant
-            np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-7)
+
+        with self.subTest("Qubit Converter object"):
+            qubit_op = converter.convert(fermionic_op)
+            matrix = qubit_op.to_matrix()
+            for occupied_orbitals in occupied_orbitals_lists:
+                circuit = FermionicGaussianState(
+                    transformation_matrix, occupied_orbitals, qubit_mapper=converter
+                )
+                final_state = np.array(Statevector(circuit))
+                eig = np.sum(orbital_energies[occupied_orbitals]) + transformed_constant
+                np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-7)
+
+        with self.subTest("Qubit Mapper object"):
+            qubit_op = mapper.map(fermionic_op)
+            matrix = qubit_op.to_matrix()
+            for occupied_orbitals in occupied_orbitals_lists:
+                circuit = FermionicGaussianState(
+                    transformation_matrix, occupied_orbitals, qubit_mapper=mapper
+                )
+                final_state = np.array(Statevector(circuit))
+                eig = np.sum(orbital_energies[occupied_orbitals]) + transformed_constant
+                np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-7)
 
     def test_no_side_effects(self):
         """Test that the routines don't mutate the input array."""
         n_orbitals = 5
         quad_ham = random_quadratic_hamiltonian(n_orbitals, seed=8353)
         transformation_matrix, _, _ = quad_ham.diagonalizing_bogoliubov_transform()
         original = transformation_matrix.copy()
@@ -85,9 +96,17 @@
         assert circuit.name == "efgh"
 
     def test_unsupported_mapper(self):
         """Test passing unsupported mapper fails gracefully."""
         with self.assertRaisesRegex(NotImplementedError, "supported"):
             _ = FermionicGaussianState(
                 np.block([np.eye(2), np.zeros((2, 2))]),
-                qubit_converter=QubitConverter(BravyiKitaevMapper()),
+                qubit_mapper=QubitConverter(BravyiKitaevMapper()),
+            )
+
+    def test_unsupported_mapper_no_converter(self):
+        """Test passing unsupported mapper fails gracefully when bypassing the qubit converter."""
+        with self.assertRaisesRegex(NotImplementedError, "supported"):
+            _ = FermionicGaussianState(
+                np.block([np.eye(2), np.zeros((2, 2))]),
+                qubit_mapper=BravyiKitaevMapper(),
             )
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/test_hartree_fock.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_hartree_fock.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test Hartree Fock initial state circuit."""
 
 import unittest
+import warnings
 from test import QiskitNatureTestCase
 import numpy as np
 
 from qiskit import QuantumCircuit
 from qiskit.opflow.primitive_ops.tapered_pauli_sum_op import Z2Symmetries
 from qiskit.quantum_info.operators.symplectic import Pauli
 from qiskit_nature.second_q.circuit.library import HartreeFock
@@ -51,33 +52,38 @@
         with self.subTest("too few orbitals"):
             with self.assertRaises(ValueError):
                 _ = hartree_fock_bitstring(-1, (2, 2))
 
     def test_raises_on_unsupported_mapper(self):
         """Test if an error is raised for an unsupported mapper."""
         with self.assertRaises(NotImplementedError):
-            converter = QubitConverter(BravyiKitaevSuperFastMapper())
-            state = HartreeFock(
-                num_spatial_orbitals=2, num_particles=(1, 1), qubit_converter=converter
-            )
+            mapper = QubitConverter(BravyiKitaevSuperFastMapper())
+            state = HartreeFock(num_spatial_orbitals=2, num_particles=(1, 1), qubit_mapper=mapper)
+            state.draw()
+
+    def test_raises_on_unsupported_mapper_no_mapper(self):
+        """Test if an error is raised for an unsupported mapper."""
+        with self.assertRaises(NotImplementedError):
+            mapper = BravyiKitaevSuperFastMapper()
+            state = HartreeFock(num_spatial_orbitals=2, num_particles=(1, 1), qubit_mapper=mapper)
             state.draw()
 
     def test_qubits_4_jw_h2(self):
         """qubits 4 jw h2 test"""
         state = HartreeFock(2, (1, 1), QubitConverter(JordanWignerMapper()))
         ref = QuantumCircuit(4)
         ref.x([0, 2])
         self.assertEqual(state, ref)
 
     def test_qubits_4_jw_h2_lazy_attribute_setting(self):
         """qubits 4 jw h2 with lazy attribute setting test"""
         state = HartreeFock()
         state.num_spatial_orbitals = 2
         state.num_particles = (1, 1)
-        state.qubit_converter = QubitConverter(JordanWignerMapper())
+        state.qubit_mapper = QubitConverter(JordanWignerMapper())
         ref = QuantumCircuit(4)
         ref.x([0, 2])
         self.assertEqual(state, ref)
 
     def test_qubits_4_py_h2(self):
         """qubits 4 py h2 test"""
         state = HartreeFock(2, (1, 1), QubitConverter(ParityMapper()))
@@ -91,33 +97,33 @@
         ref = QuantumCircuit(4)
         ref.x([0, 1, 2])
         self.assertEqual(state, ref)
 
     def test_qubits_2_py_h2(self):
         """qubits 2 py h2 test"""
         num_particles = (1, 1)
-        converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)
-        converter.force_match(num_particles=num_particles)
-        state = HartreeFock(2, num_particles, converter)
+        mapper = QubitConverter(ParityMapper(), two_qubit_reduction=True)
+        mapper.force_match(num_particles=num_particles)
+        state = HartreeFock(2, num_particles, mapper)
         ref = QuantumCircuit(2)
         ref.x(0)
         self.assertEqual(state, ref)
 
     def test_qubits_6_py_lih(self):
         """qubits 6 py lih test"""
         num_particles = (1, 1)
-        converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)
+        mapper = QubitConverter(ParityMapper(), two_qubit_reduction=True)
         z2symmetries = Z2Symmetries(
             symmetries=[Pauli("ZIZIZIZI"), Pauli("ZZIIZZII")],
             sq_paulis=[Pauli("IIIIIIXI"), Pauli("IIIIIXII")],
             sq_list=[2, 3],
             tapering_values=[1, 1],
         )
-        converter.force_match(num_particles=num_particles, z2symmetries=z2symmetries)
-        state = HartreeFock(5, num_particles, converter)
+        mapper.force_match(num_particles=num_particles, z2symmetries=z2symmetries)
+        state = HartreeFock(5, num_particles, mapper)
         ref = QuantumCircuit(6)
         ref.x([0, 1])
         self.assertEqual(state, ref)
 
     def test_hf_bitstring_mapped(self):
         """Mapped bitstring test for water"""
         # Original driver config when creating operator that resulted in symmetries coded
@@ -127,37 +133,39 @@
         #    unit=DistanceUnit.ANGSTROM,
         #    charge=0,
         #    spin=0,
         #    basis='sto-3g',
         #    hf_method=HFMethodType.RHF)
         num_spatial_orbitals = 7
         num_particles = (5, 5)
-        converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)
+        mapper = QubitConverter(ParityMapper(), two_qubit_reduction=True)
         z2symmetries = Z2Symmetries(
             symmetries=[Pauli("IZZIIIIZZIII"), Pauli("ZZIZIIZZIZII")],
             sq_paulis=[Pauli("IIIIIIIIXIII"), Pauli("IIIIIIIIIXII")],
             sq_list=[3, 2],
             tapering_values=[1, -1],
         )
         with self.subTest("Matched bitsring creation"):
-            converter.force_match(num_particles=num_particles, z2symmetries=z2symmetries)
+            mapper.force_match(num_particles=num_particles, z2symmetries=z2symmetries)
             bitstr = hartree_fock_bitstring_mapped(
                 num_spatial_orbitals=num_spatial_orbitals,
                 num_particles=num_particles,
-                qubit_converter=converter,
+                qubit_mapper=mapper,
             )
             ref_matched = [True, False, True, True, False, True, False, True, False, False]
             self.assertListEqual(bitstr, ref_matched)
         with self.subTest("Bitsring creation with no tapering"):
-            bitstr = hartree_fock_bitstring_mapped(
-                num_spatial_orbitals=num_spatial_orbitals,
-                num_particles=num_particles,
-                qubit_converter=converter,
-                match_convert=False,
-            )
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore", category=DeprecationWarning)
+                bitstr = hartree_fock_bitstring_mapped(
+                    num_spatial_orbitals=num_spatial_orbitals,
+                    num_particles=num_particles,
+                    qubit_mapper=mapper,
+                    match_convert=False,
+                )
             ref_notaper = [
                 True,
                 False,
                 True,
                 False,
                 True,
                 True,
@@ -166,10 +174,60 @@
                 False,
                 True,
                 False,
                 False,
             ]
             self.assertListEqual(bitstr, ref_notaper)
 
+    def test_hf_bitstring_mapped_with_qubitmapper(self):
+        """Mapped bitstring test for water with qubit mapper"""
+
+        num_spatial_orbitals = 7
+        num_particles = (5, 5)
+
+        ref_notaper_no_red = [
+            True,
+            False,
+            True,
+            False,
+            True,
+            True,
+            True,
+            False,
+            True,
+            False,
+            True,
+            False,
+            False,
+            False,
+        ]
+
+        with self.subTest("Qubit Converter object"):
+            mapper = QubitConverter(ParityMapper())
+            bitstr = hartree_fock_bitstring_mapped(
+                num_spatial_orbitals=num_spatial_orbitals,
+                num_particles=num_particles,
+                qubit_mapper=mapper,
+            )
+            self.assertListEqual(bitstr, ref_notaper_no_red)
+
+        with self.subTest("Qubit Mapper object"):
+            mapper = ParityMapper()
+            bitstr = hartree_fock_bitstring_mapped(
+                num_spatial_orbitals=num_spatial_orbitals,
+                num_particles=num_particles,
+                qubit_mapper=mapper,
+            )
+            self.assertListEqual(bitstr, ref_notaper_no_red)
+
+        with self.subTest("ParityMapper with builtin two-qubit reduction"):
+            mapper = ParityMapper(num_particles=num_particles)
+            bitstr = hartree_fock_bitstring_mapped(
+                num_spatial_orbitals=num_spatial_orbitals,
+                num_particles=num_particles,
+                qubit_mapper=mapper,
+            )
+            self.assertListEqual(bitstr, ref_notaper_no_red[:5] + ref_notaper_no_red[6:-1])
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/test_slater_determinant.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_slater_determinant.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,58 +1,68 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test Slater determinant state preparation circuits."""
 
 from test import QiskitNatureTestCase
-from test.nature_random import random_quadratic_hamiltonian
 
 import numpy as np
 from qiskit.quantum_info import Statevector
 
 from qiskit_nature.second_q.circuit.library import SlaterDeterminant
-from qiskit_nature.second_q.mappers import QubitConverter
-from qiskit_nature.second_q.mappers import (
-    BravyiKitaevMapper,
-    JordanWignerMapper,
-)
+from qiskit_nature.second_q.mappers import BravyiKitaevMapper, JordanWignerMapper, QubitConverter
+from qiskit_nature.testing import random_quadratic_hamiltonian
 
 
 class TestSlaterDeterminant(QiskitNatureTestCase):
     """Tests for preparing Slater determinants."""
 
     def test_slater_determinant(self):
         """Test preparing Slater determinants."""
         n_orbitals = 5
-        converter = QubitConverter(JordanWignerMapper())
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
         quad_ham = random_quadratic_hamiltonian(n_orbitals, num_conserving=True, seed=8839)
         (
             transformation_matrix,
             orbital_energies,
             transformed_constant,
         ) = quad_ham.diagonalizing_bogoliubov_transform()
         fermionic_op = quad_ham.second_q_op()
-        qubit_op = converter.convert(fermionic_op)
-        matrix = qubit_op.to_matrix()
-        for n_particles in range(n_orbitals + 1):
-            circuit = SlaterDeterminant(
-                transformation_matrix[:n_particles], qubit_converter=converter
-            )
-            final_state = np.array(Statevector(circuit))
-            eig = np.sum(orbital_energies[:n_particles]) + transformed_constant
-            np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-7)
+
+        with self.subTest("Qubit Converter object"):
+            qubit_op = converter.convert(fermionic_op)
+            matrix = qubit_op.to_matrix()
+            for n_particles in range(n_orbitals + 1):
+                circuit = SlaterDeterminant(
+                    transformation_matrix[:n_particles], qubit_mapper=converter
+                )
+                final_state = np.array(Statevector(circuit))
+                eig = np.sum(orbital_energies[:n_particles]) + transformed_constant
+                np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-7)
+
+        with self.subTest("Qubit Mapper object"):
+            qubit_op = mapper.map(fermionic_op)
+            matrix = qubit_op.to_matrix()
+            for n_particles in range(n_orbitals + 1):
+                circuit = SlaterDeterminant(
+                    transformation_matrix[:n_particles], qubit_mapper=mapper
+                )
+                final_state = np.array(Statevector(circuit))
+                eig = np.sum(orbital_energies[:n_particles]) + transformed_constant
+                np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-7)
 
     def test_no_side_effects(self):
         """Test that the routines don't mutate the input array."""
         n_orbitals = 5
         n_particles = 3
         quad_ham = random_quadratic_hamiltonian(n_orbitals, num_conserving=True, seed=8839)
         transformation_matrix, _, _ = quad_ham.diagonalizing_bogoliubov_transform()
@@ -73,8 +83,13 @@
         """Test that circuit keyword arguments are actually passed through."""
         circuit = SlaterDeterminant(np.eye(2), name="abcd")
         assert circuit.name == "abcd"
 
     def test_unsupported_mapper(self):
         """Test passing unsupported mapper fails gracefully."""
         with self.assertRaisesRegex(NotImplementedError, "supported"):
-            _ = SlaterDeterminant(np.eye(2), qubit_converter=QubitConverter(BravyiKitaevMapper()))
+            _ = SlaterDeterminant(np.eye(2), qubit_mapper=QubitConverter(BravyiKitaevMapper()))
+
+    def test_unsupported_mapper_no_converter(self):
+        """Test passing unsupported mapper fails gracefully when bypassing the qubit converter."""
+        with self.assertRaisesRegex(NotImplementedError, "supported"):
+            _ = SlaterDeterminant(np.eye(2), qubit_mapper=BravyiKitaevMapper())
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/initial_states/test_vscf.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/initial_states/test_vscf.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -15,16 +15,15 @@
 import unittest
 from test import QiskitNatureTestCase
 import numpy as np
 
 from qiskit import QuantumCircuit
 from qiskit_nature.second_q.circuit.library import VSCF
 from qiskit_nature.second_q.circuit.library.initial_states.vscf import vscf_bitstring
-from qiskit_nature.second_q.mappers import ParityMapper
-from qiskit_nature.second_q.mappers import QubitConverter
+from qiskit_nature.second_q.mappers import DirectMapper, TaperedQubitMapper, QubitConverter
 
 
 class TestVSCF(QiskitNatureTestCase):
     """Initial State vscf tests"""
 
     def test_bitstring(self):
         """Test the vscf_bitstring method."""
@@ -49,18 +48,44 @@
 
         self.assertEqual(ref, vscf)
 
     def test_qubits_6_lazy_attribute_setting(self):
         """Test 2 modes 2 modal for the first mode and 4 modals for the second
         with lazy attribute setting."""
         num_modals = [2, 4]
-        qubit_converter = QubitConverter(ParityMapper())
+        mapper = QubitConverter(DirectMapper())
         vscf = VSCF()
         vscf.num_modals = num_modals
-        vscf.qubit_converter = qubit_converter
+        vscf.qubit_mapper = mapper
+        ref = QuantumCircuit(6)
+        ref.x([0, 2])
+
+        self.assertEqual(ref, vscf)
+
+    def test_qubits_6_lazy_attribute_setting_no_converter(self):
+        """Test 2 modes 2 modal for the first mode and 4 modals for the second
+        with lazy attribute setting when bypassing the Qubit converter."""
+        num_modals = [2, 4]
+        mapper = DirectMapper()
+        vscf = VSCF()
+        vscf.num_modals = num_modals
+        vscf.qubit_mapper = mapper
+        ref = QuantumCircuit(6)
+        ref.x([0, 2])
+
+        self.assertEqual(ref, vscf)
+
+    def test_qubits_6_lazy_attribute_setting_taperedmapper(self):
+        """Test 2 modes 2 modal for the first mode and 4 modals for the second
+        with lazy attribute setting and the Tapered Qubit."""
+        num_modals = [2, 4]
+        mapper = TaperedQubitMapper(DirectMapper())
+        vscf = VSCF()
+        vscf.num_modals = num_modals
+        vscf.qubit_mapper = mapper
         ref = QuantumCircuit(6)
         ref.x([0, 2])
 
         self.assertEqual(ref, vscf)
 
 
 if __name__ == "__main__":
```

### Comparing `qiskit-nature-0.5.2/test/second_q/circuit/library/test_bogoliubov_transform.py` & `qiskit-nature-0.6.0/test/second_q/circuit/library/test_bogoliubov_transform.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,38 +1,32 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test Bogoliubov transform circuits."""
 
 from test import QiskitNatureTestCase
-from test.nature_random import random_quadratic_hamiltonian
 
 import numpy as np
 from ddt import data, ddt, unpack
 from qiskit import QuantumCircuit, QuantumRegister
 from qiskit.quantum_info import Operator, Statevector, random_hermitian, random_unitary
 
 from qiskit_nature.second_q.circuit.library import BogoliubovTransform
-from qiskit_nature.second_q.mappers import QubitConverter
-from qiskit_nature.second_q.mappers import (
-    BravyiKitaevMapper,
-    JordanWignerMapper,
-)
-from qiskit_nature.second_q.hamiltonians.quadratic_hamiltonian import (
-    QuadraticHamiltonian,
-)
+from qiskit_nature.second_q.hamiltonians.quadratic_hamiltonian import QuadraticHamiltonian
+from qiskit_nature.second_q.mappers import BravyiKitaevMapper, JordanWignerMapper, QubitConverter
+from qiskit_nature.testing import random_quadratic_hamiltonian
 
 
 def _expand_transformation_matrix(mat: np.ndarray) -> np.ndarray:
     n, _ = mat.shape
     left = mat[:, :n]
     right = mat[:, n:]
     return np.block([[left, right], [right.conj(), left.conj()]])
@@ -42,31 +36,44 @@
 class TestBogoliubovTransform(QiskitNatureTestCase):
     """Tests for BogoliubovTransform."""
 
     @unpack
     @data((4, True), (5, True), (4, False), (5, False))
     def test_bogoliubov_transform(self, n_orbitals, num_conserving):
         """Test Bogoliubov transform."""
-        converter = QubitConverter(JordanWignerMapper())
+        mapper = JordanWignerMapper()
+        converter = QubitConverter(mapper)
         hamiltonian = random_quadratic_hamiltonian(
             n_orbitals, num_conserving=num_conserving, seed=5740
         )
         (
             transformation_matrix,
             orbital_energies,
             transformed_constant,
         ) = hamiltonian.diagonalizing_bogoliubov_transform()
-        matrix = converter.map(hamiltonian.second_q_op()).to_matrix()
-        bog_circuit = BogoliubovTransform(transformation_matrix, qubit_converter=converter)
-        for initial_state in range(2**n_orbitals):
-            state = Statevector.from_int(initial_state, dims=2**n_orbitals)
-            final_state = np.array(state.evolve(bog_circuit))
-            occupied_orbitals = [i for i in range(n_orbitals) if initial_state >> i & 1]
-            eig = np.sum(orbital_energies[occupied_orbitals]) + transformed_constant
-            np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-8)
+
+        with self.subTest("Qubit Converter object"):
+            matrix = converter.convert_only(hamiltonian.second_q_op()).to_matrix()
+            bog_circuit = BogoliubovTransform(transformation_matrix, qubit_mapper=converter)
+            for initial_state in range(2**n_orbitals):
+                state = Statevector.from_int(initial_state, dims=2**n_orbitals)
+                final_state = np.array(state.evolve(bog_circuit))
+                occupied_orbitals = [i for i in range(n_orbitals) if initial_state >> i & 1]
+                eig = np.sum(orbital_energies[occupied_orbitals]) + transformed_constant
+                np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-8)
+
+        with self.subTest("Qubit Mapper object"):
+            matrix = mapper.map(hamiltonian.second_q_op()).to_matrix()
+            bog_circuit = BogoliubovTransform(transformation_matrix, qubit_mapper=mapper)
+            for initial_state in range(2**n_orbitals):
+                state = Statevector.from_int(initial_state, dims=2**n_orbitals)
+                final_state = np.array(state.evolve(bog_circuit))
+                occupied_orbitals = [i for i in range(n_orbitals) if initial_state >> i & 1]
+                eig = np.sum(orbital_energies[occupied_orbitals]) + transformed_constant
+                np.testing.assert_allclose(matrix @ final_state, eig * final_state, atol=1e-8)
 
     @data(4, 5)
     def test_bogoliubov_transform_compose_num_conserving(self, n_orbitals):
         """Test Bogoliubov transform composition, particle-number-conserving."""
         unitary1 = np.array(random_unitary(n_orbitals, seed=4331))
         unitary2 = np.array(random_unitary(n_orbitals, seed=2506))
 
@@ -100,14 +107,27 @@
         register = QuantumRegister(n_orbitals)
         circuit = QuantumCircuit(register)
         circuit.append(bog_circuit_1, register)
         circuit.append(bog_circuit_2, register)
 
         self.assertTrue(Operator(circuit).equiv(Operator(bog_circuit_composed), atol=1e-8))
 
+    def test_bogoliubov_transform_jw_inverse_general_identity(self):
+        """Test Bogoliubov transform for the identity transformation."""
+        n_orbitals = 3
+        mat = np.eye(n_orbitals, 2 * n_orbitals, k=n_orbitals)
+        bog = BogoliubovTransform(mat)
+
+        register = QuantumRegister(n_orbitals)
+        circuit = QuantumCircuit(register)
+        circuit.append(bog, register)
+        circuit.append(bog.inverse(), register)
+
+        self.assertTrue(Operator(circuit).equiv(np.eye(2**n_orbitals), atol=1e-8))
+
     def test_no_side_effects(self):
         """Test that the routines don't mutate the input array."""
         n_orbitals = 5
         hermitian_part = random_hermitian(n_orbitals).data
         constant = np.random.uniform(-10, 10)
 
         quad_ham = QuadraticHamiltonian(hermitian_part, constant=constant)
@@ -129,8 +149,13 @@
         """Test that circuit keyword arguments are actually passed through."""
         circuit = BogoliubovTransform(np.eye(2), name="abcd")
         assert circuit.name == "abcd"
 
     def test_unsupported_mapper(self):
         """Test passing unsupported mapper fails gracefully."""
         with self.assertRaisesRegex(NotImplementedError, "supported"):
-            _ = BogoliubovTransform(np.eye(2), qubit_converter=QubitConverter(BravyiKitaevMapper()))
+            _ = BogoliubovTransform(np.eye(2), qubit_mapper=QubitConverter(BravyiKitaevMapper()))
+
+    def test_unsupported_mapper_no_converter(self):
+        """Test passing unsupported mapper fails gracefully when bypassing the qubit converter."""
+        with self.assertRaisesRegex(NotImplementedError, "supported"):
+            _ = BogoliubovTransform(np.eye(2), qubit_mapper=BravyiKitaevMapper())
```

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian.py` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_extra.py` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_extra.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_forces.py` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_forces.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -227,15 +227,14 @@
                 exp_vals = TestDriverGaussianForces._C01_REV_EXPECTED
         else:
             self.fail(f"Unknown gaussian version '{version}'")
 
         return exp_vals
 
     @unittest.skipIf(not _optionals.HAS_GAUSSIAN, "gaussian not available.")
-    @unittest.skipIf(not _optionals.HAS_SPARSE, "Sparse not available.")
     def test_driver_jcf(self):
         """Test the driver works with job control file"""
         driver = GaussianForcesDriver(
             [
                 "#p B3LYP/6-31g Freq=(Anharm) Int=Ultrafine SCF=VeryTight",
                 "",
                 "CO2 geometry optimization B3LYP/6-31g",
@@ -262,15 +261,14 @@
                 for ind in indices:
                     line += f", {ind}"
                 line += "],"
                 print(line)
         print("]\n")
 
     @unittest.skipIf(not _optionals.HAS_GAUSSIAN, "gaussian not available.")
-    @unittest.skipIf(not _optionals.HAS_SPARSE, "Sparse not available.")
     @data("B3LYP", "PBEPBE")
     def test_driver_molecule(self, xcf: str):
         """Test the driver works with Molecule"""
         molecule = MoleculeInfo(
             symbols=["C", "O", "O"],
             coords=[
                 (-0.848629, 2.067624, 0.160992),
@@ -287,15 +285,14 @@
         self._check_driver_result(self._get_expected_values(pbe=xcf == "PBEPBE"), result)
 
     @data(
         ("A03", _A03_REV_EXPECTED),
         ("C01", _C01_REV_EXPECTED),
     )
     @unpack
-    @unittest.skipIf(not _optionals.HAS_SPARSE, "Sparse not available.")
     def test_driver_logfile(self, suffix, expected):
         """Test the driver works with logfile (Gaussian does not need to be installed)"""
 
         driver = GaussianForcesDriver(
             logfile=self.get_resource_path(
                 f"test_driver_gaussian_log_{suffix}.txt", "second_q/drivers/gaussiand"
             )
```

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_from_mat.mat` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_from_mat.mat`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_from_mat.py` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_from_mat.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log.py` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log_A03.txt` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log_A03.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log_C01.txt` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log_C01.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log_polyyne_2.txt` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log_polyyne_2.txt`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_gaussian_log_vibrational_energy.hdf5` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_gaussian_log_vibrational_energy.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/gaussiand/test_driver_methods_gaussian.py` & `qiskit-nature-0.6.0/test/second_q/drivers/gaussiand/test_driver_methods_gaussian.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/psi4d/test_driver_methods_psi4.py` & `qiskit-nature-0.6.0/test/second_q/drivers/psi4d/test_driver_methods_psi4.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/psi4d/test_driver_psi4.py` & `qiskit-nature-0.6.0/test/second_q/drivers/psi4d/test_driver_psi4.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/psi4d/test_driver_psi4_extra.py` & `qiskit-nature-0.6.0/test/second_q/drivers/psi4d/test_driver_psi4_extra.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/pyscfd/test_driver_methods_pyscf.py` & `qiskit-nature-0.6.0/test/second_q/drivers/pyscfd/test_driver_methods_pyscf.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2019, 2022.
+# (C) Copyright IBM 2019, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -16,14 +16,15 @@
 
 from test.second_q.drivers.test_driver_methods_gsc import TestDriverMethods
 from qiskit_nature.units import DistanceUnit
 from qiskit_nature.second_q.drivers import PySCFDriver, MethodType
 from qiskit_nature.second_q.mappers import BravyiKitaevMapper, ParityMapper
 from qiskit_nature.second_q.mappers import QubitConverter
 from qiskit_nature.second_q.transformers import FreezeCoreTransformer
+from qiskit_nature.settings import settings
 import qiskit_nature.optionals as _optionals
 
 
 class TestDriverMethodsPySCF(TestDriverMethods):
     """Driver Methods PySCF tests"""
 
     @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
@@ -226,9 +227,23 @@
             basis="sto-3g",
             method=MethodType.UHF,
         )
         result = self._run_driver(driver, converter=QubitConverter(BravyiKitaevMapper()))
         self._assert_energy_and_dipole(result, "oh")
 
 
+class TestDriverMethodsPySCFSymmetric(TestDriverMethodsPySCF):
+    """Driver Methods PySCF tests with symmetry-reduced integrals enabled"""
+
+    @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
+    def setUp(self):
+        super().setUp()
+        self._prev_setting = settings.use_symmetry_reduced_integrals
+        settings.use_symmetry_reduced_integrals = True
+
+    def tearDown(self):
+        super().tearDown()
+        settings.use_symmetry_reduced_integrals = self._prev_setting
+
+
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/test_driver.py` & `qiskit-nature-0.6.0/test/second_q/drivers/test_driver.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,68 +1,72 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """ Test Driver """
 
+from __future__ import annotations
+import builtins
 from abc import ABC, abstractmethod
 from typing import cast
+from logging import Logger
+
+from test.second_q.utils import get_expected_two_body_ints
 
 import numpy as np
 
 from qiskit_nature.units import DistanceUnit
 from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
 from qiskit_nature.second_q.hamiltonians import ElectronicEnergy
-from qiskit_nature.second_q.operators.tensor_ordering import _chem_to_phys
 from qiskit_nature.second_q.problems import ElectronicStructureProblem
 
 
 class TestDriver(ABC):
     """Common driver tests. For H2 @ 0.735, sto3g"""
 
     MOLECULE = MoleculeInfo(
         symbols=["H", "H"],
         coords=[(0.0, 0.0, 0.0), (0.0, 0.0, 0.735)],
         multiplicity=1,
         charge=0,
         units=DistanceUnit.ANGSTROM,
     )
 
-    def __init__(self):
-        self.log = None
-        self.driver_result: ElectronicStructureProblem = None
+    def __init__(self) -> None:
+        self.log: Logger | None = None
+        self.driver_result: ElectronicStructureProblem | None = None
 
     @abstractmethod
     def subTest(self, msg, **kwargs):
         # pylint: disable=invalid-name
         """subtest"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None):
         """assert Almost Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertEqual(self, first, second, msg=None):
         """assert equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
         """assert Sequence Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     def test_driver_result_electronic_energy(self):
         """Test the ElectronicEnergy property."""
         electronic_energy = cast(ElectronicEnergy, self.driver_result.hamiltonian)
 
         with self.subTest("reference energy"):
             self.log.debug("HF energy: %s", self.driver_result.reference_energy)
@@ -82,26 +86,26 @@
                 np.absolute(mo_onee_ints),
                 [[1.2563, 0.0], [0.0, 0.4719]],
                 decimal=4,
             )
 
         with self.subTest("2-body integrals"):
             mo_eri_ints = electronic_energy.electronic_integrals.alpha["++--"]
+            expected_mo_ints = np.asarray(
+                [
+                    [[[0.6757, 0.0], [0.0, 0.6646]], [[0.0, 0.1809], [0.1809, 0.0]]],
+                    [[[0.0, 0.1809], [0.1809, 0.0]], [[0.6646, 0.0], [0.0, 0.6986]]],
+                ]
+            )
+            expected_mo_ints = get_expected_two_body_ints(mo_eri_ints, expected_mo_ints)
             self.log.debug("MO two electron integrals %s", mo_eri_ints)
             self.assertEqual(mo_eri_ints.shape, (2, 2, 2, 2))
             np.testing.assert_array_almost_equal(
                 np.absolute(mo_eri_ints),
-                _chem_to_phys(
-                    np.asarray(
-                        [
-                            [[[0.6757, 0.0], [0.0, 0.6646]], [[0.0, 0.1809], [0.1809, 0.0]]],
-                            [[[0.0, 0.1809], [0.1809, 0.0]], [[0.6646, 0.0], [0.0, 0.6986]]],
-                        ]
-                    )
-                ),
+                expected_mo_ints,
                 decimal=4,
             )
 
     def test_driver_result_system_size(self):
         """Test the system size problem attributes."""
 
         with self.subTest("orbital number"):
```

### Comparing `qiskit-nature-0.5.2/test/second_q/drivers/test_driver_methods_gsc.py` & `qiskit-nature-0.6.0/test/second_q/drivers/test_driver_methods_gsc.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump.py` & `qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,30 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """ Test FCIDump """
 
+import builtins
 import unittest
+import warnings
 from abc import ABC, abstractmethod
 from test import QiskitNatureTestCase
+from test.second_q.utils import get_expected_two_body_ints
 import numpy as np
 from qiskit_nature.second_q.formats.fcidump import FCIDump
 from qiskit_nature.second_q.formats.fcidump_translator import fcidump_to_problem
-from qiskit_nature.second_q.operators.tensor_ordering import _chem_to_phys
 
 
 class BaseTestFCIDump(ABC):
     """FCIDump base test class."""
 
     def __init__(self):
         self.log = None
@@ -37,30 +39,30 @@
         self.mo_eri_ba = None
         self.mo_eri_bb = None
 
     @abstractmethod
     def subTest(self, msg, **kwargs):
         # pylint: disable=invalid-name
         """subtest"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None):
         """assert Almost Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertEqual(self, first, second, msg=None):
         """assert equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
         """assert Sequence Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     def test_electronic_energy(self):
         """Test the ElectronicEnergy property."""
 
         electronic_energy = self.problem.hamiltonian
 
         with self.subTest("inactive energy"):
@@ -89,33 +91,39 @@
                 )
 
         with self.subTest("2-body alpha-alpha"):
             alpha_2body = electronic_energy.electronic_integrals.alpha["++--"]
             self.log.debug("MO two electron alpha-alpha integrals are %s", alpha_2body)
             self.assertEqual(alpha_2body.shape, self.mo_eri.shape)
             np.testing.assert_array_almost_equal(
-                np.absolute(alpha_2body), np.absolute(self.mo_eri), decimal=4
+                np.absolute(alpha_2body),
+                np.absolute(get_expected_two_body_ints(alpha_2body, self.mo_eri)),
+                decimal=4,
             )
 
         if self.mo_eri_ba is not None:
             with self.subTest("2-body beta-alpha"):
                 beta_alpha_2body = electronic_energy.electronic_integrals.beta_alpha["++--"]
                 self.log.debug("MO two electron beta-alpha integrals are %s", beta_alpha_2body)
                 self.assertEqual(beta_alpha_2body.shape, self.mo_eri_ba.shape)
                 np.testing.assert_array_almost_equal(
-                    np.absolute(beta_alpha_2body), np.absolute(self.mo_eri_ba), decimal=4
+                    np.absolute(beta_alpha_2body),
+                    np.absolute(get_expected_two_body_ints(beta_alpha_2body, self.mo_eri_ba)),
+                    decimal=4,
                 )
 
         if self.mo_eri_bb is not None:
             with self.subTest("2-body beta-beta"):
                 beta_2body = electronic_energy.electronic_integrals.beta["++--"]
                 self.log.debug("MO two electron beta-alpha integrals are %s", beta_2body)
                 self.assertEqual(beta_2body.shape, self.mo_eri_bb.shape)
                 np.testing.assert_array_almost_equal(
-                    np.absolute(beta_2body), np.absolute(self.mo_eri_bb), decimal=4
+                    np.absolute(beta_2body),
+                    np.absolute(get_expected_two_body_ints(beta_2body, self.mo_eri_bb)),
+                    decimal=4,
                 )
 
     def test_system_size(self):
         """Test the system size problem attributes."""
 
         with self.subTest("orbital number"):
             self.log.debug("Number of orbitals is %s", self.problem.num_spatial_orbitals)
@@ -137,67 +145,71 @@
         super().setUp()
         self.nuclear_repulsion_energy = 0.7199
         self.num_molecular_orbitals = 2
         self.num_alpha = 1
         self.num_beta = 1
         self.mo_onee = np.array([[1.2563, 0.0], [0.0, 0.4719]])
         self.mo_onee_b = None
-        self.mo_eri = _chem_to_phys(
-            np.array(
-                [
-                    [[[0.6757, 0.0], [0.0, 0.6646]], [[0.0, 0.1809], [0.1809, 0.0]]],
-                    [[[0.0, 0.1809], [0.1809, 0.0]], [[0.6646, 0.0], [0.0, 0.6986]]],
-                ]
-            )
+        self.mo_eri = np.array(
+            [
+                [[[0.6757, 0.0], [0.0, 0.6646]], [[0.0, 0.1809], [0.1809, 0.0]]],
+                [[[0.0, 0.1809], [0.1809, 0.0]], [[0.6646, 0.0], [0.0, 0.6986]]],
+            ]
         )
         self.mo_eri_ba = None
         self.mo_eri_bb = None
-        fcidump = FCIDump.from_file(
-            self.get_resource_path("test_fcidump_h2.fcidump", "second_q/formats/fcidump")
-        )
-        self.problem = fcidump_to_problem(fcidump)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            fcidump = FCIDump.from_file(
+                self.get_resource_path("test_fcidump_h2.fcidump", "second_q/formats/fcidump")
+            )
+            self.problem = fcidump_to_problem(fcidump)
 
 
 class TestFCIDumpLiH(QiskitNatureTestCase, BaseTestFCIDump):
     """RHF LiH FCIDump tests."""
 
     def setUp(self):
         super().setUp()
         self.nuclear_repulsion_energy = 0.9924
         self.num_molecular_orbitals = 6
         self.num_alpha = 2
         self.num_beta = 2
         loaded = np.load(self.get_resource_path("test_fcidump_lih.npz", "second_q/formats/fcidump"))
         self.mo_onee = loaded["mo_onee"]
         self.mo_onee_b = None
-        self.mo_eri = _chem_to_phys(loaded["mo_eri"])
+        self.mo_eri = loaded["mo_eri"]
         self.mo_eri_ba = None
         self.mo_eri_bb = None
-        fcidump = FCIDump.from_file(
-            self.get_resource_path("test_fcidump_lih.fcidump", "second_q/formats/fcidump")
-        )
-        self.problem = fcidump_to_problem(fcidump)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            fcidump = FCIDump.from_file(
+                self.get_resource_path("test_fcidump_lih.fcidump", "second_q/formats/fcidump")
+            )
+            self.problem = fcidump_to_problem(fcidump)
 
 
 class TestFCIDumpOH(QiskitNatureTestCase, BaseTestFCIDump):
     """UHF OH FCIDump tests."""
 
     def setUp(self):
         super().setUp()
         self.nuclear_repulsion_energy = 11.3412
         self.num_molecular_orbitals = 6
         self.num_alpha = 5
         self.num_beta = 4
         loaded = np.load(self.get_resource_path("test_fcidump_oh.npz", "second_q/formats/fcidump"))
         self.mo_onee = loaded["mo_onee"]
         self.mo_onee_b = loaded["mo_onee_b"]
-        self.mo_eri = _chem_to_phys(loaded["mo_eri"])
-        self.mo_eri_ba = _chem_to_phys(loaded["mo_eri_ba"])
-        self.mo_eri_bb = _chem_to_phys(loaded["mo_eri_bb"])
-        fcidump = FCIDump.from_file(
-            self.get_resource_path("test_fcidump_oh.fcidump", "second_q/formats/fcidump")
-        )
-        self.problem = fcidump_to_problem(fcidump)
+        self.mo_eri = loaded["mo_eri"]
+        self.mo_eri_ba = loaded["mo_eri_ba"]
+        self.mo_eri_bb = loaded["mo_eri_bb"]
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            fcidump = FCIDump.from_file(
+                self.get_resource_path("test_fcidump_oh.fcidump", "second_q/formats/fcidump")
+            )
+            self.problem = fcidump_to_problem(fcidump)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_dumper.py` & `qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_dumper.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,33 +1,39 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020, 2022.
+# (C) Copyright IBM 2020, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """ Test FCIDump Dumping """
 
 import tempfile
+import builtins
 import unittest
+import warnings
 from abc import ABC, abstractmethod
 from test import QiskitNatureTestCase
 from pathlib import Path
 import numpy as np
+
+from ddt import ddt, data
+
 from qiskit_nature import QiskitNatureError
 from qiskit_nature.second_q.formats.fcidump import FCIDump
-from qiskit_nature.second_q.operators.tensor_ordering import _phys_to_chem
+from qiskit_nature.second_q.operators.tensor_ordering import to_chemist_ordering, find_index_order
 from qiskit_nature.second_q.problems import ElectronicStructureProblem
 from qiskit_nature.units import DistanceUnit
 from qiskit_nature.second_q.drivers import PySCFDriver
+from qiskit_nature.settings import settings
 import qiskit_nature.optionals as _optionals
 
 
 class BaseTestFCIDumpDumper(ABC):
     """FCIDump dumping base test class."""
 
     def __init__(self):
@@ -42,30 +48,30 @@
         self.mo_onee = None
         self.mo_eri = None
 
     @abstractmethod
     def subTest(self, msg, **kwargs):
         # pylint: disable=invalid-name
         """subtest"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None):
         """assert Almost Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertEqual(self, first, second, msg=None):
         """assert equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     @abstractmethod
     def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
         """assert Sequence Equal"""
-        raise Exception("Abstract method")
+        raise builtins.Exception("Abstract method")
 
     def test_dumped_inactive_energy(self):
         """dumped inactive energy test"""
         self.log.debug("Dumped inactive energy is %g", self.dumped["ECORE"])
         self.assertAlmostEqual(self.dumped["ECORE"], self.core_energy, places=3)
 
     def test_dumped_num_molecular_orbitals(self):
@@ -151,41 +157,54 @@
         """
 
         electronic_energy = problem.hamiltonian
         electronic_integrals = electronic_energy.electronic_integrals
         hijkl = electronic_integrals.alpha.get("++--", None)
         hijkl_ba = electronic_integrals.beta_alpha.get("++--", None)
         hijkl_bb = electronic_integrals.beta.get("++--", None)
-        fcidump = FCIDump(
-            num_electrons=problem.num_alpha + problem.num_beta,
-            hij=electronic_integrals.alpha.get("+-", None),
-            hij_b=electronic_integrals.beta.get("+-", None),
-            hijkl=_phys_to_chem(hijkl) if hijkl is not None else None,
-            hijkl_ba=_phys_to_chem(hijkl_ba) if hijkl_ba is not None else None,
-            hijkl_bb=_phys_to_chem(hijkl_bb) if hijkl_bb is not None else None,
-            multiplicity=problem.molecule.multiplicity,
-            constant_energy=electronic_energy.nuclear_repulsion_energy,
-        )
-        fcidump.to_file(outpath)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
+            fcidump = FCIDump(
+                num_electrons=problem.num_alpha + problem.num_beta,
+                hij=electronic_integrals.alpha.get("+-", None),
+                hij_b=electronic_integrals.beta.get("+-", None),
+                hijkl=to_chemist_ordering(hijkl) if hijkl is not None else None,
+                hijkl_ba=to_chemist_ordering(hijkl_ba, index_order=find_index_order(hijkl))
+                if hijkl_ba is not None
+                else None,
+                hijkl_bb=to_chemist_ordering(hijkl_bb) if hijkl_bb is not None else None,
+                multiplicity=problem.molecule.multiplicity,
+                constant_energy=electronic_energy.nuclear_repulsion_energy,
+            )
+            fcidump.to_file(outpath)
 
 
+@ddt
 class TestFCIDumpDumpOH(QiskitNatureTestCase):
     """RHF FCIDump tests."""
 
-    def test_dump_unrestricted_spin(self):
+    @data(True, False)
+    def test_dump_unrestricted_spin(self, use_symmetry_reduced_integrals: bool):
         """Tests dumping unrestricted spin data.
         PySCF cannot handle this themselves, so we need to rely on a custom FCIDUMP file, load it,
         dump it again, and make sure it did not change."""
-        path = self.get_resource_path("test_fcidump_oh.fcidump", "second_q/formats/fcidump")
-        fcidump = FCIDump.from_file(path)
-        with tempfile.TemporaryDirectory() as dump_dir:
-            dump_file = Path(dump_dir) / "fcidump"
-            fcidump.to_file(dump_file)
-
-            with open(path, "r", encoding="utf-8") as reference:
-                with open(dump_file, "r", encoding="utf-8") as result:
-                    for ref, res in zip(reference.readlines(), result.readlines()):
-                        self.assertEqual(ref.strip(), res.strip())
+        prev_setting = settings.use_symmetry_reduced_integrals
+        settings.use_symmetry_reduced_integrals = use_symmetry_reduced_integrals
+        try:
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore", category=DeprecationWarning)
+                path = self.get_resource_path("test_fcidump_oh.fcidump", "second_q/formats/fcidump")
+                fcidump = FCIDump.from_file(path)
+                with tempfile.TemporaryDirectory() as dump_dir:
+                    dump_file = Path(dump_dir) / "fcidump"
+                    fcidump.to_file(dump_file)
+
+                    with open(path, "r", encoding="utf-8") as reference:
+                        with open(dump_file, "r", encoding="utf-8") as result:
+                            for ref, res in zip(reference.readlines(), result.readlines()):
+                                self.assertEqual(ref.strip(), res.strip())
+        finally:
+            settings.use_symmetry_reduced_integrals = prev_setting
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_lih.fcidump` & `qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_lih.fcidump`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_lih.npz` & `qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_lih.npz`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_oh.fcidump` & `qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_oh.fcidump`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/fcidump/test_fcidump_oh.npz` & `qiskit-nature-0.6.0/test/second_q/formats/fcidump/test_fcidump_oh.npz`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/qcschema/he2_energy_VV10_input.py` & `qiskit-nature-0.6.0/test/second_q/formats/qcschema/he2_energy_VV10_input.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/qcschema/he2_energy_VV10_output.json` & `qiskit-nature-0.6.0/test/second_q/formats/qcschema/he2_energy_VV10_output.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/qcschema/he2_energy_VV10_output.py` & `qiskit-nature-0.6.0/test/second_q/formats/qcschema/he2_energy_VV10_output.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/qcschema/legacy_electronic_structure_driver_result.json` & `qiskit-nature-0.6.0/test/second_q/formats/qcschema/legacy_electronic_structure_driver_result.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/qcschema/water_output.json` & `qiskit-nature-0.6.0/test/second_q/formats/qcschema/water_output.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/qcschema/water_output.py` & `qiskit-nature-0.6.0/test/second_q/formats/qcschema/water_output.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/qcschema/water_output_v3.json` & `qiskit-nature-0.6.0/test/second_q/formats/qcschema/water_output_v3.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/qcschema/water_output_v3.py` & `qiskit-nature-0.6.0/test/second_q/formats/qcschema/water_output_v3.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/formats/test_qcschema.py` & `qiskit-nature-0.6.0/test/second_q/formats/test_qcschema.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_hyper_cubic_lattice.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_hyper_cubic_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_lattice.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_line_lattice.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_line_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_square_lattice.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_square_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/lattices/test_triangular_lattice.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/lattices/test_triangular_lattice.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/resources/electronic_energy_op.json` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/resources/electronic_energy_op.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/test_electronic_energy.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/test_electronic_energy.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/test_fermi_hubbard_model.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/test_fermi_hubbard_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/test_heisenberg_model.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/test_heisenberg_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/test_ising_model.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/test_ising_model.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/test_quadratic_hamiltonian.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/test_quadratic_hamiltonian.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,32 +1,33 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Tests for QuadraticHamiltonian"""
 
 from test import QiskitNatureTestCase
-from test.nature_random import random_antisymmetric_matrix
 
 import numpy as np
 from ddt import data, ddt
 from qiskit.quantum_info import random_hermitian
+from qiskit.opflow import PauliSumOp
 
-from qiskit_nature.second_q.mappers import QubitConverter
-from qiskit_nature.second_q.mappers import JordanWignerMapper
 from qiskit_nature.second_q.hamiltonians import QuadraticHamiltonian
+from qiskit_nature.second_q.mappers import JordanWignerMapper, QubitConverter
 from qiskit_nature.second_q.operators import FermionicOp
+from qiskit_nature.settings import settings
+from qiskit_nature.testing import random_antisymmetric_matrix
 
 
 @ddt
 class TestQuadraticHamiltonian(QiskitNatureTestCase):
     """QuadraticHamiltonian tests."""
 
     def test_init(self):
@@ -101,19 +102,18 @@
         np.testing.assert_allclose(orbital_energies, np.sort(orbital_energies))
         np.testing.assert_allclose(canonical, expected, atol=1e-7)
         np.testing.assert_allclose(
             transformed_constant, majorana_constant - 0.5 * np.sum(orbital_energies)
         )
 
         # confirm eigenvalues match with Jordan-Wigner transformed Hamiltonian
-        hamiltonian_jw = (
-            QubitConverter(mapper=JordanWignerMapper())
-            .convert(quad_ham.second_q_op())
-            .primitive.to_matrix()
-        )
+        qubit_op = QubitConverter(mapper=JordanWignerMapper()).convert(quad_ham.second_q_op())
+        if isinstance(qubit_op, PauliSumOp):
+            qubit_op = qubit_op.primitive
+        hamiltonian_jw = qubit_op.to_matrix()
         eigs, _ = np.linalg.eigh(hamiltonian_jw)
         expected_eigs = np.array(
             [
                 np.sum(orbital_energies[list(occupied_orbitals)]) + transformed_constant
                 for occupied_orbitals in [(), (0,), (1,), (2,), (0, 1), (0, 2), (1, 2), (0, 1, 2)]
             ]
         )
@@ -174,24 +174,24 @@
         antisymmetric_part = np.array([[0, 4j], [-4j, 0]])
         constant = 5.0
         quad_ham = QuadraticHamiltonian(hermitian_part, antisymmetric_part, constant)
         fermionic_op = quad_ham.second_q_op()
         expected_terms = {
             "": 5.0,
             "+_0 -_0": 1.0,
-            "+_1 -_1": 3.0,
             "+_0 -_1": 2j,
-            "-_0 +_1": 2j,
-            "+_0 +_1": 4j,
-            "-_0 -_1": 4j,
+            "+_1 -_0": -2j,
+            "+_1 -_1": 3.0,
+            "+_0 +_1": 2j,
+            "+_1 +_0": -2j,
+            "-_0 -_1": 2j,
+            "-_1 -_0": -2j,
         }
         expected_op = FermionicOp(expected_terms, num_spin_orbitals=2)
-        matrix = fermionic_op.to_matrix(sparse=False)
-        expected_matrix = expected_op.to_matrix(sparse=False)
-        np.testing.assert_allclose(matrix, expected_matrix)
+        self.assertTrue(expected_op.equiv(fermionic_op))
 
     def test_validate(self):
         """Test input validation."""
         mat = np.array([[1, 2], [3, 4]])
         _ = QuadraticHamiltonian(hermitian_part=mat, antisymmetric_part=None, validate=False)
         with self.assertRaisesRegex(ValueError, "Hermitian"):
             _ = QuadraticHamiltonian(hermitian_part=mat, antisymmetric_part=None)
@@ -242,19 +242,35 @@
 
         quad_ham_scaled = quad_ham * 2
         expected = QuadraticHamiltonian(
             np.array([[2, 4j], [-4j, 6]]), np.array([[0, 8], [-8, 0]]), 10.0
         )
         self.assertEqual(quad_ham_scaled, expected)
 
-    def test_repr(self):
+    @data(True, False)
+    def test_repr(self, tensor_unwrapping):
         """Test repr"""
-        quad_ham = QuadraticHamiltonian(
-            np.array([[1, 2j], [-2j, 3]]), np.array([[0, 4.0], [-4.0, 0]]), 5.0
-        )
-        self.assertEqual(
-            repr(quad_ham),
-            "QuadraticHamiltonian("
-            "hermitian_part=array([[ 1.+0.j,  0.+2.j],\n       [-0.-2.j,  3.+0.j]]), "
-            "antisymmetric_part=array([[ 0.,  4.],\n       [-4.,  0.]]), "
-            "constant=5.0, num_modes=2)",
-        )
+        aux = settings.tensor_unwrapping
+        try:
+            settings.tensor_unwrapping = tensor_unwrapping
+            quad_ham = QuadraticHamiltonian(
+                np.array([[1, 2j], [-2j, 3]]), np.array([[0, 4.0], [-4.0, 0]]), 5.0
+            )
+
+            if not tensor_unwrapping:
+                self.assertEqual(
+                    repr(quad_ham),
+                    "QuadraticHamiltonian("
+                    "hermitian_part=array([[ 1.+0.j,  0.+2.j],\n       [-0.-2.j,  3.+0.j]]), "
+                    "antisymmetric_part=array([[ 0.,  4.],\n       [-4.,  0.]]), "
+                    "constant=array(5.), num_modes=2)",
+                )
+            else:
+                self.assertEqual(
+                    repr(quad_ham),
+                    "QuadraticHamiltonian("
+                    "hermitian_part=array([[ 1.+0.j,  0.+2.j],\n       [-0.-2.j,  3.+0.j]]), "
+                    "antisymmetric_part=array([[ 0.,  4.],\n       [-4.,  0.]]), "
+                    "constant=5.0, num_modes=2)",
+                )
+        finally:
+            settings.tensor_unwrapping = aux
```

### Comparing `qiskit-nature-0.5.2/test/second_q/hamiltonians/test_vibrational_energy.py` & `qiskit-nature-0.6.0/test/second_q/hamiltonians/test_vibrational_energy.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/mappers/resources/bksf_lih.py` & `qiskit-nature-0.6.0/test/second_q/mappers/resources/bksf_lih.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/mappers/resources/reference_direct_mapper.py` & `qiskit-nature-0.6.0/test/second_q/mappers/resources/reference_direct_mapper.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,315 +1,317 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
-"""The reference PauliSumOp for the DirectMapper."""
+"""The reference PauliSumOp and SparsePauliOp for the DirectMapper."""
 
 from qiskit.opflow import PauliSumOp
+from qiskit.quantum_info import SparsePauliOp
 
-_num_modals_2_q_op = PauliSumOp.from_list(
-    [
-        ("IIIIIIII", 4854.200029687493),
-        ("ZIIIIIII", -342.57516687500015),
-        ("IZIIIIII", -111.85586312500007),
-        ("IIZIIIII", -342.57516687500015),
-        ("ZIZIIIII", 15.97128750000001),
-        ("IZZIIIII", 5.323762500000003),
-        ("IIIZIIII", -111.85586312500007),
-        ("ZIIZIIII", 5.323762500000003),
-        ("IZIZIIII", 1.7745875000000009),
-        ("IIIIZIII", -1049.719110937499),
-        ("ZIIIZIII", -9.437173593750005),
-        ("IZIIZIII", -3.1457245312500017),
-        ("IIZIZIII", -9.437173593750005),
-        ("IIIZZIII", -3.1457245312500017),
-        ("IIIIIZII", -349.4856346875002),
-        ("ZIIIIZII", -3.1457245312500017),
-        ("IZIIIZII", -1.0485748437500004),
-        ("IIZIIZII", -3.1457245312500017),
-        ("IIIZIZII", -1.0485748437500004),
-        ("IIIIIIZI", -1860.5306717187502),
-        ("ZIIIIIZI", -22.963255312500017),
-        ("IZIIIIZI", -7.654418437500004),
-        ("IIZIIIZI", -22.963255312500017),
-        ("IIIZIIZI", -7.654418437500004),
-        ("IIIIZIZI", 11.120720625000006),
-        ("IIIIIZZI", 3.706906875000002),
-        ("IIIIIIIZ", -618.5645973437502),
-        ("ZIIIIIIZ", -7.654418437500005),
-        ("IZIIIIIZ", -2.551472812500001),
-        ("IIZIIIIZ", -7.654418437500005),
-        ("IIIZIIIZ", -2.551472812500001),
-        ("IIIIZIIZ", 3.706906875000002),
-        ("IIIIIZIZ", 1.2356356250000005),
-        ("IIIIXXII", -25.864048912543417),
-        ("ZIIIXXII", -32.006454827123605),
-        ("IZIIXXII", -10.668818275707867),
-        ("IIZIXXII", -32.006454827123605),
-        ("IIIZXXII", -10.668818275707867),
-        ("IIIIYYII", -25.864048912543417),
-        ("ZIIIYYII", -32.006454827123605),
-        ("IZIIYYII", -10.668818275707867),
-        ("IIZIYYII", -32.006454827123605),
-        ("IIIZYYII", -10.668818275707867),
-        ("IIIIXXZI", 66.1513066265725),
-        ("IIIIYYZI", 66.1513066265725),
-        ("IIIIXXIZ", 22.050435542190833),
-        ("IIIIYYIZ", 22.050435542190833),
-    ]
-)
+_list_2_q_op = [
+    ("IIIIIIII", 4854.200029687493),
+    ("ZIIIIIII", -342.57516687500015),
+    ("IZIIIIII", -111.85586312500007),
+    ("IIZIIIII", -342.57516687500015),
+    ("ZIZIIIII", 15.97128750000001),
+    ("IZZIIIII", 5.323762500000003),
+    ("IIIZIIII", -111.85586312500007),
+    ("ZIIZIIII", 5.323762500000003),
+    ("IZIZIIII", 1.7745875000000009),
+    ("IIIIZIII", -1049.719110937499),
+    ("ZIIIZIII", -9.437173593750005),
+    ("IZIIZIII", -3.1457245312500017),
+    ("IIZIZIII", -9.437173593750005),
+    ("IIIZZIII", -3.1457245312500017),
+    ("IIIIIZII", -349.4856346875002),
+    ("ZIIIIZII", -3.1457245312500017),
+    ("IZIIIZII", -1.0485748437500004),
+    ("IIZIIZII", -3.1457245312500017),
+    ("IIIZIZII", -1.0485748437500004),
+    ("IIIIIIZI", -1860.5306717187502),
+    ("ZIIIIIZI", -22.963255312500017),
+    ("IZIIIIZI", -7.654418437500004),
+    ("IIZIIIZI", -22.963255312500017),
+    ("IIIZIIZI", -7.654418437500004),
+    ("IIIIZIZI", 11.120720625000006),
+    ("IIIIIZZI", 3.706906875000002),
+    ("IIIIIIIZ", -618.5645973437502),
+    ("ZIIIIIIZ", -7.654418437500005),
+    ("IZIIIIIZ", -2.551472812500001),
+    ("IIZIIIIZ", -7.654418437500005),
+    ("IIIZIIIZ", -2.551472812500001),
+    ("IIIIZIIZ", 3.706906875000002),
+    ("IIIIIZIZ", 1.2356356250000005),
+    ("IIIIXXII", -25.864048912543417),
+    ("ZIIIXXII", -32.006454827123605),
+    ("IZIIXXII", -10.668818275707867),
+    ("IIZIXXII", -32.006454827123605),
+    ("IIIZXXII", -10.668818275707867),
+    ("IIIIYYII", -25.864048912543417),
+    ("ZIIIYYII", -32.006454827123605),
+    ("IZIIYYII", -10.668818275707867),
+    ("IIZIYYII", -32.006454827123605),
+    ("IIIZYYII", -10.668818275707867),
+    ("IIIIXXZI", 66.1513066265725),
+    ("IIIIYYZI", 66.1513066265725),
+    ("IIIIXXIZ", 22.050435542190833),
+    ("IIIIYYIZ", 22.050435542190833),
+]
 
-_num_modals_3_q_op = PauliSumOp.from_list(
-    [
-        ("IIIIIIIIIIII", 10788.719982656237),
-        ("ZIIIIIIIIIII", -541.6731217187498),
-        ("IZIIIIIIIIII", -315.1932645312502),
-        ("IIZIIIIIIIII", -102.72856234375004),
-        ("IIIZIIIIIIII", -541.6731217187498),
-        ("ZIIZIIIIIIII", 44.36468750000001),
-        ("IZIZIIIIIIII", 26.618812500000015),
-        ("IIZZIIIIIIII", 8.872937500000004),
-        ("XIXIIIIIIIII", -13.32410345498359),
-        ("YIYIIIIIIIII", -13.32410345498359),
-        ("XIXZIIIIIIII", -12.54822855058883),
-        ("YIYZIIIIIIII", -12.54822855058883),
-        ("IIIIZIIIIIII", -315.1932645312502),
-        ("ZIIIZIIIIIII", 26.61881250000001),
-        ("IZIIZIIIIIII", 15.97128750000001),
-        ("IIZIZIIIIIII", 5.323762500000003),
-        ("XIXIZIIIIIII", -7.528937130353299),
-        ("YIYIZIIIIIII", -7.528937130353299),
-        ("IIIIIZIIIIII", -102.72856234375004),
-        ("ZIIIIZIIIIII", 8.872937500000003),
-        ("IZIIIZIIIIII", 5.323762500000003),
-        ("IIZIIZIIIIII", 1.7745875000000009),
-        ("XIXIIZIIIIII", -2.509645710117766),
-        ("YIYIIZIIIIII", -2.509645710117766),
-        ("IIIIIIZIIIII", -1730.9391493749995),
-        ("ZIIIIIZIIIII", -26.21437109375001),
-        ("IZIIIIZIIIII", -15.728622656250007),
-        ("IIZIIIZIIIII", -5.242874218750002),
-        ("IIIZIIZIIIII", -26.21437109375001),
-        ("XIXIIIZIIIII", 7.4145438259724985),
-        ("YIYIIIZIIIII", 7.4145438259724985),
-        ("IIIIZIZIIIII", -15.728622656250007),
-        ("IIIIIZZIIIII", -5.242874218750002),
-        ("IIIIIIIZIIII", -1036.7963999999984),
-        ("ZIIIIIIZIIII", -15.728622656250007),
-        ("IZIIIIIZIIII", -9.437173593750005),
-        ("IIZIIIIZIIII", -3.1457245312500017),
-        ("IIIZIIIZIIII", -15.728622656250007),
-        ("XIXIIIIZIIII", 4.4487262955835),
-        ("YIYIIIIZIIII", 4.4487262955835),
-        ("IIIIZIIZIIII", -9.437173593750005),
-        ("IIIIIZIZIIII", -3.1457245312500017),
-        ("IIIIIIIIZIII", -345.1780643749999),
-        ("ZIIIIIIIZIII", -5.242874218750002),
-        ("IZIIIIIIZIII", -3.1457245312500017),
-        ("IIZIIIIIZIII", -1.0485748437500004),
-        ("IIIZIIIIZIII", -5.242874218750002),
-        ("XIXIIIIIZIII", 1.4829087651944997),
-        ("YIYIIIIIZIII", 1.4829087651944997),
-        ("IIIIZIIIZIII", -3.1457245312500017),
-        ("IIIIIZIIZIII", -1.0485748437500004),
-        ("IIIIIIIIIZII", -3015.4877554687487),
-        ("ZIIIIIIIIZII", -63.786820312500026),
-        ("IZIIIIIIIZII", -38.27209218750002),
-        ("IIZIIIIIIZII", -12.757364062500006),
-        ("IIIZIIIIIZII", -63.786820312500026),
-        ("XIXIIIIIIZII", 18.04163727731863),
-        ("YIYIIIIIIZII", 18.04163727731863),
-        ("IIIIZIIIIZII", -38.27209218750002),
-        ("IIIIIZIIIZII", -12.757364062500006),
-        ("IIIIIIZIIZII", 30.89089062500001),
-        ("IIIIIIIZIZII", 18.53453437500001),
-        ("IIIIIIIIZZII", 6.178178125000003),
-        ("IIIIIIIIIIZI", -1802.5210217187503),
-        ("ZIIIIIIIIIZI", -38.27209218750002),
-        ("IZIIIIIIIIZI", -22.963255312500017),
-        ("IIZIIIIIIIZI", -7.654418437500004),
-        ("IIIZIIIIIIZI", -38.27209218750002),
-        ("XIXIIIIIIIZI", 10.82498236639118),
-        ("YIYIIIIIIIZI", 10.82498236639118),
-        ("IIIIZIIIIIZI", -22.963255312500017),
-        ("IIIIIZIIIIZI", -7.654418437500004),
-        ("IIIIIIZIIIZI", 18.534534375000007),
-        ("IIIIIIIZIIZI", 11.120720625000006),
-        ("IIIIIIIIZIZI", 3.706906875000002),
-        ("IIIIIIIIIIIZ", -599.2280473437502),
-        ("ZIIIIIIIIIIZ", -12.757364062500006),
-        ("IZIIIIIIIIIZ", -7.654418437500005),
-        ("IIZIIIIIIIIZ", -2.551472812500001),
-        ("IIIZIIIIIIIZ", -12.757364062500006),
-        ("XIXIIIIIIIIZ", 3.608327455463727),
-        ("YIYIIIIIIIIZ", 3.608327455463727),
-        ("IIIIZIIIIIIZ", -7.654418437500005),
-        ("IIIIIZIIIIIZ", -2.551472812500001),
-        ("IIIIIIZIIIIZ", 6.178178125000002),
-        ("IIIIIIIZIIIZ", 3.706906875000002),
-        ("IIIIIIIIZIIZ", 1.2356356250000005),
-        ("IXXXXIIIIIII", -2.8170754092577175),
-        ("IYYXXIIIIIII", -2.8170754092577175),
-        ("IXXYYIIIIIII", -2.8170754092577175),
-        ("IYYYYIIIIIII", -2.8170754092577175),
-        ("IIIXIXIIIIII", -13.3241034549836),
-        ("ZIIXIXIIIIII", -12.548228550588828),
-        ("IZIXIXIIIIII", -7.528937130353299),
-        ("IIZXIXIIIIII", -2.509645710117766),
-        ("XIXXIXIIIIII", 3.5491750000000017),
-        ("YIYXIXIIIIII", 3.5491750000000017),
-        ("IIIYIYIIIIII", -13.3241034549836),
-        ("ZIIYIYIIIIII", -12.548228550588828),
-        ("IZIYIYIIIIII", -7.528937130353299),
-        ("IIZYIYIIIIII", -2.509645710117766),
-        ("XIXYIYIIIIII", 3.5491750000000017),
-        ("YIYYIYIIIIII", 3.5491750000000017),
-        ("IIIXIXZIIIII", 7.4145438259724985),
-        ("IIIYIYZIIIII", 7.4145438259724985),
-        ("IIIXIXIZIIII", 4.4487262955835),
-        ("IIIYIYIZIIII", 4.4487262955835),
-        ("IIIXIXIIZIII", 1.4829087651944997),
-        ("IIIYIYIIZIII", 1.4829087651944997),
-        ("IIIXIXIIIZII", 18.04163727731863),
-        ("IIIYIYIIIZII", 18.04163727731863),
-        ("IIIXIXIIIIZI", 10.82498236639118),
-        ("IIIYIYIIIIZI", 10.82498236639118),
-        ("IIIXIXIIIIIZ", 3.608327455463727),
-        ("IIIYIYIIIIIZ", 3.608327455463727),
-        ("XXIIXXIIIIII", 2.8170754092577175),
-        ("YYIIXXIIIIII", 2.8170754092577175),
-        ("XXIIYYIIIIII", 2.8170754092577175),
-        ("YYIIYYIIIIII", 2.8170754092577175),
-        ("IIIIIIXXIIII", -74.16262749999993),
-        ("ZIIIIIXXIIII", -75.43993750000001),
-        ("IZIIIIXXIIII", -45.26396250000001),
-        ("IIZIIIXXIIII", -15.087987500000002),
-        ("IIIZIIXXIIII", -75.43993750000001),
-        ("XIXIIIXXIIII", 21.337636551415734),
-        ("YIYIIIXXIIII", 21.337636551415734),
-        ("IIIIZIXXIIII", -45.26396250000001),
-        ("IIIIIZXXIIII", -15.087987500000002),
-        ("IIIIIIYYIIII", -74.16262749999993),
-        ("ZIIIIIYYIIII", -75.43993750000001),
-        ("IZIIIIYYIIII", -45.26396250000001),
-        ("IIZIIIYYIIII", -15.087987500000002),
-        ("IIIZIIYYIIII", -75.43993750000001),
-        ("XIXIIIYYIIII", 21.337636551415734),
-        ("YIYIIIYYIIII", 21.337636551415734),
-        ("IIIIZIYYIIII", -45.26396250000001),
-        ("IIIIIZYYIIII", -15.087987500000002),
-        ("IIIIIIXXIZII", 155.920125),
-        ("IIIIIIYYIZII", 155.920125),
-        ("IIIIIIXXIIZI", 93.55207500000002),
-        ("IIIIIIYYIIZI", 93.55207500000002),
-        ("IIIIIIXXIIIZ", 31.184025000000005),
-        ("IIIIIIYYIIIZ", 31.184025000000005),
-        ("IIIXIXXXIIII", 21.337636551415734),
-        ("IIIYIYXXIIII", 21.337636551415734),
-        ("IIIXIXYYIIII", 21.337636551415734),
-        ("IIIYIYYYIIII", 21.337636551415734),
-        ("IIIIIIXIXIII", -9.180253761118216),
-        ("ZIIIIIXIXIII", 7.414543825972498),
-        ("IZIIIIXIXIII", 4.4487262955835),
-        ("IIZIIIXIXIII", 1.4829087651944997),
-        ("IIIZIIXIXIII", 7.414543825972498),
-        ("XIXIIIXIXIII", -2.097149687500001),
-        ("YIYIIIXIXIII", -2.097149687500001),
-        ("IIIIZIXIXIII", 4.4487262955835),
-        ("IIIIIZXIXIII", 1.4829087651944997),
-        ("IIIIIIYIYIII", -9.180253761118216),
-        ("ZIIIIIYIYIII", 7.414543825972498),
-        ("IZIIIIYIYIII", 4.4487262955835),
-        ("IIZIIIYIYIII", 1.4829087651944997),
-        ("IIIZIIYIYIII", 7.414543825972498),
-        ("XIXIIIYIYIII", -2.097149687500001),
-        ("YIYIIIYIYIII", -2.097149687500001),
-        ("IIIIZIYIYIII", 4.4487262955835),
-        ("IIIIIZYIYIII", 1.4829087651944997),
-        ("IIIIIIXIXZII", -8.737263295131783),
-        ("IIIIIIYIYZII", -8.737263295131783),
-        ("IIIIIIXIXIZI", -5.24235797707907),
-        ("IIIIIIYIYIZI", -5.24235797707907),
-        ("IIIIIIXIXIIZ", -1.7474526590263566),
-        ("IIIIIIYIYIIZ", -1.7474526590263566),
-        ("IIIXIXXIXIII", -2.097149687500001),
-        ("IIIYIYXIXIII", -2.097149687500001),
-        ("IIIXIXYIYIII", -2.097149687500001),
-        ("IIIYIYYIYIII", -2.097149687500001),
-        ("IIIIIIIXXIII", -29.42804386641884),
-        ("ZIIIIIIXXIII", -53.34409137853934),
-        ("IZIIIIIXXIII", -32.006454827123605),
-        ("IIZIIIIXXIII", -10.668818275707867),
-        ("IIIZIIIXXIII", -53.34409137853934),
-        ("XIXIIIIXXIII", 15.087987500000006),
-        ("YIYIIIIXXIII", 15.087987500000006),
-        ("IIIIZIIXXIII", -32.006454827123605),
-        ("IIIIIZIXXIII", -10.668818275707867),
-        ("IIIIIIIYYIII", -29.42804386641884),
-        ("ZIIIIIIYYIII", -53.34409137853934),
-        ("IZIIIIIYYIII", -32.006454827123605),
-        ("IIZIIIIYYIII", -10.668818275707867),
-        ("IIIZIIIYYIII", -53.34409137853934),
-        ("XIXIIIIYYIII", 15.087987500000006),
-        ("YIYIIIIYYIII", 15.087987500000006),
-        ("IIIIZIIYYIII", -32.006454827123605),
-        ("IIIIIZIYYIII", -10.668818275707867),
-        ("IIIIIIIXXZII", 110.25217771095417),
-        ("IIIIIIIYYZII", 110.25217771095417),
-        ("IIIIIIIXXIZI", 66.1513066265725),
-        ("IIIIIIIYYIZI", 66.1513066265725),
-        ("IIIIIIIXXIIZ", 22.050435542190833),
-        ("IIIIIIIYYIIZ", 22.050435542190833),
-        ("IIIXIXIXXIII", 15.087987500000006),
-        ("IIIYIYIXXIII", 15.087987500000006),
-        ("IIIXIXIYYIII", 15.087987500000006),
-        ("IIIYIYIYYIII", 15.087987500000006),
-        ("IIIIIIIIIXIX", -42.38243941348044),
-        ("ZIIIIIIIIXIX", 18.04163727731863),
-        ("IZIIIIIIIXIX", 10.824982366391183),
-        ("IIZIIIIIIXIX", 3.608327455463727),
-        ("IIIZIIIIIXIX", 18.04163727731863),
-        ("XIXIIIIIIXIX", -5.102945625000002),
-        ("YIYIIIIIIXIX", -5.102945625000002),
-        ("IIIIZIIIIXIX", 10.824982366391183),
-        ("IIIIIZIIIXIX", 3.608327455463727),
-        ("IIIIIIZIIXIX", -8.737263295131783),
-        ("IIIIIIIZIXIX", -5.24235797707907),
-        ("IIIIIIIIZXIX", -1.7474526590263566),
-        ("IIIIIIIIIYIY", -42.38243941348044),
-        ("ZIIIIIIIIYIY", 18.04163727731863),
-        ("IZIIIIIIIYIY", 10.824982366391183),
-        ("IIZIIIIIIYIY", 3.608327455463727),
-        ("IIIZIIIIIYIY", 18.04163727731863),
-        ("XIXIIIIIIYIY", -5.102945625000002),
-        ("YIYIIIIIIYIY", -5.102945625000002),
-        ("IIIIZIIIIYIY", 10.824982366391183),
-        ("IIIIIZIIIYIY", 3.608327455463727),
-        ("IIIIIIZIIYIY", -8.737263295131783),
-        ("IIIIIIIZIYIY", -5.24235797707907),
-        ("IIIIIIIIZYIY", -1.7474526590263566),
-        ("IIIXIXIIIXIX", -5.102945625000002),
-        ("IIIYIYIIIXIX", -5.102945625000002),
-        ("IIIXIXIIIYIY", -5.102945625000002),
-        ("IIIYIYIIIYIY", -5.102945625000002),
-        ("IIIIIIXXIXIX", -44.100871084381666),
-        ("IIIIIIYYIXIX", -44.100871084381666),
-        ("IIIIIIXXIYIY", -44.100871084381666),
-        ("IIIIIIYYIYIY", -44.100871084381666),
-        ("IIIIIIXIXXIX", 2.471271250000001),
-        ("IIIIIIYIYXIX", 2.471271250000001),
-        ("IIIIIIXIXYIY", 2.471271250000001),
-        ("IIIIIIYIYYIY", 2.471271250000001),
-        ("IIIIIIIXXXIX", -31.184025000000013),
-        ("IIIIIIIYYXIX", -31.184025000000013),
-        ("IIIIIIIXXYIY", -31.184025000000013),
-        ("IIIIIIIYYYIY", -31.184025000000013),
-    ]
-)
+_list_3_q_op = [
+    ("IIIIIIIIIIII", 10788.719982656237),
+    ("ZIIIIIIIIIII", -541.6731217187498),
+    ("IZIIIIIIIIII", -315.1932645312502),
+    ("IIZIIIIIIIII", -102.72856234375004),
+    ("IIIZIIIIIIII", -541.6731217187498),
+    ("ZIIZIIIIIIII", 44.36468750000001),
+    ("IZIZIIIIIIII", 26.618812500000015),
+    ("IIZZIIIIIIII", 8.872937500000004),
+    ("XIXIIIIIIIII", -13.32410345498359),
+    ("YIYIIIIIIIII", -13.32410345498359),
+    ("XIXZIIIIIIII", -12.54822855058883),
+    ("YIYZIIIIIIII", -12.54822855058883),
+    ("IIIIZIIIIIII", -315.1932645312502),
+    ("ZIIIZIIIIIII", 26.61881250000001),
+    ("IZIIZIIIIIII", 15.97128750000001),
+    ("IIZIZIIIIIII", 5.323762500000003),
+    ("XIXIZIIIIIII", -7.528937130353299),
+    ("YIYIZIIIIIII", -7.528937130353299),
+    ("IIIIIZIIIIII", -102.72856234375004),
+    ("ZIIIIZIIIIII", 8.872937500000003),
+    ("IZIIIZIIIIII", 5.323762500000003),
+    ("IIZIIZIIIIII", 1.7745875000000009),
+    ("XIXIIZIIIIII", -2.509645710117766),
+    ("YIYIIZIIIIII", -2.509645710117766),
+    ("IIIIIIZIIIII", -1730.9391493749995),
+    ("ZIIIIIZIIIII", -26.21437109375001),
+    ("IZIIIIZIIIII", -15.728622656250007),
+    ("IIZIIIZIIIII", -5.242874218750002),
+    ("IIIZIIZIIIII", -26.21437109375001),
+    ("XIXIIIZIIIII", 7.4145438259724985),
+    ("YIYIIIZIIIII", 7.4145438259724985),
+    ("IIIIZIZIIIII", -15.728622656250007),
+    ("IIIIIZZIIIII", -5.242874218750002),
+    ("IIIIIIIZIIII", -1036.7963999999984),
+    ("ZIIIIIIZIIII", -15.728622656250007),
+    ("IZIIIIIZIIII", -9.437173593750005),
+    ("IIZIIIIZIIII", -3.1457245312500017),
+    ("IIIZIIIZIIII", -15.728622656250007),
+    ("XIXIIIIZIIII", 4.4487262955835),
+    ("YIYIIIIZIIII", 4.4487262955835),
+    ("IIIIZIIZIIII", -9.437173593750005),
+    ("IIIIIZIZIIII", -3.1457245312500017),
+    ("IIIIIIIIZIII", -345.1780643749999),
+    ("ZIIIIIIIZIII", -5.242874218750002),
+    ("IZIIIIIIZIII", -3.1457245312500017),
+    ("IIZIIIIIZIII", -1.0485748437500004),
+    ("IIIZIIIIZIII", -5.242874218750002),
+    ("XIXIIIIIZIII", 1.4829087651944997),
+    ("YIYIIIIIZIII", 1.4829087651944997),
+    ("IIIIZIIIZIII", -3.1457245312500017),
+    ("IIIIIZIIZIII", -1.0485748437500004),
+    ("IIIIIIIIIZII", -3015.4877554687487),
+    ("ZIIIIIIIIZII", -63.786820312500026),
+    ("IZIIIIIIIZII", -38.27209218750002),
+    ("IIZIIIIIIZII", -12.757364062500006),
+    ("IIIZIIIIIZII", -63.786820312500026),
+    ("XIXIIIIIIZII", 18.04163727731863),
+    ("YIYIIIIIIZII", 18.04163727731863),
+    ("IIIIZIIIIZII", -38.27209218750002),
+    ("IIIIIZIIIZII", -12.757364062500006),
+    ("IIIIIIZIIZII", 30.89089062500001),
+    ("IIIIIIIZIZII", 18.53453437500001),
+    ("IIIIIIIIZZII", 6.178178125000003),
+    ("IIIIIIIIIIZI", -1802.5210217187503),
+    ("ZIIIIIIIIIZI", -38.27209218750002),
+    ("IZIIIIIIIIZI", -22.963255312500017),
+    ("IIZIIIIIIIZI", -7.654418437500004),
+    ("IIIZIIIIIIZI", -38.27209218750002),
+    ("XIXIIIIIIIZI", 10.82498236639118),
+    ("YIYIIIIIIIZI", 10.82498236639118),
+    ("IIIIZIIIIIZI", -22.963255312500017),
+    ("IIIIIZIIIIZI", -7.654418437500004),
+    ("IIIIIIZIIIZI", 18.534534375000007),
+    ("IIIIIIIZIIZI", 11.120720625000006),
+    ("IIIIIIIIZIZI", 3.706906875000002),
+    ("IIIIIIIIIIIZ", -599.2280473437502),
+    ("ZIIIIIIIIIIZ", -12.757364062500006),
+    ("IZIIIIIIIIIZ", -7.654418437500005),
+    ("IIZIIIIIIIIZ", -2.551472812500001),
+    ("IIIZIIIIIIIZ", -12.757364062500006),
+    ("XIXIIIIIIIIZ", 3.608327455463727),
+    ("YIYIIIIIIIIZ", 3.608327455463727),
+    ("IIIIZIIIIIIZ", -7.654418437500005),
+    ("IIIIIZIIIIIZ", -2.551472812500001),
+    ("IIIIIIZIIIIZ", 6.178178125000002),
+    ("IIIIIIIZIIIZ", 3.706906875000002),
+    ("IIIIIIIIZIIZ", 1.2356356250000005),
+    ("IXXXXIIIIIII", -2.8170754092577175),
+    ("IYYXXIIIIIII", -2.8170754092577175),
+    ("IXXYYIIIIIII", -2.8170754092577175),
+    ("IYYYYIIIIIII", -2.8170754092577175),
+    ("IIIXIXIIIIII", -13.3241034549836),
+    ("ZIIXIXIIIIII", -12.548228550588828),
+    ("IZIXIXIIIIII", -7.528937130353299),
+    ("IIZXIXIIIIII", -2.509645710117766),
+    ("XIXXIXIIIIII", 3.5491750000000017),
+    ("YIYXIXIIIIII", 3.5491750000000017),
+    ("IIIYIYIIIIII", -13.3241034549836),
+    ("ZIIYIYIIIIII", -12.548228550588828),
+    ("IZIYIYIIIIII", -7.528937130353299),
+    ("IIZYIYIIIIII", -2.509645710117766),
+    ("XIXYIYIIIIII", 3.5491750000000017),
+    ("YIYYIYIIIIII", 3.5491750000000017),
+    ("IIIXIXZIIIII", 7.4145438259724985),
+    ("IIIYIYZIIIII", 7.4145438259724985),
+    ("IIIXIXIZIIII", 4.4487262955835),
+    ("IIIYIYIZIIII", 4.4487262955835),
+    ("IIIXIXIIZIII", 1.4829087651944997),
+    ("IIIYIYIIZIII", 1.4829087651944997),
+    ("IIIXIXIIIZII", 18.04163727731863),
+    ("IIIYIYIIIZII", 18.04163727731863),
+    ("IIIXIXIIIIZI", 10.82498236639118),
+    ("IIIYIYIIIIZI", 10.82498236639118),
+    ("IIIXIXIIIIIZ", 3.608327455463727),
+    ("IIIYIYIIIIIZ", 3.608327455463727),
+    ("XXIIXXIIIIII", 2.8170754092577175),
+    ("YYIIXXIIIIII", 2.8170754092577175),
+    ("XXIIYYIIIIII", 2.8170754092577175),
+    ("YYIIYYIIIIII", 2.8170754092577175),
+    ("IIIIIIXXIIII", -74.16262749999993),
+    ("ZIIIIIXXIIII", -75.43993750000001),
+    ("IZIIIIXXIIII", -45.26396250000001),
+    ("IIZIIIXXIIII", -15.087987500000002),
+    ("IIIZIIXXIIII", -75.43993750000001),
+    ("XIXIIIXXIIII", 21.337636551415734),
+    ("YIYIIIXXIIII", 21.337636551415734),
+    ("IIIIZIXXIIII", -45.26396250000001),
+    ("IIIIIZXXIIII", -15.087987500000002),
+    ("IIIIIIYYIIII", -74.16262749999993),
+    ("ZIIIIIYYIIII", -75.43993750000001),
+    ("IZIIIIYYIIII", -45.26396250000001),
+    ("IIZIIIYYIIII", -15.087987500000002),
+    ("IIIZIIYYIIII", -75.43993750000001),
+    ("XIXIIIYYIIII", 21.337636551415734),
+    ("YIYIIIYYIIII", 21.337636551415734),
+    ("IIIIZIYYIIII", -45.26396250000001),
+    ("IIIIIZYYIIII", -15.087987500000002),
+    ("IIIIIIXXIZII", 155.920125),
+    ("IIIIIIYYIZII", 155.920125),
+    ("IIIIIIXXIIZI", 93.55207500000002),
+    ("IIIIIIYYIIZI", 93.55207500000002),
+    ("IIIIIIXXIIIZ", 31.184025000000005),
+    ("IIIIIIYYIIIZ", 31.184025000000005),
+    ("IIIXIXXXIIII", 21.337636551415734),
+    ("IIIYIYXXIIII", 21.337636551415734),
+    ("IIIXIXYYIIII", 21.337636551415734),
+    ("IIIYIYYYIIII", 21.337636551415734),
+    ("IIIIIIXIXIII", -9.180253761118216),
+    ("ZIIIIIXIXIII", 7.414543825972498),
+    ("IZIIIIXIXIII", 4.4487262955835),
+    ("IIZIIIXIXIII", 1.4829087651944997),
+    ("IIIZIIXIXIII", 7.414543825972498),
+    ("XIXIIIXIXIII", -2.097149687500001),
+    ("YIYIIIXIXIII", -2.097149687500001),
+    ("IIIIZIXIXIII", 4.4487262955835),
+    ("IIIIIZXIXIII", 1.4829087651944997),
+    ("IIIIIIYIYIII", -9.180253761118216),
+    ("ZIIIIIYIYIII", 7.414543825972498),
+    ("IZIIIIYIYIII", 4.4487262955835),
+    ("IIZIIIYIYIII", 1.4829087651944997),
+    ("IIIZIIYIYIII", 7.414543825972498),
+    ("XIXIIIYIYIII", -2.097149687500001),
+    ("YIYIIIYIYIII", -2.097149687500001),
+    ("IIIIZIYIYIII", 4.4487262955835),
+    ("IIIIIZYIYIII", 1.4829087651944997),
+    ("IIIIIIXIXZII", -8.737263295131783),
+    ("IIIIIIYIYZII", -8.737263295131783),
+    ("IIIIIIXIXIZI", -5.24235797707907),
+    ("IIIIIIYIYIZI", -5.24235797707907),
+    ("IIIIIIXIXIIZ", -1.7474526590263566),
+    ("IIIIIIYIYIIZ", -1.7474526590263566),
+    ("IIIXIXXIXIII", -2.097149687500001),
+    ("IIIYIYXIXIII", -2.097149687500001),
+    ("IIIXIXYIYIII", -2.097149687500001),
+    ("IIIYIYYIYIII", -2.097149687500001),
+    ("IIIIIIIXXIII", -29.42804386641884),
+    ("ZIIIIIIXXIII", -53.34409137853934),
+    ("IZIIIIIXXIII", -32.006454827123605),
+    ("IIZIIIIXXIII", -10.668818275707867),
+    ("IIIZIIIXXIII", -53.34409137853934),
+    ("XIXIIIIXXIII", 15.087987500000006),
+    ("YIYIIIIXXIII", 15.087987500000006),
+    ("IIIIZIIXXIII", -32.006454827123605),
+    ("IIIIIZIXXIII", -10.668818275707867),
+    ("IIIIIIIYYIII", -29.42804386641884),
+    ("ZIIIIIIYYIII", -53.34409137853934),
+    ("IZIIIIIYYIII", -32.006454827123605),
+    ("IIZIIIIYYIII", -10.668818275707867),
+    ("IIIZIIIYYIII", -53.34409137853934),
+    ("XIXIIIIYYIII", 15.087987500000006),
+    ("YIYIIIIYYIII", 15.087987500000006),
+    ("IIIIZIIYYIII", -32.006454827123605),
+    ("IIIIIZIYYIII", -10.668818275707867),
+    ("IIIIIIIXXZII", 110.25217771095417),
+    ("IIIIIIIYYZII", 110.25217771095417),
+    ("IIIIIIIXXIZI", 66.1513066265725),
+    ("IIIIIIIYYIZI", 66.1513066265725),
+    ("IIIIIIIXXIIZ", 22.050435542190833),
+    ("IIIIIIIYYIIZ", 22.050435542190833),
+    ("IIIXIXIXXIII", 15.087987500000006),
+    ("IIIYIYIXXIII", 15.087987500000006),
+    ("IIIXIXIYYIII", 15.087987500000006),
+    ("IIIYIYIYYIII", 15.087987500000006),
+    ("IIIIIIIIIXIX", -42.38243941348044),
+    ("ZIIIIIIIIXIX", 18.04163727731863),
+    ("IZIIIIIIIXIX", 10.824982366391183),
+    ("IIZIIIIIIXIX", 3.608327455463727),
+    ("IIIZIIIIIXIX", 18.04163727731863),
+    ("XIXIIIIIIXIX", -5.102945625000002),
+    ("YIYIIIIIIXIX", -5.102945625000002),
+    ("IIIIZIIIIXIX", 10.824982366391183),
+    ("IIIIIZIIIXIX", 3.608327455463727),
+    ("IIIIIIZIIXIX", -8.737263295131783),
+    ("IIIIIIIZIXIX", -5.24235797707907),
+    ("IIIIIIIIZXIX", -1.7474526590263566),
+    ("IIIIIIIIIYIY", -42.38243941348044),
+    ("ZIIIIIIIIYIY", 18.04163727731863),
+    ("IZIIIIIIIYIY", 10.824982366391183),
+    ("IIZIIIIIIYIY", 3.608327455463727),
+    ("IIIZIIIIIYIY", 18.04163727731863),
+    ("XIXIIIIIIYIY", -5.102945625000002),
+    ("YIYIIIIIIYIY", -5.102945625000002),
+    ("IIIIZIIIIYIY", 10.824982366391183),
+    ("IIIIIZIIIYIY", 3.608327455463727),
+    ("IIIIIIZIIYIY", -8.737263295131783),
+    ("IIIIIIIZIYIY", -5.24235797707907),
+    ("IIIIIIIIZYIY", -1.7474526590263566),
+    ("IIIXIXIIIXIX", -5.102945625000002),
+    ("IIIYIYIIIXIX", -5.102945625000002),
+    ("IIIXIXIIIYIY", -5.102945625000002),
+    ("IIIYIYIIIYIY", -5.102945625000002),
+    ("IIIIIIXXIXIX", -44.100871084381666),
+    ("IIIIIIYYIXIX", -44.100871084381666),
+    ("IIIIIIXXIYIY", -44.100871084381666),
+    ("IIIIIIYYIYIY", -44.100871084381666),
+    ("IIIIIIXIXXIX", 2.471271250000001),
+    ("IIIIIIYIYXIX", 2.471271250000001),
+    ("IIIIIIXIXYIY", 2.471271250000001),
+    ("IIIIIIYIYYIY", 2.471271250000001),
+    ("IIIIIIIXXXIX", -31.184025000000013),
+    ("IIIIIIIYYXIX", -31.184025000000013),
+    ("IIIIIIIXXYIY", -31.184025000000013),
+    ("IIIIIIIYYYIY", -31.184025000000013),
+]
+
+_num_modals_2_q_op = PauliSumOp.from_list(_list_2_q_op)
+_num_modals_3_q_op = PauliSumOp.from_list(_list_3_q_op)
+_sparse_num_modals_2_q_op = SparsePauliOp.from_list(_list_2_q_op)
+_sparse_num_modals_3_q_op = SparsePauliOp.from_list(_list_3_q_op)
```

### Comparing `qiskit-nature-0.5.2/test/second_q/mappers/test_direct_mapper.py` & `qiskit-nature-0.6.0/test/second_q/mappers/test_direct_mapper.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -14,18 +14,21 @@
 
 import unittest
 
 from test import QiskitNatureTestCase
 from test.second_q.mappers.resources.reference_direct_mapper import (
     _num_modals_2_q_op,
     _num_modals_3_q_op,
+    _sparse_num_modals_2_q_op,
+    _sparse_num_modals_3_q_op,
 )
-
+from qiskit_nature import settings
 from qiskit_nature.second_q.drivers import GaussianForcesDriver
 from qiskit_nature.second_q.mappers import DirectMapper
+from qiskit_nature.second_q.operators import VibrationalOp
 from qiskit_nature.second_q.problems import HarmonicBasis
 import qiskit_nature.optionals as _optionals
 
 
 class TestDirectMapper(QiskitNatureTestCase):
     """Test Direct Mapper"""
 
@@ -47,34 +50,50 @@
         basis = HarmonicBasis(num_modals)
         problem = self.driver.run(basis)
 
         vibration_energy = problem.hamiltonian
         vibration_op = vibration_energy.second_q_op()
 
         mapper = DirectMapper()
-        qubit_op = mapper.map(vibration_op)
-
-        self.assertEqual(qubit_op, _num_modals_2_q_op)
+        aux = settings.use_pauli_sum_op
+        try:
+            settings.use_pauli_sum_op = True
+            qubit_op = mapper.map(vibration_op)
+            self.assertEqual(qubit_op, _num_modals_2_q_op)
+            settings.use_pauli_sum_op = False
+            qubit_op = mapper.map(vibration_op)
+            self.assertEqualSparsePauliOp(qubit_op, _sparse_num_modals_2_q_op)
+        finally:
+            settings.use_pauli_sum_op = aux
 
     @unittest.skipIf(not _optionals.HAS_SPARSE, "Sparse not available.")
     def test_larger_tutorial_qubit_op(self):
         """Test the 3-modal qubit operator generated in the vibrational structure tutorial."""
         num_modals = [3, 3, 3, 3]
         basis = HarmonicBasis(num_modals)
         problem = self.driver.run(basis)
 
         vibration_energy = problem.hamiltonian
         vibration_op = vibration_energy.second_q_op()
 
         mapper = DirectMapper()
-        qubit_op = mapper.map(vibration_op)
-
-        self.assertEqual(qubit_op, _num_modals_3_q_op)
-
-    def test_allows_two_qubit_reduction(self):
-        """Test this returns False for this mapper"""
+        aux = settings.use_pauli_sum_op
+        try:
+            settings.use_pauli_sum_op = True
+            qubit_op = mapper.map(vibration_op)
+            self.assertEqual(qubit_op, _num_modals_3_q_op)
+            settings.use_pauli_sum_op = False
+            qubit_op = mapper.map(vibration_op)
+            self.assertEqualSparsePauliOp(qubit_op, _sparse_num_modals_3_q_op)
+        finally:
+            settings.use_pauli_sum_op = aux
+
+    def test_mapping_overwrite_reg_len(self):
+        """Test overwriting the register length."""
+        op = VibrationalOp({"+_0_0 -_0_0": 1}, num_modals=[1])
+        expected = VibrationalOp({"+_0_0 -_0_0": 1}, num_modals=[1, 1, 1])
         mapper = DirectMapper()
-        self.assertFalse(mapper.allows_two_qubit_reduction)
+        self.assertEqual(mapper.map(op, register_length=3), mapper.map(expected))
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/mappers/test_linear_mapper.py` & `qiskit-nature-0.6.0/test/second_q/mappers/test_linear_mapper.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -18,14 +18,15 @@
 
 from ddt import ddt, data, unpack
 
 from qiskit.opflow import PauliSumOp
 from qiskit.quantum_info import SparsePauliOp
 from qiskit_nature.second_q.operators import SpinOp
 from qiskit_nature.second_q.mappers import LinearMapper
+from qiskit_nature import settings
 
 
 @ddt
 class TestLinearMapper(QiskitNatureTestCase):
     """Test Linear Mapper"""
 
     spin_op1 = SpinOp({"Y_0^2": -0.432 + 1.32j}, 0.5, 1)
@@ -76,13 +77,28 @@
         (spin_op4, ref_qubit_op4),
         (spin_op5, ref_qubit_op5),
     )
     @unpack
     def test_mapping(self, spin_op, ref_qubit_op):
         """Test mapping to qubit operator"""
         mapper = LinearMapper()
-        qubit_op = mapper.map(spin_op)
-        self.assertEqual(qubit_op, PauliSumOp(ref_qubit_op))
+        aux = settings.use_pauli_sum_op
+        try:
+            settings.use_pauli_sum_op = True
+            qubit_op = mapper.map(spin_op)
+            self.assertEqual(qubit_op, PauliSumOp(ref_qubit_op))
+            settings.use_pauli_sum_op = False
+            qubit_op = mapper.map(spin_op)
+            self.assertEqualSparsePauliOp(qubit_op, ref_qubit_op)
+        finally:
+            settings.use_pauli_sum_op = aux
+
+    def test_mapping_overwrite_reg_len(self):
+        """Test overwriting the register length."""
+        op = SpinOp({"Y_0^2": -0.432 + 1.32j}, 0.5, 1)
+        expected = SpinOp({"Y_0^2": -0.432 + 1.32j}, 0.5, 3)
+        mapper = LinearMapper()
+        self.assertEqual(mapper.map(op, register_length=3), mapper.map(expected))
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/mappers/test_logarithmic_mapper.py` & `qiskit-nature-0.6.0/test/second_q/mappers/test_logarithmic_mapper.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -18,14 +18,15 @@
 
 from ddt import ddt, data, unpack
 
 from qiskit.opflow import PauliSumOp
 from qiskit.quantum_info.operators import SparsePauliOp
 from qiskit_nature.second_q.operators import SpinOp
 from qiskit_nature.second_q.mappers import LogarithmicMapper
+from qiskit_nature import settings
 
 
 @ddt
 class TestLogarithmicMapper(QiskitNatureTestCase):
     """Test Logarithmic Mapper"""
 
     spin_op1 = SpinOp({"Y_0": -0.432 + 1.32j}, 0.5, 1)
@@ -60,13 +61,28 @@
         (spin_op6, ref_qubit_op6, 2),
         (spin_op6, ref_qubit_op7, 2, False),
     )
     @unpack
     def test_mapping(self, spin_op, ref_qubit_op, padding=1, embed_upper=True):
         """Test mapping to qubit operator"""
         mapper = LogarithmicMapper(padding=padding, embed_upper=embed_upper)
-        qubit_op = mapper.map(spin_op)
-        self.assertEqual(qubit_op, PauliSumOp(ref_qubit_op))
+        aux = settings.use_pauli_sum_op
+        try:
+            settings.use_pauli_sum_op = True
+            qubit_op = mapper.map(spin_op)
+            self.assertEqual(qubit_op, PauliSumOp(ref_qubit_op))
+            settings.use_pauli_sum_op = False
+            qubit_op = mapper.map(spin_op)
+            self.assertEqualSparsePauliOp(qubit_op, ref_qubit_op)
+        finally:
+            settings.use_pauli_sum_op = aux
+
+    def test_mapping_overwrite_reg_len(self):
+        """Test overwriting the register length."""
+        op = SpinOp({"Y_0": -0.432 + 1.32j}, 0.5, 1)
+        expected = SpinOp({"Y_0": -0.432 + 1.32j}, 0.5, 3)
+        mapper = LogarithmicMapper()
+        self.assertEqual(mapper.map(op, register_length=3), mapper.map(expected))
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/operators/test_commutators.py` & `qiskit-nature-0.6.0/test/second_q/operators/test_commutators.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,20 +12,21 @@
 
 """Test for commutators"""
 
 from __future__ import annotations
 
 import unittest
 from test import QiskitNatureTestCase
-from ddt import ddt, data, unpack
+
+from ddt import data, ddt, unpack
 
 from qiskit_nature.second_q.operators import FermionicOp
 from qiskit_nature.second_q.operators.commutators import (
-    commutator,
     anti_commutator,
+    commutator,
     double_commutator,
 )
 
 op1 = FermionicOp({"+_0 -_0": 1}, num_spin_orbitals=1)
 op2 = FermionicOp({"-_0 +_0": 2}, num_spin_orbitals=1)
 op3 = FermionicOp({"+_0 -_0": 1, "-_0 +_0": 2 + 0.5j}, num_spin_orbitals=1)
 op4 = FermionicOp({"+_0": 1}, num_spin_orbitals=1)
@@ -41,23 +42,35 @@
         (op1, op2, {}),
         (op4, op5, {"+_0 -_0": (1 + 0j), "-_0 +_0": (-1 + 0j)}),
     )
     def test_commutator(self, op_a: FermionicOp, op_b: FermionicOp, expected: dict):
         """Test commutator method"""
         self.assertEqual(commutator(op_a, op_b), FermionicOp(expected, num_spin_orbitals=1))
 
+        with self.subTest("test simplfication tolerance"):
+            modified_op = op_a + FermionicOp({"+_0": 1e-10}, num_spin_orbitals=1)
+            self.assertNotEqual(
+                commutator(modified_op, op_b), FermionicOp(expected, num_spin_orbitals=1)
+            )
+
     @unpack
     @data(
         (op1, op2, {}),
         (op1, op3, {"+_0 -_0": (2 + 0j)}),
     )
     def test_anti_commutator(self, op_a: FermionicOp, op_b: FermionicOp, expected: dict):
         """Test anti commutator method"""
         self.assertEqual(anti_commutator(op_a, op_b), FermionicOp(expected, num_spin_orbitals=1))
 
+        with self.subTest("test simplfication tolerance"):
+            modified_op = op_a + FermionicOp({"-_0": 1e-10}, num_spin_orbitals=1)
+            self.assertNotEqual(
+                anti_commutator(modified_op, op_b), FermionicOp(expected, num_spin_orbitals=1)
+            )
+
     @unpack
     @data(
         (op1, op2, op3, False, {}),
         (op1, op4, op3, False, {"+_0": (1 + 0.5j)}),
         (op1, op4, op3, True, {"+_0": (2 + 0.5j)}),
     )
     def test_double_commutator(
@@ -69,10 +82,17 @@
         expected: dict,
     ):
         """Test double commutator method"""
         self.assertEqual(
             double_commutator(op_a, op_b, op_c, sign), FermionicOp(expected, num_spin_orbitals=1)
         )
 
+        with self.subTest("test simplfication tolerance"):
+            modified_op = op_a + FermionicOp({"-_0": 1e-10}, num_spin_orbitals=1)
+            self.assertNotEqual(
+                double_commutator(modified_op, op_b, op_c, sign),
+                FermionicOp(expected, num_spin_orbitals=1),
+            )
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/operators/test_electronic_integrals.py` & `qiskit-nature-0.6.0/test/second_q/operators/test_electronic_integrals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/operators/test_fermionic_op.py` & `qiskit-nature-0.6.0/test/second_q/operators/test_fermionic_op.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Test for FermionicOp"""
 
 import unittest
+import warnings
 from test import QiskitNatureTestCase
 
 import numpy as np
 from ddt import data, ddt, unpack
 from qiskit.circuit import Parameter
 from scipy.sparse import csc_matrix
 from scipy.sparse.linalg import eigs
@@ -80,14 +81,19 @@
         targ = self.op3
         self.assertEqual(fer_op, targ)
 
         fer_op = self.op1 + self.op4
         targ = FermionicOp({"+_0 -_0": 1 + self.a})
         self.assertEqual(fer_op, targ)
 
+        with self.subTest("sum"):
+            fer_op = sum(FermionicOp({label: 1}) for label in ["+_0", "-_1", "+_2 -_2"])
+            targ = FermionicOp({"+_0": 1, "-_1": 1, "+_2 -_2": 1})
+            self.assertEqual(fer_op, targ)
+
     def test_sub(self):
         """Test __sub__"""
         fer_op = self.op3 - self.op2
         targ = FermionicOp({"+_0 -_0": 1, "-_0 +_0": 0}, num_spin_orbitals=1)
         self.assertEqual(fer_op, targ)
 
         fer_op = self.op4 - self.op1
@@ -302,78 +308,81 @@
         FermionicOp.rtol = 1e-4
         self.assertTrue(op3.equiv(self.op3))
         FermionicOp.atol = prev_atol
         FermionicOp.rtol = prev_rtol
 
     def test_to_matrix(self):
         """Test to_matrix"""
-        with self.subTest("identity operator matrix"):
-            op = FermionicOp.one()
-            op.num_spin_orbitals = 2
-            mat = op.to_matrix(sparse=False)
-            targ = np.eye(4)
-            self.assertTrue(np.allclose(mat, targ))
-
-        with self.subTest("number operator matrix"):
-            mat = FermionicOp({"+_1 -_1": 1}, num_spin_orbitals=2).to_matrix(sparse=False)
-            targ = np.array([[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]])
-            self.assertTrue(np.allclose(mat, targ))
-
-        with self.subTest("emptiness operator matrix"):
-            mat = FermionicOp({"-_1 +_1": 1}, num_spin_orbitals=2).to_matrix(sparse=False)
-            targ = np.array([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]])
-            self.assertTrue(np.allclose(mat, targ))
-
-        with self.subTest("raising operator matrix"):
-            mat = FermionicOp({"+_1": 1}, num_spin_orbitals=2).to_matrix(sparse=False)
-            targ = np.array([[0, 0, 0, 0], [1, 0, 0, 0], [0, 0, 0, 0], [0, 0, -1, 0]])
-            self.assertTrue(np.allclose(mat, targ))
-
-        with self.subTest("lowering operator matrix"):
-            mat = FermionicOp({"-_1": 1}, num_spin_orbitals=2).to_matrix(sparse=False)
-            targ = np.array([[0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, -1], [0, 0, 0, 0]])
-            self.assertTrue(np.allclose(mat, targ))
-
-        with self.subTest("nontrivial sparse matrix"):
-            mat = FermionicOp(
-                {"-_0 +_0 +_1 -_1 +_3": 3j, "-_0 +_1 -_1 +_2 -_3": -2}, num_spin_orbitals=4
-            ).to_matrix()
-            targ = csc_matrix(([-3j, 3j, -2], ([5, 7, 6], [4, 6, 13])), shape=(16, 16))
-            self.assertTrue((mat != targ).nnz == 0)
-
-        with self.subTest("Test Hydrogen spectrum"):
-            h2_labels = {
-                "+_0 -_1 +_2 -_3": 0.18093120148374142,
-                "+_0 -_1 -_2 +_3": -0.18093120148374134,
-                "-_0 +_1 +_2 -_3": -0.18093120148374134,
-                "-_0 +_1 -_2 +_3": 0.18093120148374128,
-                "+_3 -_3": -0.4718960038869427,
-                "+_2 -_2": -1.2563391028292563,
-                "+_2 -_2 +_3 -_3": 0.48365053378098793,
-                "+_1 -_1": -0.4718960038869427,
-                "+_1 -_1 +_3 -_3": 0.6985737398458793,
-                "+_1 -_1 +_2 -_2": 0.6645817352647293,
-                "+_0 -_0": -1.2563391028292563,
-                "+_0 -_0 +_3 -_3": 0.6645817352647293,
-                "+_0 -_0 +_2 -_2": 0.6757101625347564,
-                "+_0 -_0 +_1 -_1": 0.48365053378098793,
-            }
-            h2_matrix = FermionicOp(h2_labels, num_spin_orbitals=4).to_matrix()
-            evals, evecs = eigs(h2_matrix)
-            self.assertTrue(np.isclose(np.min(evals), -1.8572750))
-            # make sure the ground state has support only in the 2-particle subspace
-            groundstate = evecs[:, np.argmin(evals)]
-            for idx in np.where(~np.isclose(groundstate, 0))[0]:
-                binary = f"{idx:0{4}b}"
-                self.assertEqual(binary.count("1"), 2)
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", category=DeprecationWarning)
 
-        with self.subTest("parameters"):
-            fer_op = FermionicOp({"+_0": self.a})
-            with self.assertRaisesRegex(ValueError, "parameter"):
-                _ = fer_op.to_matrix()
+            with self.subTest("identity operator matrix"):
+                op = FermionicOp.one()
+                op.num_spin_orbitals = 2
+                mat = op.to_matrix(sparse=False)
+                targ = np.eye(4)
+                self.assertTrue(np.allclose(mat, targ))
+
+            with self.subTest("number operator matrix"):
+                mat = FermionicOp({"+_1 -_1": 1}, num_spin_orbitals=2).to_matrix(sparse=False)
+                targ = np.array([[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]])
+                self.assertTrue(np.allclose(mat, targ))
+
+            with self.subTest("emptiness operator matrix"):
+                mat = FermionicOp({"-_1 +_1": 1}, num_spin_orbitals=2).to_matrix(sparse=False)
+                targ = np.array([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]])
+                self.assertTrue(np.allclose(mat, targ))
+
+            with self.subTest("raising operator matrix"):
+                mat = FermionicOp({"+_1": 1}, num_spin_orbitals=2).to_matrix(sparse=False)
+                targ = np.array([[0, 0, 0, 0], [1, 0, 0, 0], [0, 0, 0, 0], [0, 0, -1, 0]])
+                self.assertTrue(np.allclose(mat, targ))
+
+            with self.subTest("lowering operator matrix"):
+                mat = FermionicOp({"-_1": 1}, num_spin_orbitals=2).to_matrix(sparse=False)
+                targ = np.array([[0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, -1], [0, 0, 0, 0]])
+                self.assertTrue(np.allclose(mat, targ))
+
+            with self.subTest("nontrivial sparse matrix"):
+                mat = FermionicOp(
+                    {"-_0 +_0 +_1 -_1 +_3": 3j, "-_0 +_1 -_1 +_2 -_3": -2}, num_spin_orbitals=4
+                ).to_matrix()
+                targ = csc_matrix(([-3j, 3j, -2], ([5, 7, 6], [4, 6, 13])), shape=(16, 16))
+                self.assertTrue((mat != targ).nnz == 0)
+
+            with self.subTest("Test Hydrogen spectrum"):
+                h2_labels = {
+                    "+_0 -_1 +_2 -_3": 0.18093120148374142,
+                    "+_0 -_1 -_2 +_3": -0.18093120148374134,
+                    "-_0 +_1 +_2 -_3": -0.18093120148374134,
+                    "-_0 +_1 -_2 +_3": 0.18093120148374128,
+                    "+_3 -_3": -0.4718960038869427,
+                    "+_2 -_2": -1.2563391028292563,
+                    "+_2 -_2 +_3 -_3": 0.48365053378098793,
+                    "+_1 -_1": -0.4718960038869427,
+                    "+_1 -_1 +_3 -_3": 0.6985737398458793,
+                    "+_1 -_1 +_2 -_2": 0.6645817352647293,
+                    "+_0 -_0": -1.2563391028292563,
+                    "+_0 -_0 +_3 -_3": 0.6645817352647293,
+                    "+_0 -_0 +_2 -_2": 0.6757101625347564,
+                    "+_0 -_0 +_1 -_1": 0.48365053378098793,
+                }
+                h2_matrix = FermionicOp(h2_labels, num_spin_orbitals=4).to_matrix()
+                evals, evecs = eigs(h2_matrix)
+                self.assertTrue(np.isclose(np.min(evals), -1.8572750))
+                # make sure the ground state has support only in the 2-particle subspace
+                groundstate = evecs[:, np.argmin(evals)]
+                for idx in np.where(~np.isclose(groundstate, 0))[0]:
+                    binary = f"{idx:0{4}b}"
+                    self.assertEqual(binary.count("1"), 2)
+
+            with self.subTest("parameters"):
+                fer_op = FermionicOp({"+_0": self.a})
+                with self.assertRaisesRegex(ValueError, "parameter"):
+                    _ = fer_op.to_matrix()
 
     def test_normal_order(self):
         """test normal_order method"""
         with self.subTest("Test for creation operator"):
             orig = FermionicOp({"+_0": 1}, num_spin_orbitals=1)
             fer_op = orig.normal_order()
             self.assertEqual(fer_op, orig)
@@ -569,15 +578,17 @@
                 {
                     "+-": np.arange(1, 5).reshape((r_l, r_l)),
                     "++--": np.arange(1, 17).reshape((r_l, r_l, r_l, r_l)),
                 }
             )
             op = FermionicOp.from_polynomial_tensor(p_t)
 
-            self.assertEqual(op @ op, FermionicOp.from_polynomial_tensor(p_t @ p_t))
+            a = op @ op
+            b = FermionicOp.from_polynomial_tensor(p_t @ p_t)
+            self.assertEqual(a, b)
 
         with self.subTest("tensor operation order"):
             r_l = 2
             p_t = PolynomialTensor(
                 {
                     "+-": np.arange(1, 5).reshape((r_l, r_l)),
                     "++--": np.arange(1, 17).reshape((r_l, r_l, r_l, r_l)),
@@ -607,18 +618,21 @@
 
         with self.subTest("Equality"):
             op3 = FermionicOp({"+_0 -_0": 1}, num_spin_orbitals=3)
             self.assertEqual(op1, op3)
             self.assertTrue(op1.equiv(1.000001 * op3))
 
         with self.subTest("to_matrix"):
-            ref = np.array([[0, 0], [0, 1]])
-            np.testing.assert_array_almost_equal(op1.to_matrix(False), ref)
-            op1.num_spin_orbitals = 2
-            np.testing.assert_array_almost_equal(op1.to_matrix(False), np.kron(ref, np.eye(2)))
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore", category=DeprecationWarning)
+
+                ref = np.array([[0, 0], [0, 1]])
+                np.testing.assert_array_almost_equal(op1.to_matrix(False), ref)
+                op1.num_spin_orbitals = 2
+                np.testing.assert_array_almost_equal(op1.to_matrix(False), np.kron(ref, np.eye(2)))
 
-            ref = np.array([[1]])
-            np.testing.assert_array_almost_equal(op0.to_matrix(False), ref)
+                ref = np.array([[1]])
+                np.testing.assert_array_almost_equal(op0.to_matrix(False), ref)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/operators/test_polynomial_tensor.py` & `qiskit-nature-0.6.0/test/second_q/operators/test_polynomial_tensor.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -16,26 +16,33 @@
 
 import unittest
 from test import QiskitNatureTestCase
 
 import numpy as np
 from ddt import ddt, idata
 
-from qiskit_nature.second_q.operators import PolynomialTensor
 import qiskit_nature.optionals as _optionals
+from qiskit_nature.second_q.operators import PolynomialTensor, Tensor
 
 
 @ddt
 class TestPolynomialTensor(QiskitNatureTestCase):
     """Tests for PolynomialTensor class"""
 
     @unittest.skipIf(not _optionals.HAS_SPARSE, "Sparse not available.")
     def setUp(self) -> None:
         super().setUp()
-        import sparse as sp  # pylint: disable=import-error
+        # pylint: disable=import-error
+        import sparse as sp
+
+        self.einsum_funcs = [(np.einsum, False)]
+        if _optionals.HAS_OPT_EINSUM:
+            from opt_einsum import contract
+
+            self.einsum_funcs.append((contract, True))
 
         self.og_poly = {
             "": 1.0,
             "+": self.build_matrix(4, 1),
             "+-": self.build_matrix(4, 2),
             "++--": self.build_matrix(4, 4),
         }
@@ -174,15 +181,15 @@
                 PolynomialTensor({"+": sp.as_coo({(1,): 1}), "+-": np.eye(2)}).is_dense()
             )
 
     def test_get_item(self):
         """Test for getting value matrices corresponding to keys in PolynomialTensor"""
         og_poly_tensor = PolynomialTensor(self.og_poly)
         for key, value in self.og_poly.items():
-            np.testing.assert_array_equal(value, og_poly_tensor[key])
+            np.testing.assert_array_almost_equal(value - og_poly_tensor[key], np.zeros_like(value))
 
     def test_len(self):
         """Test for the length of PolynomialTensor"""
         length = len(
             PolynomialTensor(
                 {
                     "": 1.0,
@@ -283,30 +290,32 @@
             expected["+"][0] += 1
             expected["+"][2] += 2
             expected["+-"][0, 0] += 1
             expected["+-"][1, 0] += 2
             expected["++--"][0, 0, 0, 1] += 1
             expected["++--"][1, 0, 2, 1] += 2
             self.assertEqual(result, PolynomialTensor(expected))
-            self.assertIsInstance(result["+"], np.ndarray)
-            self.assertIsInstance(result["+-"], np.ndarray)
-            self.assertIsInstance(result["++--"], np.ndarray)
+            # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+            self.assertIsInstance(Tensor(result["+"]).array, np.ndarray)
+            self.assertIsInstance(Tensor(result["+-"]).array, np.ndarray)
+            self.assertIsInstance(Tensor(result["++--"]).array, np.ndarray)
 
         with self.subTest("sparse + sparse"):
             result = PolynomialTensor(self.sparse_1) + PolynomialTensor(self.sparse_2)
             expected = {
                 "": 3.0,
                 "+": sp.as_coo({(0,): 1, (1,): 1, (2,): 2}, shape=(4,)),
                 "+-": sp.as_coo({(0, 0): 1, (0, 1): 1, (1, 0): 4}, shape=(4, 4)),
                 "++--": sp.as_coo({(0, 0, 0, 1): 1, (0, 1, 0, 1): 1}, shape=(4, 4, 4, 4)),
             }
             self.assertEqual(result, PolynomialTensor(expected))
-            self.assertIsInstance(result["+"], sp.COO)
-            self.assertIsInstance(result["+-"], sp.COO)
-            self.assertIsInstance(result["++--"], sp.COO)
+            # TODO: remove extra-wrapping of Tensor once settings.tensor_unwrapping is removed
+            self.assertIsInstance(Tensor(result["+"]).array, sp.COO)
+            self.assertIsInstance(Tensor(result["+-"]).array, sp.COO)
+            self.assertIsInstance(Tensor(result["++--"]).array, sp.COO)
 
         with self.assertRaisesRegex(
             TypeError, "Incorrect argument type: other should be PolynomialTensor"
         ):
             _ = PolynomialTensor(self.og_poly) + 5
 
     def test_compose(self):
@@ -735,30 +744,31 @@
                 tensor,
                 coeffs_pt,
                 coeffs_pt,
                 coeffs_pt,
                 coeffs_pt,
             )
 
-            expected = PolynomialTensor(
-                {
-                    "+-": np.dot(np.dot(coeffs.T, one_body), coeffs),
-                    "++--": np.einsum(
-                        "pqrs,pi,qj,rk,sl->ijkl",
-                        two_body,
-                        coeffs,
-                        coeffs,
-                        coeffs,
-                        coeffs,
-                        optimize=True,
-                    ),
-                }
-            )
+            for einsum_func, _ in self.einsum_funcs:
+                expected = PolynomialTensor(
+                    {
+                        "+-": np.dot(np.dot(coeffs.T, one_body), coeffs),
+                        "++--": einsum_func(
+                            "pqrs,pi,qj,rk,sl->ijkl",
+                            two_body,
+                            coeffs,
+                            coeffs,
+                            coeffs,
+                            coeffs,
+                            optimize=True,
+                        ),
+                    }
+                )
 
-            self.assertTrue(result.equiv(expected))
+                self.assertTrue(result.equiv(expected))
 
         with self.subTest("all sparse"):
             one_body = sp.random((2, 2), density=0.5)
             two_body = sp.random((2, 2, 2, 2), density=0.5)
             tensor = PolynomialTensor({"+-": one_body, "++--": two_body})
             coeffs = sp.random((2, 2), density=0.5)
             coeffs_pt = PolynomialTensor({"+-": coeffs})
@@ -771,33 +781,34 @@
                 tensor,
                 coeffs_pt,
                 coeffs_pt,
                 coeffs_pt,
                 coeffs_pt,
             )
 
-            dense_one_body = one_body.todense()
-            dense_two_body = two_body.todense()
-            dense_coeffs = coeffs.todense()
-            expected = PolynomialTensor(
-                {
-                    "+-": np.dot(np.dot(dense_coeffs.T, dense_one_body), dense_coeffs),
-                    "++--": np.einsum(
-                        "pqrs,pi,qj,rk,sl->ijkl",
-                        dense_two_body,
-                        dense_coeffs,
-                        dense_coeffs,
-                        dense_coeffs,
-                        dense_coeffs,
-                        optimize=True,
-                    ),
-                }
-            )
+            for einsum_func, uses_sparse in self.einsum_funcs:
+                list_one_body = one_body if uses_sparse else one_body.todense()
+                list_two_body = two_body if uses_sparse else two_body.todense()
+                list_coeffs = coeffs if uses_sparse else coeffs.todense()
+                expected = PolynomialTensor(
+                    {
+                        "+-": np.dot(np.dot(list_coeffs.T, list_one_body), list_coeffs),
+                        "++--": einsum_func(
+                            "pqrs,pi,qj,rk,sl->ijkl",
+                            list_two_body,
+                            list_coeffs,
+                            list_coeffs,
+                            list_coeffs,
+                            list_coeffs,
+                            optimize=True,
+                        ),
+                    }
+                )
 
-            self.assertTrue(result.equiv(expected))
+                self.assertTrue(result.equiv(expected))
 
         with self.subTest("mixed"):
             one_body = sp.random((2, 2), density=0.5)
             two_body = sp.random((2, 2, 2, 2), density=0.5)
             tensor = PolynomialTensor({"+-": one_body, "++--": two_body})
             coeffs = np.random.random((2, 2))
             coeffs_pt = PolynomialTensor({"+-": coeffs})
@@ -810,29 +821,30 @@
                 tensor,
                 coeffs_pt,
                 coeffs_pt,
                 coeffs_pt,
                 coeffs_pt,
             )
 
-            dense_one_body = one_body.todense()
-            dense_two_body = two_body.todense()
-            expected = PolynomialTensor(
-                {
-                    "+-": np.dot(np.dot(coeffs.T, dense_one_body), coeffs),
-                    "++--": np.einsum(
-                        "pqrs,pi,qj,rk,sl->ijkl",
-                        dense_two_body,
-                        coeffs,
-                        coeffs,
-                        coeffs,
-                        coeffs,
-                        optimize=True,
-                    ),
-                }
-            )
+            for einsum_func, uses_sparse in self.einsum_funcs:
+                list_one_body = one_body if uses_sparse else one_body.todense()
+                list_two_body = two_body if uses_sparse else two_body.todense()
+                expected = PolynomialTensor(
+                    {
+                        "+-": np.dot(np.dot(coeffs.T, list_one_body), coeffs),
+                        "++--": einsum_func(
+                            "pqrs,pi,qj,rk,sl->ijkl",
+                            list_two_body,
+                            coeffs,
+                            coeffs,
+                            coeffs,
+                            coeffs,
+                            optimize=True,
+                        ),
+                    }
+                )
 
-            self.assertTrue(result.equiv(expected))
+                self.assertTrue(result.equiv(expected))
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/operators/test_sparse_label_op.py` & `qiskit-nature-0.6.0/test/second_q/operators/test_sparse_label_op.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -151,14 +151,26 @@
                     "+_0 -_2": 1.0,
                     "+_0 -_3": 3.0,
                 },
             )
 
             self.assertEqual(test_op, target_op)
 
+        with self.subTest("sum"):
+            test_op = sum([DummySparseLabelOp(op1), DummySparseLabelOp(op3)])
+            target_op = DummySparseLabelOp(
+                {
+                    "+_0 -_1": 0.5,
+                    "+_0 -_2": 1.0,
+                    "+_0 -_3": 3.0,
+                },
+            )
+
+            self.assertEqual(test_op, target_op)
+
     def test_mul(self):
         """Test scalar multiplication method"""
         with self.subTest("real * real"):
             test_op = DummySparseLabelOp(op1) * 2
             target_op = DummySparseLabelOp(
                 {
                     "+_0 -_1": 0.0,
@@ -414,14 +426,26 @@
     def test_assign_parameters(self):
         """Test assign_parameters."""
         op = DummySparseLabelOp({"+_0 -_1": a, "+_0 -_2": b})
         assigned_op = op.assign_parameters({a: 1.0})
         self.assertEqual(assigned_op, DummySparseLabelOp({"+_0 -_1": 1.0, "+_0 -_2": b}))
         self.assertEqual(op, DummySparseLabelOp({"+_0 -_1": a, "+_0 -_2": b}))
 
+        op = DummySparseLabelOp({"+_0 -_1": a + 1}) + DummySparseLabelOp({"+_1 -_0": a})
+        assigned_op = op.assign_parameters({a: 1})
+        self.assertEqual(assigned_op, DummySparseLabelOp({"+_0 -_1": 2, "+_1 -_0": 1}))
+
+        op = DummySparseLabelOp({"+_0 -_1": a + 1}) + DummySparseLabelOp({"+_1 -_0": b})
+        assigned_op = op.assign_parameters({a: 1})
+        self.assertEqual(assigned_op, DummySparseLabelOp({"+_0 -_1": 2, "+_1 -_0": b}))
+
+        op = DummySparseLabelOp({"+_0 -_1": a + 1})
+        assigned_op = op.assign_parameters({b: 1})
+        self.assertEqual(assigned_op, op)
+
     def test_round(self):
         """test round function"""
         with self.subTest("round just real part"):
             data = {
                 "+_0 -_1": 0.7 + 3j,
                 "+_0 -_3": 1.1 + 4j,
             }
@@ -551,14 +575,20 @@
                 {
                     "+_0 -_1": 0.05,
                     "+_0 -_3": 0.0,
                 }
             )
             self.assertFalse(test_op.is_zero(tol=0.001))
 
+        with self.subTest("parameterized coefficient"):
+            test_op = DummySparseLabelOp({"+_0 -_1": a})
+            self.assertFalse(test_op.is_zero())
+            bound_op = test_op.assign_parameters({a: 0.0})
+            self.assertTrue(bound_op.is_zero())
+
     def test_parameters(self):
         """Test parameters."""
         op = DummySparseLabelOp({"+_0 -_1": a, "+_0 -_2": b})
         self.assertEqual(op.parameters(), [a, b])
 
 
 if __name__ == "__main__":
```

### Comparing `qiskit-nature-0.5.2/test/second_q/operators/test_spin_op.py` & `qiskit-nature-0.6.0/test/second_q/operators/test_spin_op.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -62,14 +62,19 @@
 
     def test_add(self):
         """Test __add__"""
         spin_op = self.op1 + self.op2
         targ = self.op3
         self.assertEqual(spin_op, targ)
 
+        with self.subTest("sum"):
+            spin_op = sum(SpinOp({label: 1}, num_spins=3) for label in ["X_0", "Z_1", "X_2 Z_2"])
+            targ = SpinOp({"X_0": 1, "Z_1": 1, "X_2 Z_2": 1})
+            self.assertEqual(spin_op, targ)
+
     def test_sub(self):
         """Test __sub__"""
         spin_op = self.op3 - self.op2
         targ = SpinOp({"X_0 Y_0": 1, "X_0^2 Z_0": 0}, num_spins=1)
         self.assertEqual(spin_op, targ)
 
     def test_simplify(self):
```

### Comparing `qiskit-nature-0.5.2/test/second_q/operators/test_tensor_ordering.py` & `qiskit-nature-0.6.0/test/second_q/operators/test_tensor_ordering.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/operators/test_vibrational_op.py` & `qiskit-nature-0.6.0/test/second_q/operators/test_vibrational_op.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -74,14 +74,22 @@
 
     def test_add(self):
         """Test __add__"""
         vib_op = self.op1 + self.op2
         targ = self.op3
         self.assertEqual(vib_op, targ)
 
+        with self.subTest("sum"):
+            vib_op = sum(
+                VibrationalOp({label: 1}, num_modals=[1, 1, 1])
+                for label in ["+_0_0", "-_1_0", "+_2_0 -_2_0"]
+            )
+            targ = VibrationalOp({"+_0_0": 1, "-_1_0": 1, "+_2_0 -_2_0": 1})
+            self.assertEqual(vib_op, targ)
+
     def test_sub(self):
         """Test __sub__"""
         vib_op = self.op3 - self.op2
         targ = VibrationalOp({"+_0_0 -_0_0": 1, "-_0_0 +_0_0": 0}, num_modals=[1])
         self.assertEqual(vib_op, targ)
 
     def test_compose(self):
@@ -105,14 +113,31 @@
                     "+_0_0 +_1_0 -_0_0": 1,
                     "-_0_0 -_1_0 +_1_0": 1,
                 },
                 num_modals=[1, 1],
             )
             self.assertEqual(vib_op, targ)
 
+        with self.subTest("creation commutation relation"):
+            op1 = VibrationalOp({"+_0_0": 1}, num_modals=[1])
+            comm = (op1 @ op1 - op1 @ op1).normal_order()
+            self.assertTrue(comm.is_zero())
+
+        with self.subTest("annihilation commutation relation"):
+            op1 = VibrationalOp({"-_0_0": 1}, num_modals=[1])
+            comm = (op1 @ op1 - op1 @ op1).normal_order()
+            self.assertTrue(comm.is_zero())
+
+        with self.subTest("mixed commutation relation"):
+            op1 = VibrationalOp({"-_0_0": 1}, num_modals=[1])
+            op2 = VibrationalOp({"+_0_0": 1}, num_modals=[1])
+            comm = (op1 @ op2 - op2 @ op1).normal_order()
+            targ = VibrationalOp({"": 1})
+            self.assertEqual(comm, targ)
+
     def test_tensor(self):
         """Test tensor multiplication"""
         vib_op = self.op1.tensor(self.op2)
         targ = VibrationalOp({"+_0_0 -_0_0 -_1_0 +_1_0": 2}, num_modals=[1, 1])
         self.assertEqual(vib_op, targ)
 
     def test_expand(self):
@@ -243,27 +268,27 @@
             orig = VibrationalOp({"+_0_0 -_0_0": 1})
             vib_op = orig.normal_order()
             self.assertEqual(vib_op, orig)
 
         with self.subTest("Test for empty operator"):
             orig = VibrationalOp({"-_0_0 +_0_0": 1})
             vib_op = orig.normal_order()
-            targ = VibrationalOp({"+_0_0 -_0_0": 1})
+            targ = VibrationalOp({"": 1, "+_0_0 -_0_0": 1})
             self.assertEqual(vib_op, targ)
 
         with self.subTest("Test for multiple operators 1"):
             orig = VibrationalOp({"-_0_0 +_1_0": 1})
             vib_op = orig.normal_order()
             targ = VibrationalOp({"+_1_0 -_0_0": 1})
             self.assertEqual(vib_op, targ)
 
         with self.subTest("Test for multiple operators 2"):
             orig = VibrationalOp({"-_0_0 +_0_0 +_1_0 -_2_0": 1})
             vib_op = orig.normal_order()
-            targ = VibrationalOp({"+_0_0 +_1_0 -_0_0 -_2_0": 1})
+            targ = VibrationalOp({"+_1_0 -_2_0": 1, "+_0_0 +_1_0 -_0_0 -_2_0": 1})
             self.assertEqual(vib_op, targ)
 
         with self.subTest("Test normal ordering simplifies"):
             orig = VibrationalOp({"-_0_0 +_1_0": 1, "+_1_0 -_0_0": 1, "+_0_0": 0.0})
             vib_op = orig.normal_order()
             targ = VibrationalOp({"+_1_0 -_0_0": 2})
             self.assertEqual(vib_op, targ)
```

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/resources/H2_631g_ferm_op.json` & `qiskit-nature-0.6.0/test/second_q/problems/resources/H2_631g_ferm_op.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/resources/H2_631g_ferm_op_active_space.json` & `qiskit-nature-0.6.0/test/second_q/problems/resources/H2_631g_ferm_op_active_space.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/resources/expected_ops.py` & `qiskit-nature-0.6.0/test/second_q/problems/resources/expected_ops.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_eigenstate_result.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_eigenstate_result.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_electronic_properties_container.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_electronic_properties_container.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_electronic_structure_problem.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_electronic_structure_problem.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,28 +1,34 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Tests Electronic Structure Problem."""
 import unittest
+import warnings
 from test import QiskitNatureTestCase
 
 import json
 import numpy as np
 
+from qiskit.opflow import PauliSumOp
+from qiskit.opflow.primitive_ops import Z2Symmetries
+from qiskit.quantum_info.analysis.z2_symmetries import Z2Symmetries as Z2SparseSymmetries
+
 import qiskit_nature.optionals as _optionals
 from qiskit_nature.second_q.drivers import PySCFDriver
+from qiskit_nature.second_q.mappers import JordanWignerMapper
 from qiskit_nature.second_q.operators import SparseLabelOp
 from qiskit_nature.second_q.transformers import ActiveSpaceTransformer
 
 
 class TestElectronicStructureProblem(QiskitNatureTestCase):
     """Tests Electronic Structure Problem."""
 
@@ -81,10 +87,37 @@
                 assert isinstance(second_quantized_op, SparseLabelOp)
         with self.subTest("Check components of electronic second quantized operator."):
             assert all(
                 s[0] == t[0] and np.isclose(np.abs(s[1]), np.abs(t[1]))
                 for s, t in zip(sorted(expected.items()), sorted(electr_sec_quant_op.items()))
             )
 
+    @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
+    def test_symmetry_sector_locator(self):
+        """Tests that the symmetry sector locator gives the right sector."""
+        driver = PySCFDriver()
+        electronic_structure_problem = driver.run()
+        hamiltonian, _ = electronic_structure_problem.second_q_ops()
+        mapper = JordanWignerMapper()
+        mapped_op = mapper.map(hamiltonian)
+        expected_sector = [-1, 1, -1]
+
+        with self.subTest("Opflow Z2Symmetries"):
+            if isinstance(mapped_op, PauliSumOp):
+                mapped_op = mapped_op.primitive
+            z2sym = Z2SparseSymmetries.find_z2_symmetries(mapped_op)
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore", category=DeprecationWarning)
+                sector = electronic_structure_problem.symmetry_sector_locator(z2sym, mapper)
+            self.assertEqual(sector, expected_sector)
+        with self.subTest("Opflow Z2Symmetries"):
+            if not isinstance(mapped_op, PauliSumOp):
+                mapped_op = PauliSumOp(mapped_op)
+            z2sym = Z2Symmetries.find_Z2_symmetries(mapped_op)
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore", category=DeprecationWarning)
+                sector = electronic_structure_problem.symmetry_sector_locator(z2sym, mapper)
+            self.assertEqual(sector, expected_sector)
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_electronic_structure_result.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_electronic_structure_result.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Tests for the ElectronicStructureResult."""
 
-import unittest
 import contextlib
 import io
+import unittest
 from itertools import zip_longest
 from test import QiskitNatureTestCase
 
 import numpy as np
 
 from qiskit_nature.second_q.problems import ElectronicStructureResult
 
@@ -54,14 +54,15 @@
               - computed part:      0.0+1.j
         """
         self._assert_printed_result(res)
 
     def test_print_complex_dipole(self):
         """Test printing complex dipoles."""
         res = ElectronicStructureResult()
+        res.formatting_precision = 8
         res.computed_energies = np.asarray([1.0])
         res.nuclear_dipole_moment = (0.0, 0.0, 1.0)
         res.computed_dipole_moment = [(0.0, 0.0, 1.0j)]
         res.extracted_transformer_dipoles = [{}]
         self.expected = """\
             === GROUND STATE ENERGY ===
 
@@ -76,10 +77,16 @@
               * Electronic dipole moment (a.u.): [0.0  0.0  0.0+1.j]
                 - computed part:      [0.0  0.0  0.0+1.j]
               > Dipole moment (a.u.): [0.0  0.0  1.+1.j]  Total: 1.+1.j
                              (debye): [0.0  0.0  2.54174623+2.54174623j]  Total: 2.54174623+2.54174623j
         """
         self._assert_printed_result(res)
 
+    def test_print_debye_dipole(self):
+        """Test printing debye dipoles."""
+        res = ElectronicStructureResult()
+        res.computed_dipole_moment = None
+        self.assertIsNone(res.total_dipole_moment_in_debye)
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_lattice_model_problem.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_lattice_model_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_lattice_properties_container.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_lattice_properties_container.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_properties_container.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_properties_container.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_vibrational_properties_container.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_vibrational_properties_container.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/problems/test_vibrational_structure_problem.py` & `qiskit-nature-0.6.0/test/second_q/problems/test_vibrational_structure_problem.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/properties/property_test.py` & `qiskit-nature-0.6.0/test/second_q/properties/property_test.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/properties/resources/angular_momentum_op.json` & `qiskit-nature-0.6.0/test/second_q/properties/resources/angular_momentum_op.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/properties/resources/vibrational_energy_op.json` & `qiskit-nature-0.6.0/test/second_q/properties/resources/vibrational_energy_op.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/properties/test_angular_momentum.py` & `qiskit-nature-0.6.0/test/second_q/properties/test_angular_momentum.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/properties/test_dipole_moment.py` & `qiskit-nature-0.6.0/test/second_q/properties/test_dipole_moment.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/properties/test_magnetization.py` & `qiskit-nature-0.6.0/test/second_q/properties/test_magnetization.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/properties/test_occupied_modals.py` & `qiskit-nature-0.6.0/test/second_q/properties/test_occupied_modals.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/properties/test_particle_number.py` & `qiskit-nature-0.6.0/test/second_q/properties/test_particle_number.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/transformers/resources/BeH_sto3g_reduced.json` & `qiskit-nature-0.6.0/test/second_q/transformers/resources/BeH_sto3g_reduced.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/transformers/resources/LiH_sto3g_reduced.json` & `qiskit-nature-0.6.0/test/second_q/transformers/resources/LiH_sto3g_reduced.json`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/second_q/transformers/test_active_space_transformer.py` & `qiskit-nature-0.6.0/test/second_q/transformers/test_active_space_transformer.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,65 +1,74 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Tests for the ActiveSpaceTransformer."""
 
 import unittest
 
 from test import QiskitNatureTestCase
+from test.second_q.utils import get_expected_two_body_ints
 
 from ddt import ddt, idata, unpack
 import numpy as np
 
 import qiskit_nature.optionals as _optionals
 from qiskit_nature import QiskitNatureError
 from qiskit_nature.second_q.drivers import PySCFDriver
 from qiskit_nature.second_q.formats.qcschema import QCSchema
 from qiskit_nature.second_q.formats.qcschema_translator import qcschema_to_problem
 from qiskit_nature.second_q.hamiltonians import ElectronicEnergy
 from qiskit_nature.second_q.operators import ElectronicIntegrals
+from qiskit_nature.second_q.operators.tensor_ordering import to_chemist_ordering
 from qiskit_nature.second_q.problems import ElectronicStructureProblem
 from qiskit_nature.second_q.properties import ElectronicDensity, ElectronicDipoleMoment
 from qiskit_nature.second_q.transformers import ActiveSpaceTransformer
 
 
 @ddt
 class TestActiveSpaceTransformer(QiskitNatureTestCase):
     """ActiveSpaceTransformer tests."""
 
-    def assertDriverResult(self, driver_result, expected):
-        """Asserts that the two `DriverResult` object's relevant fields are equivalent."""
-        electronic_energy = driver_result.hamiltonian
-        electronic_energy_exp = expected.hamiltonian
+    def assertElectronicEnergy(self, electronic_energy, expected):
+        """Assets that the two ``ElectronicEnergy`` object's relevant fields are equivalent."""
         with self.subTest("MO 1-electron integrals"):
             np.testing.assert_array_almost_equal(
                 np.abs(electronic_energy.electronic_integrals.second_q_coeffs()["+-"]),
-                np.abs(electronic_energy_exp.electronic_integrals.second_q_coeffs()["+-"]),
+                np.abs(expected.electronic_integrals.second_q_coeffs()["+-"]),
             )
         with self.subTest("MO 2-electron integrals"):
+            actual_ints = electronic_energy.electronic_integrals.second_q_coeffs()["++--"]
+            expected_ints = get_expected_two_body_ints(
+                actual_ints,
+                to_chemist_ordering(expected.electronic_integrals.second_q_coeffs()["++--"]),
+            )
             np.testing.assert_array_almost_equal(
-                np.abs(electronic_energy.electronic_integrals.second_q_coeffs()["++--"]),
-                np.abs(electronic_energy_exp.electronic_integrals.second_q_coeffs()["++--"]),
+                np.abs(actual_ints),
+                np.abs(expected_ints),
             )
         with self.subTest("Inactive energy"):
-            for key in electronic_energy_exp.constants.keys():
+            for key in expected.constants.keys():
                 self.assertAlmostEqual(
                     electronic_energy.constants[key],
-                    electronic_energy_exp.constants[key],
+                    expected.constants[key],
                 )
 
+    def assertDriverResult(self, driver_result, expected):
+        """Asserts that the two ``DriverResult`` object's relevant fields are equivalent."""
+        self.assertElectronicEnergy(driver_result.hamiltonian, expected.hamiltonian)
+
         if expected.properties.electronic_dipole_moment is not None:
             dip_moment = driver_result.properties.electronic_dipole_moment
             exp_moment = expected.properties.electronic_dipole_moment
             with self.subTest("Integrals"):
                 for dipole, dipole_exp in zip(
                     (dip_moment.x_dipole, dip_moment.y_dipole, dip_moment.z_dipole),
                     (exp_moment.x_dipole, exp_moment.y_dipole, exp_moment.z_dipole),
@@ -235,16 +244,14 @@
 
     @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
     @idata(
         [
             [2, 3, None, "More active orbitals requested than available in total."],
             [4, 2, None, "More active electrons requested than available in total."],
             [(1, 0), 2, None, "The number of inactive electrons may not be odd."],
-            [2, 2, [0, 1, 2], "The number of active orbitals do not match."],
-            [2, 2, [1, 2], "The number of active electrons do not match."],
             [1, 2, None, "The number of active electrons must be even when not a tuple."],
             [-2, 2, None, "The number of active electrons must not be negative."],
         ]
     )
     @unpack
     def test_error_raising(self, num_electrons, num_spatial_orbitals, active_orbitals, message):
         """Test errors are being raised in certain scenarios."""
@@ -314,10 +321,45 @@
             np.int64(driver_result.num_alpha),
             np.int64(driver_result.num_beta),
         )
 
         trafo = ActiveSpaceTransformer(driver_result.num_particles, 2)
         _ = trafo.transform(driver_result)
 
+    @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
+    def test_standalone_usage(self):
+        """Test usage on a standalone Hamiltonian."""
+        driver = PySCFDriver(basis="631g")
+        problem = driver.run()
+
+        trafo = ActiveSpaceTransformer(2, 2)
+
+        with self.subTest("prepare_active_space not called yet"):
+            with self.assertRaises(QiskitNatureError):
+                reduced_hamiltonian = trafo.transform_hamiltonian(problem.hamiltonian)
+
+        trafo.prepare_active_space(problem.num_particles, problem.num_spatial_orbitals)
+
+        reduced_hamiltonian = trafo.transform_hamiltonian(problem.hamiltonian)
+
+        electronic_energy = ElectronicEnergy.from_raw_integrals(
+            np.asarray([[-1.24943841, 0.0], [0.0, -0.547816138]]),
+            np.asarray(
+                [
+                    [
+                        [[0.652098466, 0.0], [0.0, 0.433536565]],
+                        [[0.0, 0.0794483182], [0.0794483182, 0.0]],
+                    ],
+                    [
+                        [[0.0, 0.0794483182], [0.0794483182, 0.0]],
+                        [[0.433536565, 0.0], [0.0, 0.385524695]],
+                    ],
+                ]
+            ),
+        )
+        electronic_energy.constants["ActiveSpaceTransformer"] = 0.0
+
+        self.assertElectronicEnergy(reduced_hamiltonian, electronic_energy)
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/second_q/transformers/test_basis_transformer.py` & `qiskit-nature-0.6.0/test/second_q/transformers/test_basis_transformer.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -19,24 +19,25 @@
 
 import numpy as np
 
 import qiskit_nature.optionals as _optionals
 from qiskit_nature.second_q.drivers import PySCFDriver, MethodType
 from qiskit_nature.second_q.formats.qcschema_translator import get_ao_to_mo_from_qcschema
 from qiskit_nature.second_q.hamiltonians import ElectronicEnergy
+from qiskit_nature.second_q.operators.symmetric_two_body import SymmetricTwoBodyIntegrals
 from qiskit_nature.second_q.problems import ElectronicBasis
 
 
 class TestBasisTransformer(QiskitNatureTestCase):
     """BasisTransformer tests."""
 
     @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
     def test_restricted_spin(self):
         """A simple restricted-spin test case."""
-        driver = PySCFDriver(atom="H 0 0 0; H 0 0 0.735", method=MethodType.RKS)
+        driver = PySCFDriver(atom="H 0 0 0; H 0 0 0.735", method=MethodType.RHF)
         driver.run_pyscf()
         mo_coeff = driver._calc.mo_coeff
 
         problem_ao = driver.to_problem(basis=ElectronicBasis.AO)
         qcschema = driver.to_qcschema()
 
         trafo = get_ao_to_mo_from_qcschema(qcschema)
@@ -60,18 +61,22 @@
         with self.subTest("one-body alpha-spin"):
             np.testing.assert_array_almost_equal(
                 transformed_integrals.alpha["+-"],
                 np.dot(np.dot(mo_coeff.T, driver._calc.get_hcore()), mo_coeff),
             )
 
         with self.subTest("two-body alpha-spin"):
+            two_body_aa = transformed_integrals.alpha["++--"]
+            einsum = "pqrs,pi,qj,rk,sl->iklj"
+            if isinstance(two_body_aa, SymmetricTwoBodyIntegrals):
+                einsum = "pqrs,pi,qj,rk,sl->ijkl"
             np.testing.assert_array_almost_equal(
-                transformed_integrals.alpha["++--"],
+                two_body_aa,
                 np.einsum(
-                    "pqrs,pi,qj,rk,sl->iklj",
+                    einsum,
                     driver._mol.intor("int2e", aosym=1),
                     *(mo_coeff,) * 4,
                     optimize=True,
                 ),
             )
 
         with self.subTest("beta-spin is empty"):
@@ -88,15 +93,15 @@
             self.assertIsNone(problem_mo.orbital_energies)
             self.assertIsNone(problem_mo.orbital_energies_b)
             # orbital_occupations are not tested since in the MO basis they are auto-filled
 
     @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
     def test_unrestricted_spin(self):
         """A simple unrestricted-spin test case."""
-        driver = PySCFDriver(atom="O 0 0 0; H 0 0 0.9697", spin=1, method=MethodType.UKS)
+        driver = PySCFDriver(atom="O 0 0 0; H 0 0 0.9697", spin=1, method=MethodType.UHF)
         driver.run_pyscf()
         mo_coeff, mo_coeff_b = driver._calc.mo_coeff
 
         problem_ao = driver.to_problem(basis=ElectronicBasis.AO)
         qcschema = driver.to_qcschema()
 
         trafo = get_ao_to_mo_from_qcschema(qcschema)
@@ -120,46 +125,58 @@
         with self.subTest("one-body alpha-spin"):
             np.testing.assert_array_almost_equal(
                 transformed_integrals.alpha["+-"],
                 np.dot(np.dot(mo_coeff.T, driver._calc.get_hcore()), mo_coeff),
             )
 
         with self.subTest("two-body alpha-spin"):
+            two_body_aa = transformed_integrals.alpha["++--"]
+            einsum = "pqrs,pi,qj,rk,sl->iklj"
+            if isinstance(two_body_aa, SymmetricTwoBodyIntegrals):
+                einsum = "pqrs,pi,qj,rk,sl->ijkl"
             np.testing.assert_array_almost_equal(
-                transformed_integrals.alpha["++--"],
+                two_body_aa,
                 np.einsum(
-                    "pqrs,pi,qj,rk,sl->iklj",
+                    einsum,
                     driver._mol.intor("int2e", aosym=1),
                     *(mo_coeff,) * 4,
                     optimize=True,
                 ),
             )
 
         with self.subTest("one-body beta-spin"):
             np.testing.assert_array_almost_equal(
                 transformed_integrals.beta["+-"],
                 np.dot(np.dot(mo_coeff_b.T, driver._calc.get_hcore()), mo_coeff_b),
             )
 
         with self.subTest("two-body beta-spin"):
+            two_body_bb = transformed_integrals.beta["++--"]
+            einsum = "pqrs,pi,qj,rk,sl->iklj"
+            if isinstance(two_body_bb, SymmetricTwoBodyIntegrals):
+                einsum = "pqrs,pi,qj,rk,sl->ijkl"
             np.testing.assert_array_almost_equal(
-                transformed_integrals.beta["++--"],
+                two_body_bb,
                 np.einsum(
-                    "pqrs,pi,qj,rk,sl->iklj",
+                    einsum,
                     driver._mol.intor("int2e", aosym=1),
                     *(mo_coeff_b,) * 4,
                     optimize=True,
                 ),
             )
 
         with self.subTest("two-body beta-alpha-spin"):
+            two_body_ba = transformed_integrals.beta_alpha["++--"]
+            einsum = "pqrs,pi,qj,rk,sl->iklj"
+            if isinstance(two_body_ba, SymmetricTwoBodyIntegrals):
+                einsum = "pqrs,pi,qj,rk,sl->ijkl"
             np.testing.assert_array_almost_equal(
-                transformed_integrals.beta_alpha["++--"],
+                two_body_ba,
                 np.einsum(
-                    "pqrs,pi,qj,rk,sl->iklj",
+                    einsum,
                     driver._mol.intor("int2e", aosym=1),
                     *(mo_coeff_b,) * 2,
                     *(mo_coeff,) * 2,
                     optimize=True,
                 ),
             )
```

### Comparing `qiskit-nature-0.5.2/test/second_q/transformers/test_freeze_core_transformer.py` & `qiskit-nature-0.6.0/test/second_q/transformers/test_freeze_core_transformer.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,44 +1,48 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """Tests for the FreezeCoreTransformer."""
 
 import unittest
 
 from test import QiskitNatureTestCase
+from test.second_q.utils import get_expected_two_body_ints
+
 from ddt import ddt, idata
 import numpy as np
 
 import qiskit_nature.optionals as _optionals
+from qiskit_nature import QiskitNatureError
 from qiskit_nature.second_q.drivers import PySCFDriver
 from qiskit_nature.second_q.formats.qcschema import QCSchema
 from qiskit_nature.second_q.formats.qcschema_translator import qcschema_to_problem
+from qiskit_nature.second_q.operators.tensor_ordering import to_chemist_ordering
 from qiskit_nature.second_q.transformers import FreezeCoreTransformer
 
 
 @ddt
 class TestFreezeCoreTransformer(QiskitNatureTestCase):
     """FreezeCoreTransformer tests."""
 
-    # pylint: disable=import-outside-toplevel
     from test.second_q.transformers.test_active_space_transformer import (
         TestActiveSpaceTransformer,
     )
 
     assertDriverResult = TestActiveSpaceTransformer.assertDriverResult
+    assertElectronicEnergy = TestActiveSpaceTransformer.assertElectronicEnergy
 
     @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
     @idata(
         [
             {"freeze_core": True},
         ]
     )
@@ -115,17 +119,51 @@
         electronic_energy_exp = driver_result.hamiltonian
         with self.subTest("MO 1-electron integrals"):
             np.testing.assert_array_almost_equal(
                 np.abs(electronic_energy.electronic_integrals.second_q_coeffs()["+-"]),
                 np.abs(electronic_energy_exp.electronic_integrals.second_q_coeffs()["+-"]),
             )
         with self.subTest("MO 2-electron integrals"):
+            actual_ints = electronic_energy.electronic_integrals.second_q_coeffs()["++--"]
+            expected_ints = get_expected_two_body_ints(
+                actual_ints,
+                to_chemist_ordering(
+                    electronic_energy_exp.electronic_integrals.second_q_coeffs()["++--"]
+                ),
+            )
             np.testing.assert_array_almost_equal(
-                np.abs(electronic_energy.electronic_integrals.second_q_coeffs()["++--"]),
-                np.abs(electronic_energy_exp.electronic_integrals.second_q_coeffs()["++--"]),
+                np.abs(actual_ints),
+                np.abs(expected_ints),
             )
         with self.subTest("Inactive energy"):
             self.assertAlmostEqual(electronic_energy.constants["FreezeCoreTransformer"], 0.0)
 
+    @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
+    def test_standalone_usage(self):
+        """Test usage on a standalone Hamiltonian."""
+        driver = PySCFDriver(atom="Li 0 0 0; H 0 0 1.6")
+        problem = driver.run()
+
+        trafo = FreezeCoreTransformer()
+
+        with self.subTest("prepare_active_space not called yet"):
+            with self.assertRaises(QiskitNatureError):
+                reduced_hamiltonian = trafo.transform_hamiltonian(problem.hamiltonian)
+
+        trafo.prepare_active_space(problem.molecule, problem.num_spatial_orbitals)
+
+        reduced_hamiltonian = trafo.transform_hamiltonian(problem.hamiltonian)
+
+        expected = qcschema_to_problem(
+            QCSchema.from_json(
+                self.get_resource_path("LiH_sto3g_reduced.json", "second_q/transformers/resources")
+            ),
+            include_dipole=False,
+        )
+        # add energy shift, which currently cannot be stored in the QCSchema
+        expected.hamiltonian.constants["FreezeCoreTransformer"] = -7.796219568771229
+
+        self.assertElectronicEnergy(reduced_hamiltonian, expected.hamiltonian)
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/test_deprecation.py` & `qiskit-nature-0.6.0/test/test_deprecation.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,36 +1,38 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2021, 2022.
+# (C) Copyright IBM 2021, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
 # that they have been altered from the originals.
 
 """
 Test The deprecation methods
 """
 
+from __future__ import annotations
+
 import unittest
 import sys
 import inspect
 import warnings
-from typing import Tuple, Optional
 from test import QiskitNatureTestCase
 from ddt import data, ddt
 from qiskit_nature.deprecation import (
     DeprecatedEnum,
     DeprecatedEnumMeta,
     DeprecatedType,
     warn_deprecated,
     warn_deprecated_same_type_name,
+    warn_deprecated_type,
     deprecate_function,
     deprecate_property,
     deprecate_method,
     deprecate_arguments,
     deprecate_values,
     deprecate_positional_arguments,
 )
@@ -60,15 +62,15 @@
 @deprecate_function("0.2.0", new_name="some_function2")
 def func2(arg2: int) -> int:
     """function 2"""
     return arg2
 
 
 @deprecate_arguments("0.1.2", {"old_arg": "new_arg"})
-def func3(new_arg: Optional[int] = None, old_arg: Optional[int] = None) -> Tuple[int, int]:
+def func3(new_arg: int | None = None, old_arg: int | None = None) -> tuple[int, int]:
     """function 3"""
     return new_arg, old_arg
 
 
 class DeprecatedClass1:
     """Deprecated Test class 1"""
 
@@ -114,14 +116,25 @@
 
     @deprecate_values("0.2.0", {"status": {3: 2, 4: 5}})
     def method1(self, status: int = 2) -> None:
         """method 1"""
         self.status = status
 
 
+class DeprecatedClass5:
+    """Deprecated Test class 5"""
+
+    def __init__(self, value: int | str):
+        if isinstance(value, str):
+            warn_deprecated_type("0.6.0", "value", "str", "int")
+            self.value = int(value)
+        else:
+            self.value = value
+
+
 @deprecate_positional_arguments(
     version="0.1",
     func_name="function_positional",
     old_function_arguments=["a", "b", "c", "d"],
     stack_level=2,
 )
 def function_positional(
@@ -164,17 +177,15 @@
 
     @deprecate_method("0.2.0", new_name="some_method2")
     def method2(self, arg: int) -> int:
         """method 2"""
         return arg
 
     @deprecate_arguments("0.1.2", {"old_arg": "new_arg"})
-    def method3(
-        self, new_arg: Optional[int] = None, old_arg: Optional[int] = None
-    ) -> Tuple[int, int]:
+    def method3(self, new_arg: int | None = None, old_arg: int | None = None) -> tuple[int, int]:
         """method3"""
         return new_arg, old_arg
 
 
 @ddt
 class TestDeprecation(QiskitNatureTestCase):
     """Test deprecation methods"""
@@ -477,14 +488,38 @@
 
         # trying again should not emit deprecation
         with warnings.catch_warnings(record=True) as c_m:
             warnings.simplefilter("always")
             self.assertEqual(("hello", None), obj.method3(old_arg="hello"))
             self.assertListEqual(c_m, [])
 
+    def test_method_argument_type_deprecation(self):
+        """test method argument type deprecation"""
+
+        msg_ref = (
+            "The str type in the 'value' argument is deprecated as of version 0.6.0 "
+            "and will be removed no sooner than 3 months after the release. "
+            "Instead use the int type."
+        )
+
+        # emit deprecation the first time it is used
+        with warnings.catch_warnings(record=True) as c_m:
+            warnings.simplefilter("always")
+            _ = DeprecatedClass5("10")
+            msg = str(c_m[0].message)
+            self.assertEqual(msg, msg_ref)
+            self.assertTrue("test_deprecation.py" in c_m[0].filename, c_m[0].filename)
+            self.assertEqual(self._get_line_from_str('DeprecatedClass5("10")'), c_m[0].lineno)
+
+        # trying again should not emit deprecation
+        with warnings.catch_warnings(record=True) as c_m:
+            warnings.simplefilter("always")
+            _ = DeprecatedClass5("10")
+            self.assertListEqual(c_m, [])
+
     def test_property_deprecation(self):
         """test property deprecation"""
 
         obj = TestClass()
 
         msg_ref = (
             "The property1 property is deprecated as of version 0.1.0 "
```

### Comparing `qiskit-nature-0.5.2/test/test_end2end_with_vqe.py` & `qiskit-nature-0.6.0/test/test_end2end_with_vqe.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2018, 2022.
+# (C) Copyright IBM 2018, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -12,19 +12,19 @@
 
 """ Test End to End with VQE """
 
 import unittest
 
 from test import QiskitNatureDeprecatedTestCase
 
-from qiskit import BasicAer
-from qiskit.algorithms import VQE
+from qiskit.algorithms.minimum_eigensolvers import VQE
 from qiskit.algorithms.optimizers import COBYLA
 from qiskit.circuit.library import TwoLocal
-from qiskit.utils import algorithm_globals, QuantumInstance
+from qiskit.primitives import Estimator
+from qiskit.utils import algorithm_globals
 import qiskit_nature.optionals as _optionals
 from qiskit_nature.second_q.drivers import PySCFDriver
 from qiskit_nature.second_q.mappers import ParityMapper, QubitConverter
 
 
 @unittest.skipIf(not _optionals.HAS_PYSCF, "pyscf not available.")
 class TestEnd2End(QiskitNatureDeprecatedTestCase):
@@ -41,19 +41,16 @@
         num_particles = problem.num_particles
         self.qubit_op = converter.convert(main_op, num_particles)
         self.aux_ops = converter.convert_match(aux_ops)
         self.reference_energy = -1.857275027031588
 
     def test_end2end_h2(self):
         """end to end h2"""
-        backend = BasicAer.get_backend("statevector_simulator")
-        shots = 1
         optimizer = COBYLA(maxiter=1000)
         ryrz = TwoLocal(rotation_blocks=["ry", "rz"], entanglement_blocks="cz")
-        quantum_instance = QuantumInstance(backend, shots=shots)
-        vqe = VQE(ryrz, optimizer=optimizer, quantum_instance=quantum_instance)
+        vqe = VQE(Estimator(), ryrz, optimizer)
         result = vqe.compute_minimum_eigenvalue(self.qubit_op, aux_operators=self.aux_ops)
         self.assertAlmostEqual(result.eigenvalue.real, self.reference_energy, places=4)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `qiskit-nature-0.5.2/test/test_hdf5.py` & `qiskit-nature-0.6.0/test/test_hdf5.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/test_logging.py` & `qiskit-nature-0.6.0/test/test_logging.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2022.
+# (C) Copyright IBM 2022, 2023.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
 # of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
 #
 # Any modifications or derivative works of this code must retain this
 # copyright notice, and modified files need to carry a notice indicating
@@ -24,15 +24,15 @@
 from test import QiskitNatureTestCase
 from qiskit_nature import logging as nature_logging
 
 
 class TestHandler(logging.StreamHandler):
     """Unit Test Handler"""
 
-    def __init__(self):
+    def __init__(self) -> None:
         """
         Initialize the handler.
         """
         super().__init__(sys.stdout)
         self.records: List[logging.LogRecord] = []
 
     def emit(self, record) -> None:
@@ -60,15 +60,15 @@
     def tearDown(self) -> None:
         super().tearDown()
         for name in self._logging_dict:
             nature_logging.remove_handler(name, handler=self._test_handler)
         nature_logging.set_levels_for_names(self._old_logging_dict, add_default_handler=False)
         nature_logging.remove_default_handler(self._logging_dict.keys())
 
-    def _validate_records(self, records):
+    def _validate_records(self, records: dict) -> None:
         name_levels: Dict[str, Set[int]] = {}
         for record in records:
             names = record.name.split(".")
             if names[0] in name_levels:
                 name_levels[names[0]].add(record.levelno)
             else:
                 name_levels[names[0]] = set()
```

### Comparing `qiskit-nature-0.5.2/test/test_readme_sample.py` & `qiskit-nature-0.6.0/test/test_readme_sample.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/BeH_sto3g.hdf5` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/BeH_sto3g.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/BeH_sto3g_reduced.hdf5` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/BeH_sto3g_reduced.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/H2_631g.hdf5` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/H2_631g.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/H2_sto3g.hdf5` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/H2_sto3g.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/H2_sto3g_v2.hdf5` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/H2_sto3g_v2.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/LiH_sto3g.hdf5` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/LiH_sto3g.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/LiH_sto3g_reduced.hdf5` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/LiH_sto3g_reduced.hdf5`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/test_active_space_transformer.py` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/test_active_space_transformer.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/transformers/second_quantization/electronic/test_freeze_core_transformer.py` & `qiskit-nature-0.6.0/test/transformers/second_quantization/electronic/test_freeze_core_transformer.py`

 * *Files identical despite different names*

### Comparing `qiskit-nature-0.5.2/test/utils/test_linalg.py` & `qiskit-nature-0.6.0/test/utils/test_linalg.py`

 * *Files identical despite different names*

