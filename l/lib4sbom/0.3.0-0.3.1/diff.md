# Comparing `tmp/lib4sbom-0.3.0-py2.py3-none-any.whl.zip` & `tmp/lib4sbom-0.3.1-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,33 @@
-Zip file size: 76885 bytes, number of entries: 45
+Zip file size: 78965 bytes, number of entries: 45
 -rw-r--r--  2.0 unx        0 b- defN 23-Jan-24 22:20 examples/__init__.py
 -rw-r--r--  2.0 unx     2233 b- defN 22-Dec-23 12:03 examples/conversion.py
 -rw-r--r--  2.0 unx     1813 b- defN 23-Mar-06 13:22 examples/create.py
 -rw-r--r--  2.0 unx     1057 b- defN 23-Feb-09 21:04 examples/parse.py
 -rw-r--r--  2.0 unx     1455 b- defN 23-Jan-29 22:35 examples/summary.py
 -rw-r--r--  2.0 unx       76 b- defN 23-Mar-23 22:55 lib4sbom/__init__.py
--rw-r--r--  2.0 unx    10975 b- defN 23-Mar-23 22:55 lib4sbom/generator.py
--rw-r--r--  2.0 unx     5106 b- defN 23-Mar-23 22:56 lib4sbom/license.py
--rw-r--r--  2.0 unx     2276 b- defN 23-Mar-06 14:06 lib4sbom/output.py
--rw-r--r--  2.0 unx     4332 b- defN 23-Jan-29 22:03 lib4sbom/parser.py
+-rw-r--r--  2.0 unx    11367 b- defN 23-Apr-11 12:25 lib4sbom/generator.py
+-rw-r--r--  2.0 unx     5855 b- defN 23-Apr-13 09:13 lib4sbom/license.py
+-rw-r--r--  2.0 unx     2484 b- defN 23-Apr-04 12:45 lib4sbom/output.py
+-rw-r--r--  2.0 unx     4304 b- defN 23-Mar-30 20:11 lib4sbom/parser.py
 -rw-r--r--  2.0 unx     1979 b- defN 23-Mar-06 14:00 lib4sbom/sbom.py
--rw-r--r--  2.0 unx      100 b- defN 23-Mar-18 13:41 lib4sbom/version.py
+-rw-r--r--  2.0 unx      100 b- defN 23-Mar-30 11:08 lib4sbom/version.py
 -rw-r--r--  2.0 unx       76 b- defN 23-Mar-23 22:55 lib4sbom/cyclonedx/__init__.py
--rw-r--r--  2.0 unx    12899 b- defN 23-Mar-23 22:55 lib4sbom/cyclonedx/cyclonedx_generator.py
--rw-r--r--  2.0 unx     6412 b- defN 23-Mar-26 15:44 lib4sbom/cyclonedx/cyclonedx_parser.py
+-rw-r--r--  2.0 unx    14327 b- defN 23-Apr-11 10:30 lib4sbom/cyclonedx/cyclonedx_generator.py
+-rw-r--r--  2.0 unx     7833 b- defN 23-Apr-11 12:05 lib4sbom/cyclonedx/cyclonedx_parser.py
 -rw-r--r--  2.0 unx       76 b- defN 23-Mar-23 22:55 lib4sbom/data/__init__.py
 -rw-r--r--  2.0 unx     2088 b- defN 23-Jan-29 22:10 lib4sbom/data/document.py
--rw-r--r--  2.0 unx     3327 b- defN 23-Mar-24 19:16 lib4sbom/data/file.py
--rw-r--r--  2.0 unx     4508 b- defN 23-Jan-30 12:17 lib4sbom/data/package.py
+-rw-r--r--  2.0 unx     3429 b- defN 23-Apr-11 16:20 lib4sbom/data/file.py
+-rw-r--r--  2.0 unx     5998 b- defN 23-Apr-11 22:09 lib4sbom/data/package.py
 -rw-r--r--  2.0 unx     1502 b- defN 23-Feb-13 18:43 lib4sbom/data/relationship.py
--rw-r--r--  2.0 unx      858 b- defN 23-Mar-23 17:38 lib4sbom/license_data/license_synonyms.txt
+-rw-r--r--  2.0 unx     1686 b- defN 23-Apr-13 09:33 lib4sbom/license_data/license_synonyms.txt
 -rw-r--r--  2.0 unx   240843 b- defN 23-Mar-18 12:32 lib4sbom/license_data/spdx_licenses.json
 -rw-r--r--  2.0 unx       76 b- defN 23-Mar-23 22:55 lib4sbom/spdx/__init__.py
--rw-r--r--  2.0 unx    19180 b- defN 23-Mar-23 22:55 lib4sbom/spdx/spdx_generator.py
--rw-r--r--  2.0 unx    21691 b- defN 23-Mar-26 15:32 lib4sbom/spdx/spdx_parser.py
+-rw-r--r--  2.0 unx    19810 b- defN 23-Apr-11 15:45 lib4sbom/spdx/spdx_generator.py
+-rw-r--r--  2.0 unx    22248 b- defN 23-Apr-13 20:12 lib4sbom/spdx/spdx_parser.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Nov-15 14:47 test/__init__.py
 -rw-r--r--  2.0 unx      657 b- defN 23-Jan-25 10:41 test/test_cyclonedx_generator.py
 -rw-r--r--  2.0 unx      274 b- defN 22-Nov-15 18:55 test/test_cyclonedx_parser.py
 -rw-r--r--  2.0 unx     2858 b- defN 23-Jan-29 12:52 test/test_document.py
 -rw-r--r--  2.0 unx     3747 b- defN 23-Mar-24 19:12 test/test_file.py
 -rw-r--r--  2.0 unx      516 b- defN 22-Nov-15 19:16 test/test_generator.py
 -rw-r--r--  2.0 unx      497 b- defN 22-Nov-15 21:40 test/test_output.py
@@ -35,13 +35,13 @@
 -rw-r--r--  2.0 unx      320 b- defN 22-Nov-15 19:16 test/test_parser.py
 -rw-r--r--  2.0 unx     1110 b- defN 23-Feb-09 23:00 test/test_relationship.py
 -rw-r--r--  2.0 unx     5119 b- defN 23-Jan-29 12:22 test/test_sbom.py
 -rw-r--r--  2.0 unx     1160 b- defN 23-Jan-25 10:18 test/test_spdx_generator.py
 -rw-r--r--  2.0 unx      391 b- defN 22-Nov-15 18:55 test/test_spdx_parser.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jan-24 22:19 tools/__init__.py
 -rw-r--r--  2.0 unx     1635 b- defN 22-Nov-15 17:25 tools/generate_pytest.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Mar-27 14:01 lib4sbom-0.3.0.dist-info/LICENSE
--rw-r--r--  2.0 unx    31103 b- defN 23-Mar-27 14:01 lib4sbom-0.3.0.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 23-Mar-27 14:01 lib4sbom-0.3.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       29 b- defN 23-Mar-27 14:01 lib4sbom-0.3.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3610 b- defN 23-Mar-27 14:01 lib4sbom-0.3.0.dist-info/RECORD
-45 files, 415941 bytes uncompressed, 71205 bytes compressed:  82.9%
+-rw-r--r--  2.0 unx    11357 b- defN 23-Apr-14 15:13 lib4sbom-0.3.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx    31669 b- defN 23-Apr-14 15:13 lib4sbom-0.3.1.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Apr-14 15:13 lib4sbom-0.3.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       29 b- defN 23-Apr-14 15:13 lib4sbom-0.3.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3611 b- defN 23-Apr-14 15:13 lib4sbom-0.3.1.dist-info/RECORD
+45 files, 424285 bytes uncompressed, 73285 bytes compressed:  82.7%
```

## zipnote {}

```diff
@@ -114,23 +114,23 @@
 
 Filename: tools/__init__.py
 Comment: 
 
 Filename: tools/generate_pytest.py
 Comment: 
 
-Filename: lib4sbom-0.3.0.dist-info/LICENSE
+Filename: lib4sbom-0.3.1.dist-info/LICENSE
 Comment: 
 
-Filename: lib4sbom-0.3.0.dist-info/METADATA
+Filename: lib4sbom-0.3.1.dist-info/METADATA
 Comment: 
 
-Filename: lib4sbom-0.3.0.dist-info/WHEEL
+Filename: lib4sbom-0.3.1.dist-info/WHEEL
 Comment: 
 
-Filename: lib4sbom-0.3.0.dist-info/top_level.txt
+Filename: lib4sbom-0.3.1.dist-info/top_level.txt
 Comment: 
 
-Filename: lib4sbom-0.3.0.dist-info/RECORD
+Filename: lib4sbom-0.3.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## lib4sbom/generator.py

```diff
@@ -207,26 +207,33 @@
             sem_version = semantic_version.Version(version_spec)
         except ValueError:
             # Version string does not follow semantic version specification
             sem_version = version_spec
         return sem_version
 
     def _get_element(self, name, id=None):
+        default_version = semantic_version.Version("0.0.0")
         check = self.element_set.get(name)
         if check is not None:
             if len(check) > 1:
                 # Duplicate name identified. Match against id
                 # If no version specified, select component with the latest
                 # version based on semantic version ordering
                 # Each element entry is <package id> <version id of form name_version>
-                if id is None:
+                latest_version = default_version
+                if id is None and check[0][1] is not None:
                     latest_version = self._semantic_version(check[0][1].split("_")[-1])
                 index = i = 0
                 for c in check:
                     if id is None:
+                        current_version = default_version
+                        if c[1] is not None:
+                            current_version = self._semantic_version(
+                                c[1].split("_")[-1]
+                            )
                         current_version = self._semantic_version(c[1].split("_")[-1])
                         if current_version > latest_version:
                             latest_version = current_version
                             index = i
                     elif c[1] == id:
                         return c[0]
                     i += 1
```

## lib4sbom/license.py

```diff
@@ -52,72 +52,92 @@
             return self.DEFAULT_LICENSE
         elif license.upper() == "NONE":
             # Maintain value
             return license.upper()
         elif license.startswith("LicenseRef"):
             # Don't process SPDX user defined licenses
             return license
-        for lic in self.licenses["licenses"]:
-            # Comparisons ignore case of provided license text
-            if lic["licenseId"].lower() == license.lower():
-                return lic["licenseId"]
-            elif lic["name"].lower() == license.lower():
-                return lic["licenseId"]
         # Look for synonyms
         license_id = self.check_synonym(license)
-        return license_id if license_id is not None else self.DEFAULT_LICENSE
+        if license_id is not None:
+            return license_id
+        for lic in self.licenses["licenses"]:
+            # Ignore deprecated ids
+            if not lic["isDeprecatedLicenseId"]:
+                # Comparisons ignore case of provided license text
+                if lic["licenseId"].lower() == license.lower():
+                    return lic["licenseId"]
+                elif lic["name"].lower() == license.lower():
+                    return lic["licenseId"]
+        return self.DEFAULT_LICENSE
 
     def get_license_url(self, license_id):
         # Assume that license_id is a valid SPDX id
         if license_id != self.DEFAULT_LICENSE:
             for lic in self.licenses["licenses"]:
                 # License URL is in the seeAlso field.
                 # If multiple entries, just return first one
                 if lic["licenseId"] == license_id:
                     return lic["seeAlso"][0]
         return None  # License not found
 
+    def osi_approved(self, license_id):
+        # Assume that license_id is a valid SPDX id
+        if license_id != self.DEFAULT_LICENSE:
+            for lic in self.licenses["licenses"]:
+                if lic["licenseId"] == license_id:
+                    return lic["isOsiApproved"]
+        return False  # License not found
+
     # License expression processing
 
     def _expression_split(self, expression):
         # Split expression into a list using words in keyword list as separators
         boolean_operator = ["AND", "OR"]
         result = []
         working = expression.replace("(", "").replace(")", "").split(" ")
         word = ""
         for item in working:
             if item.upper() in boolean_operator:
                 # Store word in list
-                result.append(word)
+                if word not in result:
+                    result.append(word)
                 word = ""
             elif len(word) > 0:
                 word = word + " " + item
             else:
                 word = item
         # Store last word if available
         if len(word) > 0:
-            result.append(word)
+            if word not in result:
+                result.append(word)
         return result
 
     def find_license(self, license_expression):
         # Multiple liceneses can be specified and connected using boolean logic.
         # This will preserve any brackets and boolean operators included in the expression
-        updated_expression = license_expression
+        # Ensure case of operators is uppercase
+        updated_expression = (
+            license_expression.replace(" or ", " OR ")
+            .replace(" Or ", " OR ")
+            .replace(" and ", " AND ")
+            .replace(" And ", " AND ")
+        )
         # Remove brackets and split into elements (separated by boolean operators)
         license_information = self._expression_split(license_expression)
         # Now process license information and build up list of valid licenses
         license_data = []
         for license in license_information:
             # Assume we have a license!
             validated_license = self.find_license_id(license)
             license_data.append(validated_license)
             # Update expression if necessary if valid license found
             if validated_license not in [self.DEFAULT_LICENSE, "NONE"]:
                 updated_expression = updated_expression.replace(
-                    license, validated_license, 1
+                    license, validated_license
                 )
         # Return expression if all licenses are valid
         return (
             "NOASSERTION"
             if len(updated_expression) == 0 or self.DEFAULT_LICENSE in license_data
             else updated_expression
         )
```

## lib4sbom/output.py

```diff
@@ -11,15 +11,20 @@
 class _OutputManager:
     """Helper class for managing output to file and console."""
 
     def __init__(self, out_type="file", filename=None):
         self.out_type = out_type
         self.filename = filename
         if self.out_type == "file" and self.filename != "":
-            self.file_handle = open(filename, "w")
+            try:
+                self.file_handle = open(filename, "w")
+            except FileNotFoundError:
+                # Unable to create file, so send output to console
+                self.out_type = "console"
+                self.file_handle = None
         else:
             self.out_type = "console"
             self.file_handle = None
 
     def close(self):
         if self.out_type == "file":
             self.file_handle.close()
```

## lib4sbom/parser.py

```diff
@@ -20,24 +20,15 @@
 
         auto is used to automatically work out the SBOM type
 
         Default is auto
     """
 
     def __init__(self, sbom_type: str = "auto"):
-        if sbom_type == "spdx":
-            self.parser = SPDXParser()
-            self.sbom_type = "spdx"
-        elif sbom_type == "cyclonedx":
-            self.parser = CycloneDXParser()
-            self.sbom_type = "cyclonedx"
-        else:
-            # Default parser is SPDX
-            self.parser = SPDXParser()
-            self.sbom_type = "auto"
+        self.sbom_type = sbom_type
         self.document = None
         self.files = None
         self.packages = None
         self.relationships = None
         self.sbom = SBOM(self.sbom_type)
 
     def parse_file(self, filename: str) -> None:
@@ -57,14 +48,21 @@
             if filePath.exists() and filePath.is_file():
                 # Assume that processing can proceed
                 invalid_file = False
 
         if invalid_file:
             raise FileNotFoundError
 
+        # Set up parser
+        if self.sbom_type == "cyclonedx":
+            self.parser = CycloneDXParser()
+        else:
+            # Default parser is SPDX
+            self.parser = SPDXParser()
+
         if self.sbom_type == "auto":
             # Work out the SBOM type for file
             # Assume SPDX...
             self.sbom_type = "spdx"
             (
                 self.document,
                 self.files,
@@ -91,14 +89,17 @@
         self.sbom.add_files(self.files)
         self.sbom.add_packages(self.packages)
         self.sbom.add_relationships(self.relationships)
         if len(self.document) > 0:
             self.sbom.add_document(self.document.get_document())
         self.sbom.set_type(self.sbom_type)
 
+    def set_type(self, sbom_type: str = "auto") -> None:
+        self.sbom_type = sbom_type
+
     def get_sbom(self) -> SBOMData:
         """Return the constituent components of SBOM
         Returns
         -------
         SBOM : SBOMData object
         """
         return self.sbom.get_sbom()
```

## lib4sbom/version.py

```diff
@@ -1,4 +1,4 @@
 # Copyright (C) 2023 Anthony Harrison
 # SPDX-License-Identifier: Apache-2.0
 
-VERSION: str = "0.3.0"
+VERSION: str = "0.3.1"
```

## lib4sbom/cyclonedx/cyclonedx_generator.py

```diff
@@ -127,14 +127,17 @@
         self.store("<components>")
         return project_id
 
     def generateRelationship(self, parent_id, package_id):
         # Check we have valid ids
         if parent_id is None or package_id is None:
             return
+        # Avoid self->self relationship
+        if parent_id == package_id:
+            return
         # Check if entry exists. If so, update list of dependencies
         element_found = False
         for element in self.relationship:
             if element["ref"] == parent_id:
                 element_found = True
                 # Update list of dependencies if necessary
                 if package_id not in element["dependsOn"]:
@@ -170,17 +173,17 @@
         supplier = " ".join(n for n in names)
         email_address = emails[-1] if len(emails) > 0 else ""
         return supplier.strip(), email_address
 
     def generateJSONComponent(self, id, type, package):
         component = dict()
         if "type" in package:
-            component["type"] = package["type"]
+            component["type"] = package["type"].lower()
         else:
-            component["type"] = type
+            component["type"] = type.lower()
         component["bom-ref"] = id
         name = package["name"]
         component["name"] = name
         if "version" in package:
             version = package["version"]
             component["version"] = version
         if "supplier" in package:
@@ -240,17 +243,26 @@
                 item["license"] = license
                 component["licenses"] = [item]
         if "copyrighttext" in package:
             component["copyright"] = package["copyrighttext"]
         if "homepage" in package:
             externalReference = dict()
             externalReference["url"] = package["homepage"]
-            externalReference["type"] = "other"
+            externalReference["type"] = "website"
             externalReference["comment"] = "Home page for project"
             component["externalReferences"] = [externalReference]
+        if "downloadlocation" in package:
+            externalReference = dict()
+            externalReference["url"] = package["downloadlocation"]
+            externalReference["type"] = "distribution"
+            externalReference["comment"] = "Download location for component"
+            if "externalReferences" in component:
+                component["externalReferences"].append(externalReference)
+            else:
+                component["externalReferences"] = [externalReference]
         if "externalreference" in package:
             # Potentially multiple entries
             for reference in package["externalreference"]:
                 ref_category = reference[0]
                 ref_type = reference[1]
                 ref_value = reference[2]
                 if ref_category == "SECURITY" and ref_type == "cpe23Type":
@@ -265,14 +277,31 @@
                 property_entry = dict()
                 property_entry["name"] = property[0]
                 property_entry["value"] = property[1]
                 if "properties" in component:
                     component["properties"].append(property_entry)
                 else:
                     component["properties"] = [property_entry]
+        # SPDX items with no corresponding entry are created as properties
+        if "licensecomments" in package:
+            property_entry = dict()
+            property_entry["name"] = "License Comments"
+            property_entry["value"] = package["licensecomments"]
+            if "properties" in component:
+                component["properties"].append(property_entry)
+            else:
+                component["properties"] = [property_entry]
+        if "comments" in package:
+            property_entry = dict()
+            property_entry["name"] = "Component Comments"
+            property_entry["value"] = package["comments"]
+            if "properties" in component:
+                component["properties"].append(property_entry)
+            else:
+                component["properties"] = [property_entry]
         self.component.append(component)
 
     def generateXMLComponent(self, id, type, package):
         self.store(f'<component type="{type}" bom-ref="{id}">')
         name = package["name"]
         version = package["version"]
         self.store(f"<name>{name}</name>")
```

## lib4sbom/cyclonedx/cyclonedx_parser.py

```diff
@@ -21,14 +21,15 @@
 
     def parse_cyclonedx_json(self, sbom_file):
         """parses CycloneDX JSON BOM file extracting package name, version and license"""
         data = json.load(open(sbom_file))
         files = {}
         packages = {}
         relationships = []
+        id = {}
         cyclonedx_package = SBOMPackage()
         cyclonedx_relationship = SBOMRelationship()
         cyclonedx_document = SBOMDocument()
         # Check valid CycloneDX JSON file (and not SPDX)
         cyclonedx_json_file = data.get("bomFormat", False)
         if cyclonedx_json_file:
             cyclonedx_document.set_version(data["specVersion"])
@@ -42,29 +43,36 @@
                     )
                 if "authors" in data["metadata"]:
                     cyclonedx_document.set_creator(
                         "person", data["metadata"]["authors"][0]["name"]
                     )
                 if "component" in data["metadata"]:
                     cyclonedx_document.set_name(data["metadata"]["component"]["name"])
+                    id[data["metadata"]["component"]['bom-ref']] = data["metadata"]["component"]["name"]
             for d in data["components"]:
                 cyclonedx_package.initialise()
                 if d["type"] in ["file", "library", "application", "operating-system"]:
                     package = d["name"]
                     cyclonedx_package.set_name(package)
                     if "version" in d:
                         version = d["version"]
                         cyclonedx_package.set_version(version)
                     # Record type of component
                     cyclonedx_package.set_type(d["type"])
                     if "supplier" in d:
                         # Assume that this refers to an organisation
-                        cyclonedx_package.set_supplier(
-                            "Organisation", d["supplier"]["name"]
-                        )
+                        supplier_name = d["supplier"]["name"]
+                        # Check for contact details (email)
+                        if "contact" in d["supplier"]:
+                            for contact in d["supplier"]["contact"]:
+                                if "email" in contact:
+                                    supplier_name = (
+                                        f'{supplier_name} ({contact["email"]})'
+                                    )
+                        cyclonedx_package.set_supplier("Organisation", supplier_name)
                     if "author" in d:
                         # Assume that this refers to an individual
                         cyclonedx_package.set_supplier("Person", d["author"])
                     if "description" in d:
                         cyclonedx_package.set_description(d["description"])
                     if "hashes" in d:
                         # Potentially multiple entries
@@ -106,23 +114,38 @@
                         )
                     if "properties" in d:
                         # Potentially multiple entries
                         for property in d["properties"]:
                             cyclonedx_package.set_property(
                                 property["name"], property["value"]
                             )
+                    if "externalReferences" in d:
+                        # Potentially multiple entries
+                        for reference in d["externalReferences"]:
+                            ref_type = reference["type"]
+                            ref_url = reference["url"]
+                            # Try to map type to package element
+                            if ref_type == "website":
+                                cyclonedx_package.set_homepage(ref_url)
+                            elif ref_type == "distribution":
+                                cyclonedx_package.set_downloadlocation(ref_url)
                     if package not in packages:
                         # Save package metadata
                         packages[package] = cyclonedx_package.get_package()
+                        id[d['bom-ref']] = package
             if "dependencies" in data:
                 # First relationship is assumed to be the root element
                 relationship_type = " DESCRIBES "
                 for d in data["dependencies"]:
-                    source = d["ref"]
-                    for target in d["dependsOn"]:
+                    source_id = d["ref"]
+                    # Get source name
+                    source = id[source_id]
+                    for target_id in d["dependsOn"]:
+                        target = id[target_id]
                         cyclonedx_relationship.initialise()
                         cyclonedx_relationship.set_relationship(
                             source, relationship_type, target
                         )
+                        cyclonedx_relationship.set_relationship_id(source_id, target_id)
                         relationships.append(cyclonedx_relationship.get_relationship())
                     relationship_type = " DEPENDS_ON "
         return cyclonedx_document, files, packages, relationships
```

## lib4sbom/data/file.py

```diff
@@ -7,25 +7,25 @@
 
 
 class SBOMFile:
     def __init__(self):
         self.file = {}
         self.license = LicenseScanner()
 
+    def _text(self, text_item):
+        return text_item.replace("<text>","").replace("</text>","")
+
     def initialise(self):
         self.file = {}
         # Set defaults for mandatory items
         self.set_name("TBD")
         self.set_id("NOT_DEFINED")
 
     def set_name(self, name):
-        if name.startswith("./"):
-            self.file["name"] = name[2:]
-        else:
-            self.file["name"] = name
+        self.file["name"] = name
 
     def set_id(self, id):
         self.file["id"] = id
 
     def set_filetype(self, type):
         file_type = type.upper()
         if file_type not in [
@@ -66,31 +66,32 @@
         # Only include if valid license
         if "licenseinfoinfile" in self.file:
             self.file["licenseinfoinfile"].append(license_id)
         else:
             self.file["licenseinfoinfile"] = [license_id]
 
     def set_licensecomment(self, comment):
-        self.file["licensecomment"] = comment
+        self.file["licensecomment"] = self._text(comment)
 
     def set_copyrighttext(self, text):
-        self.file["copyrighttext"] = text
+        self.file["copyrighttext"] = self._text(text)
 
     def set_comment(self, comment):
-        self.file["comment"] = comment
+        self.file["comment"] = self._text(comment)
 
     def set_notice(self, notice):
-        self.file["notice"] = notice
+        self.file["notice"] = self._text(notice)
 
     def set_contributor(self, name):
-        # Allow multiple entries
-        if "contributor" in self.file:
-            self.file["contributor"].append(name)
-        else:
-            self.file["contributor"] = [name]
+        if len(name) > 0:
+            # Allow multiple entries
+            if "contributor" in self.file:
+                self.file["contributor"].append(name)
+            else:
+                self.file["contributor"] = [name]
 
     def set_attribution(self, attribution):
         self.file["attribution"] = attribution
 
     def set_value(self, key, value):
         self.file[key] = value
```

## lib4sbom/data/package.py

```diff
@@ -1,58 +1,97 @@
 # Copyright (C) 2023 Anthony Harrison
 # SPDX-License-Identifier: Apache-2.0
 
+import re
 import string
 
 from lib4sbom.license import LicenseScanner
 
 
 class SBOMPackage:
     def __init__(self):
         self.package = {}
         self.license = LicenseScanner()
 
+    def _text(self, text_item):
+        return text_item.replace("<text>","").replace("</text>","")
+
+    def _url_valid(self, url):
+        url_pattern = (
+        "(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/|ssh:\\/\\/|git:\\/\\/|svn:\\/\\/|sftp:"
+        "\\/\\/|ftp:\\/\\/)?[a-z0-9]+([\\-\\.]{1}[a-z0-9]+){0,100}\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?"
+        )
+        # Simple check to catch multiple URLs 
+        if " " in url:
+            return False
+        check_url = re.match (url_pattern, url)
+        if check_url is None:
+            # No match
+            return False
+        # Check URL is fully matched
+        return (check_url.group(0) == url)
+
     def initialise(self):
         self.package = {}
 
     def set_name(self, name):
         self.package["name"] = name
 
     def set_id(self, id):
         self.package["id"] = id
 
     def set_type(self, type):
-        self.package["type"] = type
+        # Handle all types as upper case. Handle mismatch of _ and - in SPDX
+        package_type = type.upper().replace("_","-")
+        # Subset of SPDX and CycloneDX types/purpose
+        if package_type in [
+            "APPLICATION",
+            "FRAMEWORK",
+            "LIBRARY",
+            "CONTAINER",
+            "OPERATING-SYSTEM",
+            "DEVICE",
+            "FIRMWARE",
+            "FILE"
+        ]:
+            self.package["type"] = package_type
+        else:
+            # SPDX purpose of OTHER, INSTALL, ARCHIVE, SOURCE not supported by CycloneDX
+            self.package["type"] = "FILE"
 
     def set_version(self, version):
         self.package["version"] = self._semantic_version(version)
         my_id = self.package.get("id")
         my_name = self.get_name()
         if my_id is None and my_name is not None:
             self.set_id(self.get_name() + "_" + str(self.package["version"]))
 
     def set_supplier(self, type, name):
-        self.package["supplier_type"] = type.strip()
-        self.package["supplier"] = name
+        if len(name) > 0:
+            self.package["supplier_type"] = type.strip()
+            self.package["supplier"] = name
 
     def set_originator(self, type, name):
-        self.package["originator_type"] = type.strip()
-        self.package["originator"] = name
+        if len(name) > 0:
+            self.package["originator_type"] = type.strip()
+            self.package["originator"] = name
 
     def set_downloadlocation(self, location):
-        self.package["downloadlocation"] = location
+        if self._url_valid(location):
+            self.package["downloadlocation"] = location
 
     def set_filename(self, filename):
         self.package["filename"] = filename
 
     def set_homepage(self, page):
-        self.package["homepage"] = page
+        if self._url_valid(page):
+            self.package["homepage"] = page
 
     def set_sourceinfo(self, info):
-        self.package["sourceinfo"] = info
+        self.package["sourceinfo"] = self._text(info)
 
     def set_filesanalysis(self, analysis):
         self.package["filesanalysis"] = analysis
 
     def set_checksum(self, type, value):
         # Only store valid checksums
         if self._valid_checksum(value):
@@ -74,15 +113,15 @@
     def set_licenseconcluded(self, license):
         self.package["licenseconcluded"] = license
 
     def set_licensedeclared(self, license):
         self.package["licensedeclared"] = license
 
     def set_licensecomments(self, comment):
-        self.package["licensecomments"] = comment
+        self.package["licensecomments"] = self._text(comment)
 
     def set_licenseinfoinfiles(self, license_info):
         # Validate license
         license_id = self.license.find_license(license_info)
         # Only include if valid license
         if license_id != "UNKNOWN":
             if "licenseinfoinfile" in self.package:
@@ -97,24 +136,24 @@
         reference_entry = [category, type.strip(), locator]
         if "externalreference" in self.package:
             self.package["externalreference"].append(reference_entry)
         else:
             self.package["externalreference"] = [reference_entry]
 
     def set_copyrighttext(self, text):
-        self.package["copyrighttext"] = text
+        self.package["copyrighttext"] = self._text(text)
 
     def set_comment(self, comment):
-        self.package["comment"] = comment
+        self.package["comment"] = self._text(comment)
 
     def set_summary(self, summary):
-        self.package["summary"] = summary
+        self.package["summary"] = self._text(summary)
 
     def set_description(self, description):
-        self.package["description"] = description
+        self.package["description"] = self._text(description)
 
     def set_value(self, key, value):
         self.package[key] = value
 
     def get_package(self):
         return self.package
```

## lib4sbom/license_data/license_synonyms.txt

```diff
@@ -1,69 +1,162 @@
 # LIB4SBOM license synonyms
 [AGPL-3.0-only]
+AGPL3
+AGPL-3
 AGPLv3
+AGPL-3.0
 [AGPL-3.0-or-later]
+AGPL3+
+AGPL-3+
 AGPLv3+
+AGPL-3.0+
 [Apache-2.0]
 Apache Software License
 Apache License, Version 2.0
 Apache 2.0
 Apache_2.0
+Apache2
 Apache 2
 Apache-2
 ASL 2
 ASL 2.0
 Apache
 [Artistic-1.0-Perl]
+Artistic
 Artistic License
 [Artistic-2.0]
+Artistic 2.0
 Artistic License 2
 [Bitstream-Vera]
 Bitstream Vera
+BitstreamVera
+[BSD-2-Clause]
+BSD2
+BSD-2
 [BSD-3-Clause]
 BSD
 BSD License
+BSD3
+BSD-3
+3-Clause BSD
+BSD-3-cluase
+[BSD-4-Clause]
+BSD4
+BSD-4
 [BSL-1.0]
 Boost
+[CC0-1.0]
+CC0
+[CPL-1.0]
+CPL
 [GFDL-1.1-only]
 GFDLv1.1
 [GFDL-1.1-or-later]
 GFDLv1.1+
 [GFDL-1.2-only]
 GFDLv1.2
 [GFDL-1.2-or-later]
 GFDLv1.2+
 [GFDL-1.3-only]
 GFDLv1.3
 [GFDL-1.3-or-later]
 GFDLv1.3+
+[GPL-1.0-only]
+GPL1
+GPL-1
+GPLv1
+GPL-1.0
+[GPL-1.0-or-later]
+GPL+
+GPL1+
+GPL-1+
+GPLv1+
+GPL-1.0+
 [GPL-2.0-only]
+GPL
+GPL2
+GPL-2
 GPLv2
+GPL-2.0
 [GPL-2.0-or-later]
+GPL2+
+GPL-2+
 GPLv2+
+GPL v2 or later
+GNU General Public License GPL, version 2 or later
+GPL-2.0+
 [GPL-3.0-only]
+GPL3
+GPL-3
 GPLv3
+GPL-3.0
 [GPL-3.0-or-later]
+GPL3+
+GPL-3+
 GPLv3+
+GPL-3.0+
 [LGPL-2.0-only]
+LGPL2
+LGPL-2
+LGPL-2.0
 LGPLv2
 [LGPL-2.0-or-later]
 LGPL
+LGPL2+
+LGPL-2+
 LGPLv2+
+LGPL-2.0+
 [LGPL-2.1-only]
+LGPL2.1
+LGPL-2.1
 LGPLv2.1
 [LGPL-2.1-or-later]
+LGPL2.1+
+LGPL-2.1+
 LGPLv2.1+
 [LGPL-3.0-only]
+LGPL3
+LGPL-3
 LGPLv3
+LGPL-3.0
 [LGPL-3.0-or-later]
+LGPL3+
+LGPL-3+
 LGPLv3+
+LGPL-3.0+
+[LPPL-1.3c]
+LPPL
 [MIT]
-MIT/X
+Expat
 [MPL-1.1]
 MPLv1.1
 [MPL-2.0]
 MPLv2.0
+MPL-2
+[OFL-1.1]
+OFL
+SIL-OFL-1.1
+[OLDAP-2.8]
+OpenLDAP-2.8
+[OSL-2.1]
+OSL 2.1
+[OSL-3.0]
+OSL 3.0
 [PSF-2.0]
+PSF-2
 PSFL
 [Python-2.0]
-Python
+Python
+[Ruby]
+RubyLicense
+Ruby License
+[SGI-B-2.0]
+SGI-2
+[X11]
+MIT/X
+MIT/X11
+[ZPL-1.1]
+Zope-1.1
+[ZPL-2.0]
+Zope-2.0
+[ZPL-2.1]
+Zope-2.1
```

## lib4sbom/spdx/spdx_generator.py

```diff
@@ -92,15 +92,15 @@
         self.generateTag("LicenseListVersion", self.license.get_license_version())
         self.generateTag(
             "Creator: Tool", self.application + "-" + self.application_version
         )
         self.generateTag("Created", self.generateTime())
         self.generateTag(
             "CreatorComment",
-            "<text>This document has been automatically generated.</text>",
+            self._text("This document has been automatically generated."),
         )
         return self.SPDX_PROJECT_ID
 
     def generateJSONDocumentHeader(self, project_name):
         # Generate SPDX Document Header
         self.doc["SPDXID"] = self.SPDX_PROJECT_ID
         self.doc["spdxVersion"] = self.SPDX_VERSION
@@ -152,14 +152,19 @@
             if license != "UNKNOWN":
                 derived_license = self.license.find_license(license)
                 if derived_license != "UNKNOWN":
                     return derived_license
                 # Not an SPDX License id
         return "NOASSERTION"
 
+    def _text(file, text_item):
+        if text_item not in ["NONE", "NOASSERTION"]:
+            return f'<text>{text_item}</text>'
+        return text_item
+
     def _file_name(self, name):
         # ensure name is a relative filename
         if name.startswith("/"):
             return name
         elif name.startswith("./"):
             return name
         else:
@@ -173,14 +178,19 @@
         package_id = self.package_ident(id)
         self.generateTag("SPDXID", package_id)
         if "version" in package_info:
             version = package_info["version"]
             self.generateTag("PackageVersion", version)
         elif self.debug:
             print(f"[WARNING] **** version missing for {package}")
+        if "type" in package_info:
+            # Handle SPDX mismatch of - and _ in OPERATING-SYSTEM
+            self.generateTag("PrimaryPackagePurpose", package_info["type"].upper().replace("-","_"))
+        else:
+            self.generateTag("PrimaryPackagePurpose", "LIBRARY")
         if "supplier" in package_info:
             if package_info["supplier_type"] != "UNKNOWN":
                 self.generateTag(
                     "PackageSupplier",
                     package_info["supplier_type"] + ": " + package_info["supplier"],
                 )
             else:
@@ -204,51 +214,53 @@
         if "homepage" in package_info:
             self.generateTag("PackageHomePage", package_info["homepage"])
         if "checksum" in package_info:
             # Potentially multiple entries
             for checksum in package_info["checksum"]:
                 self.generateTag("PackageChecksum", checksum[0] + ": " + checksum[1])
         if "sourceinfo" in package_info:
-            self.generateTag("PackageSourceInfo", package_info["sourceinfo"])
+            self.generateTag("PackageSourceInfo", self._text(package_info["sourceinfo"]))
         if "licensedeclared" in package_info:
             self.generateTag(
                 "PackageLicenseDeclared",
                 package_info["licensedeclared"],
             )
         if "licenseconcluded" in package_info:
             self.generateTag(
                 "PackageLicenseConcluded", package_info["licenseconcluded"]
             )
         if "licensecomments" in package_info:
             self.generateTag(
                 "PackageLicenseComments",
-                f'<text>{package_info["licensecomments"]}</text>',
+                self._text(package_info["licensecomments"]),
             )
         if files_analysed:
             # Only if files have been analysed
             if "licenseinfoinfiles" in package_info:
                 for info in package_info["licenseinfoinfiles"]:
                     self.generateTag(
                         "PackageLicenseInfoFromFiles",
                         self.license_ident(info),
                     )
         if "copyrighttext" in package_info:
-            self.generateTag("PackageCopyrightText", package_info["copyrighttext"])
+            self.generateTag(
+                "PackageCopyrightText", self._text(package_info["copyrighttext"])
+            )
         else:
             self.generateTag("PackageCopyrightText", "NOASSERTION")
         if "description" in package_info:
             self.generateTag(
-                "PackageDescription", f'<text>{package_info["description"]}</text>'
+                "PackageDescription", self._text(package_info["description"])
             )
         if "comment" in package_info:
             self.generateTag(
-                "PackageComment", f'<text>{package_info["comment"]}</text>'
+                "PackageComment", self._text(package_info["comment"])
             )
         if "summary" in package_info:
-            self.generateTag("PackageSummary", package_info["summary"])
+            self.generateTag("PackageSummary", self._text(package_info["summary"]))
         if "externalreference" in package_info:
             # Potentially multiple entries
             for reference in package_info["externalreference"]:
                 self.generateTag(
                     "ExternalRef",
                     reference[0] + " " + reference[1] + " " + reference[2],
                 )
@@ -261,14 +273,18 @@
         component["SPDXID"] = package_id
         component["name"] = package
         if "version" in package_info:
             version = package_info["version"]
             component["versionInfo"] = version
         elif self.debug:
             print(f"[WARNING] **** version missing for {package}")
+        if "type" in package_info:
+            component["primaryPackagePurpose"] = package_info["type"].upper().replace("-","_")
+        else:
+            component["primaryPackagePurpose"] =  "LIBRARY"
         if "supplier" in package_info:
             if package_info["supplier_type"] != "UNKNOWN":
                 component["supplier"] = (
                     package_info["supplier_type"] + ": " + package_info["supplier"]
                 )
             else:
                 component["supplier"] = "NOASSERTION"
@@ -312,20 +328,19 @@
                 for info in package_info["licenseinfoinfile"]:
                     if "licenseInfoInFiles" in component:
                         component["licenseInfoInFiles"].append(self.license_ident(info))
                     else:
                         component["licenseInfoInFiles"] = [self.license_ident(info)]
         component["copyrightText"] = package_info.get("copyrightText", "NOASSERTION")
         if "description" in package_info:
-            component["description"] = f'<text>{package_info["description"]}</text>'
+            component["description"] = fpackage_info["description"]
         if "comment" in package_info:
             component["comment"] = package_info["comment"]
         if "summary" in package_info:
             component["summary"] = package_info["summary"]
-        component["downloadLocation"] = package_info.get("downloadLocation", "NONE")
         if "externalreference" in package_info:
             # Potentially multiple entries
             for reference in package_info["externalreference"]:
                 reference_data = dict()
                 reference_data["referenceCategory"] = reference[0]
                 reference_data["referenceType"] = reference[1]
                 reference_data["referenceLocator"] = reference[2]
@@ -352,22 +367,24 @@
                 "LicenseConcluded", self.license_ident(file_info["licenseconcluded"])
             )
         if "licenseinfoinfile" in file_info:
             for info in file_info["licenseinfoinfile"]:
                 self.generateTag("LicenseInfoInFile", self.license_ident(info))
         if "licensecomment" in file_info:
             self.generateTag(
-                "LicenseComments", f'<text>{file_info["licensecomment"]}</text>'
+                "LicenseComments", self._text(file_info["licensecomment"])
             )
         if "copyrighttext" in file_info:
-            self.generateTag("FileCopyrightText", file_info["copyrighttext"])
+            self.generateTag(
+                "FileCopyrightText", self._text(file_info["copyrighttext"])
+            )
         if "comment" in file_info:
-            self.generateTag("FileComment", f'<text>{file_info["comment"]}</text>')
+            self.generateTag("FileComment", self._text(file_info["comment"]))
         if "notice" in file_info:
-            self.generateTag("FileNotice", file_info["notice"])
+            self.generateTag("FileNotice", self._text(file_info["notice"]))
         if "contributor" in file_info:
             for contributor in file_info["contributor"]:
                 self.generateTag("FileContributor", contributor)
 
     def generateJSONFileDetails(self, file, id, file_info, parent_id, relationship):
         component = dict()
         file_id = self.file_ident(id)
```

## lib4sbom/spdx/spdx_parser.py

```diff
@@ -15,15 +15,18 @@
     def __init__(self):
         pass
 
     def parse(self, sbom_file):
         """parses SPDX SBOM file"""
         if sbom_file.endswith(".spdx"):
             return self.parse_spdx_tag(sbom_file)
-        elif sbom_file.endswith(".spdx.json"):
+        elif sbom_file.endswith((".spdx.json", ".json")):
+            # Convention for SPDX is to use .spdx.json extension but
+            # check any json file just in case. Attempts to parse a CycloneDX JSON
+            # file will result in no data being returned.
             return self.parse_spdx_json(sbom_file)
         elif sbom_file.endswith((".spdx.yaml", "spdx.yml")):
             return self.parse_spdx_yaml(sbom_file)
         else:
             return {}, {}, {}, []
 
     def parse_spdx_tag(self, sbom_file):
@@ -154,15 +157,16 @@
                 spdx_package.initialise()
                 spdx_package.set_name(package)
                 # Default type of component
                 spdx_package.set_type("library")
                 file_element = False
                 element_name = package
             elif line_elements[0] == "PackageVersion":
-                version = line_elements[1].strip().rstrip("\n")
+                # Version may have ':' in version specifier
+                version = line[16:].strip().rstrip("\n")
                 version = version.split("-")[0]
                 version = version.split("+")[0]
                 spdx_package.set_version(version)
                 # Assume ID is after name
                 elements[spdx_id] = element_name
                 if package in versions:
                     versions[package].append(version)
@@ -185,14 +189,17 @@
                     originator_type = line_elements[1]
                     originator = line_elements[2].strip().rstrip("\n")
                 else:
                     # No type specified
                     originator_type = "UNKNOWN"
                     originator = line_elements[1].strip().rstrip("\n")
                 spdx_package.set_originator(originator_type, originator)
+            elif line_elements[0] == "PrimaryPackagePurpose":
+                package_type = line_elements[1]
+                spdx_package.set_type(package_type)
             elif line_elements[0] == "PackageDownloadLocation":
                 downloadlocation = line[24:].strip().rstrip("\n")
                 spdx_package.set_downloadlocation(downloadlocation)
             elif line_elements[0] == "FilesAnalyzed":
                 file_analysis = line_elements[1].strip().rstrip("\n")
                 spdx_package.set_filesanalysis(file_analysis)
             elif line_elements[0] == "PackageChecksum":
@@ -213,16 +220,16 @@
                 spdx_package.set_licensedeclared(license_declared)
             elif line_elements[0] == "PackageLicenseComments":
                 license_comments = line_elements[1].strip().rstrip("\n")
                 spdx_package.set_licensecomments(license_comments)
             elif line_elements[0] == "PackageLicenseInfoFromFiles":
                 license_info = line_elements[1].strip().rstrip("\n")
                 spdx_package.set_licenseinfoinfiles(license_info)
-            elif line_elements[0] == "PackageLicenseCopyrightTest":
-                copyright_text = line_elements[1].strip().rstrip("\n")
+            elif line_elements[0] == "PackageCopyrightText":
+                copyright_text = line[21:].strip().rstrip("\n")
                 spdx_package.set_copyrighttext(copyright_text)
             elif line_elements[0] == "PackageComment":
                 comments = line_elements[1].strip().rstrip("\n")
                 spdx_package.set_comment(comments)
             elif line_elements[0] == "PackageSummary":
                 summary = line_elements[1].strip().rstrip("\n")
                 spdx_package.set_summary(summary)
@@ -352,14 +359,16 @@
                             spdx_package.set_originator(originator[0], originator[1])
                         if "filesAnaylzed" in d:
                             spdx_package.set_filesAnalyzed(d["filesAnaylzed"])
                         if "filename" in d:
                             spdx_package.set_fileName(d["filename"])
                         if "homepage" in d:
                             spdx_package.set_homepage(d["homepage"])
+                        if "primaryPackagePurpose" in d:
+                            spdx_package.set_type(d["primaryPackagePurpose"])
                         if "checksum" in d:
                             # Potentially multiple entries
                             for checksum in d["checksum"]:
                                 spdx_package.set_checksum(
                                     checksum["algorithm"], checksum["checkumValue"]
                                 )
                         if "sourceinfo" in d:
```

## Comparing `lib4sbom-0.3.0.dist-info/LICENSE` & `lib4sbom-0.3.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `lib4sbom-0.3.0.dist-info/METADATA` & `lib4sbom-0.3.1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lib4sbom
-Version: 0.3.0
+Version: 0.3.1
 Summary: Software Bill of Material (SBOM) generator and consumer library
 Home-page: https://github.com/anthonyharrison/lib4sbom
 Author: Anthony Harrison
 Author-email: anthony.p.harrison@gmail.com
 Maintainer: Anthony Harrison
 Maintainer-email: anthony.p.harrison@gmail.com
 License: Apache-2.0
@@ -310,15 +310,15 @@
 
 ### SBOMOutput
 
 _class_ **SBOMOutput**(_filename="", output_format="tag"_)
 
 This creates a simple SBOM Output object. The following optional parameters can be specified:
 
-_filename_ indicates the output destination of the SBOM to be generated. If a valid filename path is provided, then the output will be to a file otherwise
+_filename_ indicates the output destination of the SBOM to be generated. If a valid filename path is provided and a file can be created, then the output will be to a file otherwise
 it will be output to the console.
 
 _output_format_ indicates the format that the SBOM is to be generated in. Valid options are Tag, JSON or YAML. If an invalid format is specified,
 a default format of JSON will be assumed.
 
 **Methods**
 
@@ -502,15 +502,16 @@
 e.g. set_version(). The attribute names are aligned with the attributes of the Package Object in the SPDX Specification. Unless
 indicated, the method just takes a single parameter for the value. Where indicated, multiple instances of the attribute may be defined.
 
 | Attribute         | Multiple | Note |
 |-------------------|----------|------|
 | Name              | No       |      |
 | Id                | No       |      |
-| Checksum          | Yes      | (1)  |
+| Type              | No       | (1)  |
+| Checksum          | Yes      | (2)  |
 | LicenseConcluded  | No       |      |
 | LicenseDeclared   | No       |      |
 | LicenceInfoInFile | Yes      |      |
 | LicenceComments   | No       |      |
 | FilesAnalysis     | No       |      |
 | CopyrightText     | No       |      |
 | Comment           | No       |      |
@@ -524,15 +525,17 @@
 | ExternalReference | Yes      |      |
 | Summary           | No       |      |
 | SourceInfo        | No       |      |
 | Filename          | No       |      |
 
 **Note**
 
-1 The set_checksum method takes two parameters, the checksum algorithm (e.g. SHA256) and the actual checksum value (as a string)
+1 The set_type method is used to indicate the purpose of the package (e.g. Application, Library, Operating-System).
+
+2 The set_checksum method takes two parameters, the checksum algorithm (e.g. SHA256) and the actual checksum value (as a string)
 
 There is an additional setter method, **set_value**(_attribute, value_) which allows the setting of any attribute.
 
 `set_value("language", "Rust")`
 
 **_Getter Methods_**
 
@@ -616,14 +619,17 @@
 
 1. It is assumed that the SBOM is valid and contains syntactically valid data.
 
 2. In SPDX format, the tool assumes that the name of a package preceeds the version and license of the package.
 
 3. In SPDX format, the current implementation does not currently handle multi-line elements.
 
+4. When processing and validating licenses, the application will use a set of synonyms to attempt to map some license identifiers to the correct [SPDX License Identifiers](https://spdx.org/licenses/). However, the
+user of the tool is reminded that they should assert the quality of any data which is provided by the tool particularly where the license identifier has been modified.
+
 ## Future Development
 
 1. Support later versions of SPDX (3.0) and CycloneDX.
 
 2. Enhance validation of SBOM data to check for all mandatory elements.
 
 3. Implement Python typing across modules.
```

## Comparing `lib4sbom-0.3.0.dist-info/RECORD` & `lib4sbom-0.3.1.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 examples/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 examples/conversion.py,sha256=SogVYWznxhz7iG-hUr3dWRyVRW9_XSDHyKj71YtX9ao,2233
 examples/create.py,sha256=iduL-EI9IdZZor1kjnBnsiBXlnUfk3Y9im1DGIIkrxE,1813
 examples/parse.py,sha256=zwA-Cqd2GbW-UuM7u6OKHmns7zi-RvOHzfFq_qUC9cE,1057
 examples/summary.py,sha256=vuG1pN4NLEIFGshrFfzp8U1a8XHIopwT9ZM24fYapBA,1455
 lib4sbom/__init__.py,sha256=UXoScW29szuUhsP-AvPIJLEPeX_U31M1gxYUSooemy8,76
-lib4sbom/generator.py,sha256=1tjiVOdmFCK0Fw_oId9cNiPP8Nt9y_Of5Mu34fUFsMI,10975
-lib4sbom/license.py,sha256=-b4RgefjRjnKl2elv1ZszUhJjkAvW-Wu9lZCqfzhwmQ,5106
-lib4sbom/output.py,sha256=AvO-shOfuAC04ZGvRsjFMajyNn5cHkt4IYyQx5DS8KU,2276
-lib4sbom/parser.py,sha256=wJEYeLu82MRdC-N4fRu_TGbTpi378ag3nH5sD6kR0gI,4332
+lib4sbom/generator.py,sha256=kuQsPwBAMdiTw-tZk4HMgBN7egzEb1N4ixxHyGdpBP0,11367
+lib4sbom/license.py,sha256=V1iiZoRm8HOFwntp20TNHeHdrZE8Re9teLLUYTH2rIU,5855
+lib4sbom/output.py,sha256=WD7AODB8TiiHSFFHLUGxys0sD7nwCy6A2tuQWfaLDZI,2484
+lib4sbom/parser.py,sha256=tCpFfbgsjvbEpRBrJ3BMINVICwySHH3hp662fQG2HGk,4304
 lib4sbom/sbom.py,sha256=5lqlfk_qavRRxGvimfln81paNjIfnmWgyhbn3r7pO88,1979
-lib4sbom/version.py,sha256=_p-y2a7gEF6oU37vmbGAsqrCSIpyaZoCAugkrzEBDQI,100
+lib4sbom/version.py,sha256=CeJcjaiDBO5VCclMviqt24LUhCD_M1wNCUy22wMtojo,100
 lib4sbom/cyclonedx/__init__.py,sha256=UXoScW29szuUhsP-AvPIJLEPeX_U31M1gxYUSooemy8,76
-lib4sbom/cyclonedx/cyclonedx_generator.py,sha256=i8hzJqUZh2KUzVIiu-1h9Tk0KyrIAHAZW-_4XAVb-Tg,12899
-lib4sbom/cyclonedx/cyclonedx_parser.py,sha256=ZSD9DPESJz29mZEtzKbvpx1cvsGLfx3bIRDdGdkICmc,6412
+lib4sbom/cyclonedx/cyclonedx_generator.py,sha256=Mcy_o_dNKi-uK8ODlQ0gqwmj3ArAZErYtJRLq0WwJZQ,14327
+lib4sbom/cyclonedx/cyclonedx_parser.py,sha256=5KUf25G91csG7ytUHdDGw_MRPxcghfaI1Zi5YtMXFsw,7833
 lib4sbom/data/__init__.py,sha256=UXoScW29szuUhsP-AvPIJLEPeX_U31M1gxYUSooemy8,76
 lib4sbom/data/document.py,sha256=pIdBs7znaU-70NGRmrXAAdcrPvjg5b5Qwd0WMNbxQ4Q,2088
-lib4sbom/data/file.py,sha256=0mk_ue-d81FW8q1QSa4dsuoLLUR-1NImjLK3aUF1zTs,3327
-lib4sbom/data/package.py,sha256=20GiEIay5onE4EMXLsbgDnzYtX-EvvSIBoPLkMKRXlo,4508
+lib4sbom/data/file.py,sha256=Z2aYkB0gZP0Jb1g5bA8yLOANdtp5MuYSJhgpMgJh-4A,3429
+lib4sbom/data/package.py,sha256=riIm6Z69-6UIoVF55pePS75n0oc0yx9HhqmtORK2XZo,5998
 lib4sbom/data/relationship.py,sha256=IyMumSksWT2a4RwcK838FLS8fH1nkdyr_gI0-a9NP0U,1502
-lib4sbom/license_data/license_synonyms.txt,sha256=b0rr7N-q4HZ8lGGuk7vyHbdsHJ2TZiR0la63WJyJt-o,858
+lib4sbom/license_data/license_synonyms.txt,sha256=tgNZZGTjhw3f8DGcmy6Ryo8witLag1GbUy9DANc9RoQ,1686
 lib4sbom/license_data/spdx_licenses.json,sha256=hkQj27DG51qxnpzU_fTiKfj2eXlwlj3rRjQaTbYBygU,240843
 lib4sbom/spdx/__init__.py,sha256=UXoScW29szuUhsP-AvPIJLEPeX_U31M1gxYUSooemy8,76
-lib4sbom/spdx/spdx_generator.py,sha256=gqPrx5uBDqqvlX0QAv_o40i31LrPDXIp9cG63sq-Zzc,19180
-lib4sbom/spdx/spdx_parser.py,sha256=mzDFo71mzbJWxfHLvRkuFInzqaY-mqsdEGJcHKyRlZw,21691
+lib4sbom/spdx/spdx_generator.py,sha256=YF9aSyluQ1B-cBUKCX9zSSZQks-AdZ46on2LNpjai6s,19810
+lib4sbom/spdx/spdx_parser.py,sha256=5t3_aFTqLoiu5llkeskl6RDF_uTBPQFqJ_t2abAiecc,22248
 test/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 test/test_cyclonedx_generator.py,sha256=ELzJo4q23ttzXUvivLOcGtuAS_ldWgRftahxGTU_myQ,657
 test/test_cyclonedx_parser.py,sha256=y4JC3Ew8419mc13APaMf18nHxvFlLO9ST9v9EJNtZTE,274
 test/test_document.py,sha256=Rgt-LXC6yb6YO1Sf45UuRQpR1mi61fWzmxGT7RANTkU,2858
 test/test_file.py,sha256=y65_nKsHxq9505tsVJQ-tp0q_2Ji_EoKX3Gv6RUfc-4,3747
 test/test_generator.py,sha256=MeMKx2qgA84M9cvIvXCEZQuwtXURC5Tx15qfHe6nyC0,516
 test/test_output.py,sha256=Ue5zNGU4mMkXbwYSZv_6pHbJRi-C1K3oz7A_O-rIeqg,497
@@ -34,12 +34,12 @@
 test/test_parser.py,sha256=ccVRnxGeRsfA0_jZzy5SX6yxJxji0ThiUB7SQB_zTtQ,320
 test/test_relationship.py,sha256=CN5uawA10QAgkA5tX8eWKWkCn0Vln0LkLMOyX7lhcvk,1110
 test/test_sbom.py,sha256=H7TCElKfBMUt4HQpPJYKWmqCJVbWtyye88xQjW1FMuc,5119
 test/test_spdx_generator.py,sha256=GHtovoyV7sayVcxXriTtvVa-sNCht-02Mvm9viSEacw,1160
 test/test_spdx_parser.py,sha256=diabb1iYvRDJ0w0jnU1bUCVe6Mvz8Yw-5vyUmP5TA34,391
 tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tools/generate_pytest.py,sha256=zYjO5EWSXZps-vMIbL0bF7thFvOYKagyVG3PVAyxHEc,1635
-lib4sbom-0.3.0.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-lib4sbom-0.3.0.dist-info/METADATA,sha256=BMM2eg1vTIkwaguvD8YxMxa8bTW05OmEXiqsa5e7F9w,31103
-lib4sbom-0.3.0.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
-lib4sbom-0.3.0.dist-info/top_level.txt,sha256=8dTJovdik2zvAiNalUJMjqFEMD7RLMd82hdQS_Ktgwc,29
-lib4sbom-0.3.0.dist-info/RECORD,,
+lib4sbom-0.3.1.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+lib4sbom-0.3.1.dist-info/METADATA,sha256=zZsrrBH7FvcdAL-UwSg7gw9FN86w4HXyNOdHgdLxRRY,31669
+lib4sbom-0.3.1.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
+lib4sbom-0.3.1.dist-info/top_level.txt,sha256=8dTJovdik2zvAiNalUJMjqFEMD7RLMd82hdQS_Ktgwc,29
+lib4sbom-0.3.1.dist-info/RECORD,,
```

